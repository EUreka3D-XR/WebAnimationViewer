{"version":3,"file":"splatFileLoader-P7JZmD0g.esm.min.js","sources":["../../../../../dev/core/dist/Shaders/ShadersInclude/gaussianSplattingFragmentDeclaration.js","../../../../../dev/core/dist/Shaders/gaussianSplatting.fragment.js","../../../../../dev/core/dist/Shaders/ShadersInclude/gaussianSplattingVertexDeclaration.js","../../../../../dev/core/dist/Shaders/ShadersInclude/gaussianSplattingUboDeclaration.js","../../../../../dev/core/dist/Shaders/ShadersInclude/gaussianSplatting.js","../../../../../dev/core/dist/Shaders/gaussianSplatting.vertex.js","../../../../../dev/core/dist/ShadersWGSL/ShadersInclude/gaussianSplattingFragmentDeclaration.js","../../../../../dev/core/dist/ShadersWGSL/gaussianSplatting.fragment.js","../../../../../dev/core/dist/ShadersWGSL/ShadersInclude/gaussianSplatting.js","../../../../../dev/core/dist/ShadersWGSL/gaussianSplatting.vertex.js","../../../../../dev/core/dist/Materials/GaussianSplatting/gaussianSplattingMaterial.js","../../../../../dev/core/dist/Maths/math.scalar.js","../../../../../dev/core/dist/Meshes/GaussianSplatting/gaussianSplattingMesh.js","../../../../../dev/core/dist/Particles/pointsCloudSystem.js","../../../../../dev/core/dist/Particles/cloudPoint.js","../../../../../dev/loaders/dist/SPLAT/sog.js","../../../../../dev/loaders/dist/SPLAT/splatFileLoader.js","../../../../../dev/loaders/dist/SPLAT/spz.js"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./logDepthFragment\";\nimport \"./fogFragment\";\nconst name = \"gaussianSplattingFragmentDeclaration\";\nconst shader = `vec4 gaussianColor(vec4 inColor)\n{float A=-dot(vPosition,vPosition);if (A<-4.0) discard;float B=exp(A)*inColor.a;\n#include<logDepthFragment>\nvec3 color=inColor.rgb;\n#ifdef FOG\n#include<fogFragment>\n#endif\nreturn vec4(color,B);}\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingFragmentDeclaration = { name, shader };\n//# sourceMappingURL=gaussianSplattingFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/gaussianSplattingFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nconst name = \"gaussianSplattingPixelShader\";\nconst shader = `#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nvarying vec4 vColor;varying vec2 vPosition;\n#include<gaussianSplattingFragmentDeclaration>\nvoid main () { \n#include<clipPlaneFragment>\ngl_FragColor=gaussianColor(vColor);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingPixelShader = { name, shader };\n//# sourceMappingURL=gaussianSplatting.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nconst name = \"gaussianSplattingVertexDeclaration\";\nconst shader = `attribute vec2 position;uniform mat4 view;uniform mat4 projection;uniform mat4 world;uniform vec4 vEyePosition;`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingVertexDeclaration = { name, shader };\n//# sourceMappingURL=gaussianSplattingVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./sceneUboDeclaration\";\nimport \"./meshUboDeclaration\";\nconst name = \"gaussianSplattingUboDeclaration\";\nconst shader = `#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\nattribute vec2 position;`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingUboDeclaration = { name, shader };\n//# sourceMappingURL=gaussianSplattingUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nconst name = \"gaussianSplatting\";\nconst shader = `#if !defined(WEBGL2) && !defined(WEBGPU) && !defined(NATIVE)\nmat3 transpose(mat3 matrix) {return mat3(matrix[0][0],matrix[1][0],matrix[2][0],\nmatrix[0][1],matrix[1][1],matrix[2][1],\nmatrix[0][2],matrix[1][2],matrix[2][2]);}\n#endif\nvec2 getDataUV(float index,vec2 textureSize) {float y=floor(index/textureSize.x);float x=index-y*textureSize.x;return vec2((x+0.5)/textureSize.x,(y+0.5)/textureSize.y);}\n#if SH_DEGREE>0\nivec2 getDataUVint(float index,vec2 textureSize) {float y=floor(index/textureSize.x);float x=index-y*textureSize.x;return ivec2(uint(x+0.5),uint(y+0.5));}\n#endif\nstruct Splat {vec4 center;vec4 color;vec4 covA;vec4 covB;\n#if SH_DEGREE>0\nuvec4 sh0; \n#endif\n#if SH_DEGREE>1\nuvec4 sh1;\n#endif\n#if SH_DEGREE>2\nuvec4 sh2;\n#endif\n};Splat readSplat(float splatIndex)\n{Splat splat;vec2 splatUV=getDataUV(splatIndex,dataTextureSize);splat.center=texture2D(centersTexture,splatUV);splat.color=texture2D(colorsTexture,splatUV);splat.covA=texture2D(covariancesATexture,splatUV)*splat.center.w;splat.covB=texture2D(covariancesBTexture,splatUV)*splat.center.w;\n#if SH_DEGREE>0\nivec2 splatUVint=getDataUVint(splatIndex,dataTextureSize);splat.sh0=texelFetch(shTexture0,splatUVint,0);\n#endif\n#if SH_DEGREE>1\nsplat.sh1=texelFetch(shTexture1,splatUVint,0);\n#endif\n#if SH_DEGREE>2\nsplat.sh2=texelFetch(shTexture2,splatUVint,0);\n#endif\nreturn splat;}\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nvec3 computeColorFromSHDegree(vec3 dir,const vec3 sh[16])\n{const float SH_C0=0.28209479;const float SH_C1=0.48860251;float SH_C2[5];SH_C2[0]=1.092548430;SH_C2[1]=-1.09254843;SH_C2[2]=0.315391565;SH_C2[3]=-1.09254843;SH_C2[4]=0.546274215;float SH_C3[7];SH_C3[0]=-0.59004358;SH_C3[1]=2.890611442;SH_C3[2]=-0.45704579;SH_C3[3]=0.373176332;SH_C3[4]=-0.45704579;SH_C3[5]=1.445305721;SH_C3[6]=-0.59004358;vec3 result=/*SH_C0**/sh[0];\n#if SH_DEGREE>0\nfloat x=dir.x;float y=dir.y;float z=dir.z;result+=- SH_C1*y*sh[1]+SH_C1*z*sh[2]-SH_C1*x*sh[3];\n#if SH_DEGREE>1\nfloat xx=x*x,yy=y*y,zz=z*z;float xy=x*y,yz=y*z,xz=x*z;result+=\nSH_C2[0]*xy*sh[4] +\nSH_C2[1]*yz*sh[5] +\nSH_C2[2]*(2.0*zz-xx-yy)*sh[6] +\nSH_C2[3]*xz*sh[7] +\nSH_C2[4]*(xx-yy)*sh[8];\n#if SH_DEGREE>2\nresult+=\nSH_C3[0]*y*(3.0*xx-yy)*sh[9] +\nSH_C3[1]*xy*z*sh[10] +\nSH_C3[2]*y*(4.0*zz-xx-yy)*sh[11] +\nSH_C3[3]*z*(2.0*zz-3.0*xx-3.0*yy)*sh[12] +\nSH_C3[4]*x*(4.0*zz-xx-yy)*sh[13] +\nSH_C3[5]*z*(xx-yy)*sh[14] +\nSH_C3[6]*x*(xx-3.0*yy)*sh[15];\n#endif\n#endif\n#endif\nreturn result;}\nvec4 decompose(uint value)\n{vec4 components=vec4(\nfloat((value ) & 255u),\nfloat((value>>uint( 8)) & 255u),\nfloat((value>>uint(16)) & 255u),\nfloat((value>>uint(24)) & 255u));return components*vec4(2./255.)-vec4(1.);}\nvec3 computeSH(Splat splat,vec3 dir)\n{vec3 sh[16];sh[0]=vec3(0.,0.,0.);\n#if SH_DEGREE>0\nvec4 sh00=decompose(splat.sh0.x);vec4 sh01=decompose(splat.sh0.y);vec4 sh02=decompose(splat.sh0.z);sh[1]=vec3(sh00.x,sh00.y,sh00.z);sh[2]=vec3(sh00.w,sh01.x,sh01.y);sh[3]=vec3(sh01.z,sh01.w,sh02.x);\n#endif\n#if SH_DEGREE>1\nvec4 sh03=decompose(splat.sh0.w);vec4 sh04=decompose(splat.sh1.x);vec4 sh05=decompose(splat.sh1.y);sh[4]=vec3(sh02.y,sh02.z,sh02.w);sh[5]=vec3(sh03.x,sh03.y,sh03.z);sh[6]=vec3(sh03.w,sh04.x,sh04.y);sh[7]=vec3(sh04.z,sh04.w,sh05.x);sh[8]=vec3(sh05.y,sh05.z,sh05.w);\n#endif\n#if SH_DEGREE>2\nvec4 sh06=decompose(splat.sh1.z);vec4 sh07=decompose(splat.sh1.w);vec4 sh08=decompose(splat.sh2.x);vec4 sh09=decompose(splat.sh2.y);vec4 sh10=decompose(splat.sh2.z);vec4 sh11=decompose(splat.sh2.w);sh[9]=vec3(sh06.x,sh06.y,sh06.z);sh[10]=vec3(sh06.w,sh07.x,sh07.y);sh[11]=vec3(sh07.z,sh07.w,sh08.x);sh[12]=vec3(sh08.y,sh08.z,sh08.w);sh[13]=vec3(sh09.x,sh09.y,sh09.z);sh[14]=vec3(sh09.w,sh10.x,sh10.y);sh[15]=vec3(sh10.z,sh10.w,sh11.x); \n#endif\nreturn computeColorFromSHDegree(dir,sh);}\n#else\nvec3 computeSH(Splat splat,vec3 dir)\n{return vec3(0.,0.,0.);}\n#endif\nvec4 gaussianSplatting(vec2 meshPos,vec3 worldPos,vec2 scale,vec3 covA,vec3 covB,mat4 worldMatrix,mat4 viewMatrix,mat4 projectionMatrix)\n{mat4 modelView=viewMatrix*worldMatrix;vec4 camspace=viewMatrix*vec4(worldPos,1.);vec4 pos2d=projectionMatrix*camspace;float bounds=1.2*pos2d.w;if (pos2d.z<-pos2d.w || pos2d.x<-bounds || pos2d.x>bounds\n|| pos2d.y<-bounds || pos2d.y>bounds) {return vec4(0.0,0.0,2.0,1.0);}\nmat3 Vrk=mat3(\ncovA.x,covA.y,covA.z,\ncovA.y,covB.x,covB.y,\ncovA.z,covB.y,covB.z\n);mat3 J=mat3(\nfocal.x/camspace.z,0.,-(focal.x*camspace.x)/(camspace.z*camspace.z),\n0.,focal.y/camspace.z,-(focal.y*camspace.y)/(camspace.z*camspace.z),\n0.,0.,0.\n);mat3 invy=mat3(1,0,0,0,-1,0,0,0,1);mat3 T=invy*transpose(mat3(modelView))*J;mat3 cov2d=transpose(T)*Vrk*T;\n#if COMPENSATION\nfloat c00=cov2d[0][0];float c11=cov2d[1][1];float c01=cov2d[0][1];float detOrig=c00*c11-c01*c01;\n#endif\ncov2d[0][0]+=kernelSize;cov2d[1][1]+=kernelSize;\n#if COMPENSATION\nvec3 c2d=vec3(cov2d[0][0],c01,cov2d[1][1]);float detBlur=c2d.x*c2d.z-c2d.y*c2d.y;float compensation=sqrt(max(0.,detOrig/detBlur));vColor.w*=compensation;\n#endif\nfloat mid=(cov2d[0][0]+cov2d[1][1])/2.0;float radius=length(vec2((cov2d[0][0]-cov2d[1][1])/2.0,cov2d[0][1]));float epsilon=0.0001;float lambda1=mid+radius+epsilon,lambda2=mid-radius+epsilon;if (lambda2<0.0)\n{return vec4(0.0,0.0,2.0,1.0);}\nvec2 diagonalVector=normalize(vec2(cov2d[0][1],lambda1-cov2d[0][0]));vec2 majorAxis=min(sqrt(2.0*lambda1),1024.0)*diagonalVector;vec2 minorAxis=min(sqrt(2.0*lambda2),1024.0)*vec2(diagonalVector.y,-diagonalVector.x);vec2 vCenter=vec2(pos2d);return vec4(\nvCenter \n+ ((meshPos.x*majorAxis\n+ meshPos.y*minorAxis)*invViewport*pos2d.w)*scale,pos2d.zw);}`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const gaussianSplatting = { name, shader };\n//# sourceMappingURL=gaussianSplatting.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/gaussianSplattingVertexDeclaration\";\nimport \"./ShadersInclude/gaussianSplattingUboDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/gaussianSplatting\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/logDepthVertex\";\nconst name = \"gaussianSplattingVertexShader\";\nconst shader = `#include<__decl__gaussianSplattingVertex>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<logDepthDeclaration>\n#include<helperFunctions>\nattribute float splatIndex;uniform vec2 invViewport;uniform vec2 dataTextureSize;uniform vec2 focal;uniform float kernelSize;uniform vec3 eyePosition;uniform vec3 viewDirectionFactor;uniform sampler2D covariancesATexture;uniform sampler2D covariancesBTexture;uniform sampler2D centersTexture;uniform sampler2D colorsTexture;\n#if SH_DEGREE>0\nuniform highp usampler2D shTexture0;\n#endif\n#if SH_DEGREE>1\nuniform highp usampler2D shTexture1;\n#endif\n#if SH_DEGREE>2\nuniform highp usampler2D shTexture2;\n#endif\nvarying vec4 vColor;varying vec2 vPosition;\n#include<gaussianSplatting>\nvoid main () {Splat splat=readSplat(splatIndex);vec3 covA=splat.covA.xyz;vec3 covB=vec3(splat.covA.w,splat.covB.xy);vec4 worldPos=world*vec4(splat.center.xyz,1.0);vColor=splat.color;vPosition=position;\n#if SH_DEGREE>0\nmat3 worldRot=mat3(world);mat3 normWorldRot=inverseMat3(worldRot);vec3 dir=normalize(normWorldRot*(worldPos.xyz-eyePosition));dir*=viewDirectionFactor;vColor.xyz=splat.color.xyz+computeSH(splat,dir);\n#endif\ngl_Position=gaussianSplatting(position,worldPos.xyz,vec2(1.,1.),covA,covB,world,view,projection);\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<logDepthVertex>\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingVertexShader = { name, shader };\n//# sourceMappingURL=gaussianSplatting.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./logDepthFragment\";\nimport \"./fogFragment\";\nconst name = \"gaussianSplattingFragmentDeclaration\";\nconst shader = `fn gaussianColor(inColor: vec4f,inPosition: vec2f)->vec4f\n{var A : f32=-dot(inPosition,inPosition);if (A>-4.0)\n{var B: f32=exp(A)*inColor.a;\n#include<logDepthFragment>\nvar color: vec3f=inColor.rgb;\n#ifdef FOG\n#include<fogFragment>\n#endif\nreturn vec4f(color,B);} else {return vec4f(0.0);}}\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStoreWGSL[name]) {\n    ShaderStore.IncludesShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingFragmentDeclarationWGSL = { name, shader };\n//# sourceMappingURL=gaussianSplattingFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/gaussianSplattingFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nconst name = \"gaussianSplattingPixelShader\";\nconst shader = `#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nvarying vColor: vec4f;varying vPosition: vec2f;\n#include<gaussianSplattingFragmentDeclaration>\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#include<clipPlaneFragment>\nfragmentOutputs.color=gaussianColor(input.vColor,input.vPosition);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingPixelShaderWGSL = { name, shader };\n//# sourceMappingURL=gaussianSplatting.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nconst name = \"gaussianSplatting\";\nconst shader = `fn getDataUV(index: f32,dataTextureSize: vec2f)->vec2<f32> {let y: f32=floor(index/dataTextureSize.x);let x: f32=index-y*dataTextureSize.x;return vec2f((x+0.5),(y+0.5));}\nstruct Splat {center: vec4f,\ncolor: vec4f,\ncovA: vec4f,\ncovB: vec4f,\n#if SH_DEGREE>0\nsh0: vec4<u32>,\n#endif\n#if SH_DEGREE>1\nsh1: vec4<u32>,\n#endif\n#if SH_DEGREE>2\nsh2: vec4<u32>,\n#endif\n};fn readSplat(splatIndex: f32,dataTextureSize: vec2f)->Splat {var splat: Splat;let splatUV=getDataUV(splatIndex,dataTextureSize);let splatUVi32=vec2<i32>(i32(splatUV.x),i32(splatUV.y));splat.center=textureLoad(centersTexture,splatUVi32,0);splat.color=textureLoad(colorsTexture,splatUVi32,0);splat.covA=textureLoad(covariancesATexture,splatUVi32,0)*splat.center.w;splat.covB=textureLoad(covariancesBTexture,splatUVi32,0)*splat.center.w;\n#if SH_DEGREE>0\nsplat.sh0=textureLoad(shTexture0,splatUVi32,0);\n#endif\n#if SH_DEGREE>1\nsplat.sh1=textureLoad(shTexture1,splatUVi32,0);\n#endif\n#if SH_DEGREE>2\nsplat.sh2=textureLoad(shTexture2,splatUVi32,0);\n#endif\nreturn splat;}\nfn computeColorFromSHDegree(dir: vec3f,sh: array<vec3<f32>,16>)->vec3f\n{let SH_C0: f32=0.28209479;let SH_C1: f32=0.48860251;var SH_C2: array<f32,5>=array<f32,5>(\n1.092548430,\n-1.09254843,\n0.315391565,\n-1.09254843,\n0.546274215\n);var SH_C3: array<f32,7>=array<f32,7>(\n-0.59004358,\n2.890611442,\n-0.45704579,\n0.373176332,\n-0.45704579,\n1.445305721,\n-0.59004358\n);var result: vec3f=/*SH_C0**/sh[0];\n#if SH_DEGREE>0\nlet x: f32=dir.x;let y: f32=dir.y;let z: f32=dir.z;result+=-SH_C1*y*sh[1]+SH_C1*z*sh[2]-SH_C1*x*sh[3];\n#if SH_DEGREE>1\nlet xx: f32=x*x;let yy: f32=y*y;let zz: f32=z*z;let xy: f32=x*y;let yz: f32=y*z;let xz: f32=x*z;result+=\nSH_C2[0]*xy*sh[4] +\nSH_C2[1]*yz*sh[5] +\nSH_C2[2]*(2.0f*zz-xx-yy)*sh[6] +\nSH_C2[3]*xz*sh[7] +\nSH_C2[4]*(xx-yy)*sh[8];\n#if SH_DEGREE>2\nresult+=\nSH_C3[0]*y*(3.0f*xx-yy)*sh[9] +\nSH_C3[1]*xy*z*sh[10] +\nSH_C3[2]*y*(4.0f*zz-xx-yy)*sh[11] +\nSH_C3[3]*z*(2.0f*zz-3.0f*xx-3.0f*yy)*sh[12] +\nSH_C3[4]*x*(4.0f*zz-xx-yy)*sh[13] +\nSH_C3[5]*z*(xx-yy)*sh[14] +\nSH_C3[6]*x*(xx-3.0f*yy)*sh[15];\n#endif\n#endif\n#endif\nreturn result;}\nfn decompose(value: u32)->vec4f\n{let components : vec4f=vec4f(\nf32((value ) & 255u),\nf32((value>>u32( 8)) & 255u),\nf32((value>>u32(16)) & 255u),\nf32((value>>u32(24)) & 255u));return components*vec4f(2./255.)-vec4f(1.);}\nfn computeSH(splat: Splat,dir: vec3f)->vec3f\n{var sh: array<vec3<f32>,16>;sh[0]=vec3f(0.,0.,0.);\n#if SH_DEGREE>0\nlet sh00: vec4f=decompose(splat.sh0.x);let sh01: vec4f=decompose(splat.sh0.y);let sh02: vec4f=decompose(splat.sh0.z);sh[1]=vec3f(sh00.x,sh00.y,sh00.z);sh[2]=vec3f(sh00.w,sh01.x,sh01.y);sh[3]=vec3f(sh01.z,sh01.w,sh02.x);\n#endif\n#if SH_DEGREE>1\nlet sh03: vec4f=decompose(splat.sh0.w);let sh04: vec4f=decompose(splat.sh1.x);let sh05: vec4f=decompose(splat.sh1.y);sh[4]=vec3f(sh02.y,sh02.z,sh02.w);sh[5]=vec3f(sh03.x,sh03.y,sh03.z);sh[6]=vec3f(sh03.w,sh04.x,sh04.y);sh[7]=vec3f(sh04.z,sh04.w,sh05.x);sh[8]=vec3f(sh05.y,sh05.z,sh05.w);\n#endif\n#if SH_DEGREE>2\nlet sh06: vec4f=decompose(splat.sh1.z);let sh07: vec4f=decompose(splat.sh1.w);let sh08: vec4f=decompose(splat.sh2.x);let sh09: vec4f=decompose(splat.sh2.y);let sh10: vec4f=decompose(splat.sh2.z);let sh11: vec4f=decompose(splat.sh2.w);sh[9]=vec3f(sh06.x,sh06.y,sh06.z);sh[10]=vec3f(sh06.w,sh07.x,sh07.y);sh[11]=vec3f(sh07.z,sh07.w,sh08.x);sh[12]=vec3f(sh08.y,sh08.z,sh08.w);sh[13]=vec3f(sh09.x,sh09.y,sh09.z);sh[14]=vec3f(sh09.w,sh10.x,sh10.y);sh[15]=vec3f(sh10.z,sh10.w,sh11.x); \n#endif\nreturn computeColorFromSHDegree(dir,sh);}\nfn gaussianSplatting(\nmeshPos: vec2<f32>,\nworldPos: vec3<f32>,\nscale: vec2<f32>,\ncovA: vec3<f32>,\ncovB: vec3<f32>,\nworldMatrix: mat4x4<f32>,\nviewMatrix: mat4x4<f32>,\nprojectionMatrix: mat4x4<f32>,\nfocal: vec2f,\ninvViewport: vec2f,\nkernelSize: f32\n)->vec4f {let modelView=viewMatrix*worldMatrix;let camspace=viewMatrix*vec4f(worldPos,1.0);let pos2d=projectionMatrix*camspace;let bounds=1.2*pos2d.w;if (pos2d.z<0. || pos2d.x<-bounds || pos2d.x>bounds || pos2d.y<-bounds || pos2d.y>bounds) {return vec4f(0.0,0.0,2.0,1.0);}\nlet Vrk=mat3x3<f32>(\ncovA.x,covA.y,covA.z,\ncovA.y,covB.x,covB.y,\ncovA.z,covB.y,covB.z\n);let J=mat3x3<f32>(\nfocal.x/camspace.z,0.0,-(focal.x*camspace.x)/(camspace.z*camspace.z),\n0.0,focal.y/camspace.z,-(focal.y*camspace.y)/(camspace.z*camspace.z),\n0.0,0.0,0.0\n);let invy=mat3x3<f32>(\n1.0,0.0,0.0,\n0.0,-1.0,0.0,\n0.0,0.0,1.0\n);let T=invy*transpose(mat3x3<f32>(\nmodelView[0].xyz,\nmodelView[1].xyz,\nmodelView[2].xyz))*J;var cov2d=transpose(T)*Vrk*T;\n#if COMPENSATION\nlet c00: f32=cov2d[0][0];let c11: f32=cov2d[1][1];let c01: f32=cov2d[0][1];let detOrig: f32=c00*c11-c01*c01;\n#endif\ncov2d[0][0]+=kernelSize;cov2d[1][1]+=kernelSize;\n#if COMPENSATION\nlet c2d: vec3f=vec3f(cov2d[0][0],c01,cov2d[1][1]);let detBlur: f32=c2d.x*c2d.z-c2d.y*c2d.y;let compensation: f32=sqrt(max(0.,detOrig/detBlur));vertexOutputs.vColor.w*=compensation;\n#endif\nlet mid=(cov2d[0][0]+cov2d[1][1])/2.0;let radius=length(vec2<f32>((cov2d[0][0]-cov2d[1][1])/2.0,cov2d[0][1]));let lambda1=mid+radius;let lambda2=mid-radius;if (lambda2<0.0) {return vec4f(0.0,0.0,2.0,1.0);}\nlet diagonalVector=normalize(vec2<f32>(cov2d[0][1],lambda1-cov2d[0][0]));let majorAxis=min(sqrt(2.0*lambda1),1024.0)*diagonalVector;let minorAxis=min(sqrt(2.0*lambda2),1024.0)*vec2<f32>(diagonalVector.y,-diagonalVector.x);let vCenter=vec2<f32>(pos2d.x,pos2d.y);return vec4f(\nvCenter+((meshPos.x*majorAxis+meshPos.y*minorAxis)*invViewport*pos2d.w)*scale,\npos2d.z,\npos2d.w\n);}\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStoreWGSL[name]) {\n    ShaderStore.IncludesShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingWGSL = { name, shader };\n//# sourceMappingURL=gaussianSplatting.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/sceneUboDeclaration\";\nimport \"./ShadersInclude/meshUboDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/gaussianSplatting\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/logDepthVertex\";\nconst name = \"gaussianSplattingVertexShader\";\nconst shader = `#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n#include<helperFunctions>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<logDepthDeclaration>\nattribute splatIndex: f32;attribute position: vec2f;uniform invViewport: vec2f;uniform dataTextureSize: vec2f;uniform focal: vec2f;uniform kernelSize: f32;uniform eyePosition: vec3f;uniform viewDirectionFactor: vec3f;var covariancesATexture: texture_2d<f32>;var covariancesBTexture: texture_2d<f32>;var centersTexture: texture_2d<f32>;var colorsTexture: texture_2d<f32>;\n#if SH_DEGREE>0\nvar shTexture0: texture_2d<u32>;\n#endif\n#if SH_DEGREE>1\nvar shTexture1: texture_2d<u32>;\n#endif\n#if SH_DEGREE>2\nvar shTexture2: texture_2d<u32>;\n#endif\nvarying vColor: vec4f;varying vPosition: vec2f;\n#include<gaussianSplatting>\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {var splat: Splat=readSplat(input.splatIndex,uniforms.dataTextureSize);var covA: vec3f=splat.covA.xyz;var covB: vec3f=vec3f(splat.covA.w,splat.covB.xy);let worldPos: vec4f=mesh.world*vec4f(splat.center.xyz,1.0);vertexOutputs.vPosition=input.position;\n#if SH_DEGREE>0\nlet worldRot: mat3x3f= mat3x3f(mesh.world[0].xyz,mesh.world[1].xyz,mesh.world[2].xyz);let normWorldRot: mat3x3f=inverseMat3(worldRot);var dir: vec3f=normalize(normWorldRot*(worldPos.xyz-uniforms.eyePosition.xyz));dir*=uniforms.viewDirectionFactor;vertexOutputs.vColor=vec4f(splat.color.xyz+computeSH(splat,dir),splat.color.w);\n#else\nvertexOutputs.vColor=splat.color;\n#endif\nvertexOutputs.position=gaussianSplatting(input.position,worldPos.xyz,vec2f(1.0,1.0),covA,covB,mesh.world,scene.view,scene.projection,uniforms.focal,uniforms.invViewport,uniforms.kernelSize);\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<logDepthVertex>\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingVertexShaderWGSL = { name, shader };\n//# sourceMappingURL=gaussianSplatting.vertex.js.map","import { SerializationHelper } from \"../../Misc/decorators.serialization\";\nimport { VertexBuffer } from \"../../Buffers/buffer\";\nimport { MaterialDefines } from \"../../Materials/materialDefines\";\nimport { PushMaterial } from \"../../Materials/pushMaterial\";\nimport { RegisterClass } from \"../../Misc/typeStore\";\nimport { AddClipPlaneUniforms, BindClipPlane } from \"../clipPlaneMaterialHelper\";\nimport { Camera } from \"core/Cameras/camera\";\nimport \"../../Shaders/gaussianSplatting.fragment\";\nimport \"../../Shaders/gaussianSplatting.vertex\";\nimport \"../../ShadersWGSL/gaussianSplatting.fragment\";\nimport \"../../ShadersWGSL/gaussianSplatting.vertex\";\nimport { BindFogParameters, BindLogDepth, PrepareAttributesForInstances, PrepareDefinesForAttributes, PrepareDefinesForFrameBoundValues, PrepareDefinesForMisc, PrepareUniformsAndSamplersList, } from \"../materialHelper.functions\";\n/**\n * @internal\n */\nclass GaussianSplattingMaterialDefines extends MaterialDefines {\n    /**\n     * Constructor of the defines.\n     */\n    constructor() {\n        super();\n        this.FOG = false;\n        this.THIN_INSTANCES = true;\n        this.LOGARITHMICDEPTH = false;\n        this.CLIPPLANE = false;\n        this.CLIPPLANE2 = false;\n        this.CLIPPLANE3 = false;\n        this.CLIPPLANE4 = false;\n        this.CLIPPLANE5 = false;\n        this.CLIPPLANE6 = false;\n        this.SH_DEGREE = 0;\n        this.COMPENSATION = false;\n        this.rebuild();\n    }\n}\n/**\n * GaussianSplattingMaterial material used to render Gaussian Splatting\n * @experimental\n */\nexport class GaussianSplattingMaterial extends PushMaterial {\n    /**\n     * Instantiates a Gaussian Splatting Material in the given scene\n     * @param name The friendly name of the material\n     * @param scene The scene to add the material to\n     */\n    constructor(name, scene) {\n        super(name, scene);\n        /**\n         * Point spread function (default 0.3). Can be overriden per GS material, otherwise, using default static `KernelSize` value\n         */\n        this.kernelSize = GaussianSplattingMaterial.KernelSize;\n        this._compensation = GaussianSplattingMaterial.Compensation;\n        // set to true when material defines are dirty\n        this._isDirty = false;\n        this.backFaceCulling = false;\n    }\n    /**\n     * Set compensation default value is `GaussianSplattingMaterial.Compensation`\n     */\n    set compensation(value) {\n        this._isDirty = this._isDirty != value;\n        this._compensation = value;\n    }\n    /**\n     * Get compensation\n     */\n    get compensation() {\n        return this._compensation;\n    }\n    /**\n     * Gets a boolean indicating that current material needs to register RTT\n     */\n    get hasRenderTargetTextures() {\n        return false;\n    }\n    /**\n     * Specifies whether or not this material should be rendered in alpha test mode.\n     * @returns false\n     */\n    needAlphaTesting() {\n        return false;\n    }\n    /**\n     * Specifies whether or not this material should be rendered in alpha blend mode.\n     * @returns true\n     */\n    needAlphaBlending() {\n        return true;\n    }\n    /**\n     * Checks whether the material is ready to be rendered for a given mesh.\n     * @param mesh The mesh to render\n     * @param subMesh The submesh to check against\n     * @returns true if all the dependencies are ready (Textures, Effects...)\n     */\n    isReadyForSubMesh(mesh, subMesh) {\n        const useInstances = true;\n        const drawWrapper = subMesh._drawWrapper;\n        let defines = subMesh.materialDefines;\n        if (defines && this._isDirty) {\n            defines.markAsUnprocessed();\n        }\n        if (drawWrapper.effect && this.isFrozen) {\n            if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\n                return true;\n            }\n        }\n        if (!subMesh.materialDefines) {\n            defines = subMesh.materialDefines = new GaussianSplattingMaterialDefines();\n        }\n        const scene = this.getScene();\n        if (this._isReadyForSubMesh(subMesh)) {\n            return true;\n        }\n        const engine = scene.getEngine();\n        const gsMesh = mesh;\n        // Misc.\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, false, defines, undefined, undefined, undefined, this._setVertexOutputInvariant);\n        // Values that need to be evaluated on every frame\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, true);\n        // Attribs\n        PrepareDefinesForAttributes(mesh, defines, false, false);\n        // SH is disabled for webGL1\n        if (engine.version > 1 || engine.isWebGPU) {\n            defines[\"SH_DEGREE\"] = gsMesh.shDegree;\n        }\n        // Compensation\n        const splatMaterial = gsMesh.material;\n        defines[\"COMPENSATION\"] = splatMaterial && splatMaterial.compensation ? splatMaterial.compensation : GaussianSplattingMaterial.Compensation;\n        // Get correct effect\n        if (defines.isDirty) {\n            defines.markAsProcessed();\n            scene.resetCachedMaterial();\n            //Attributes\n            const attribs = [VertexBuffer.PositionKind, \"splatIndex\"];\n            PrepareAttributesForInstances(attribs, defines);\n            const uniforms = [\n                \"world\",\n                \"view\",\n                \"projection\",\n                \"vFogInfos\",\n                \"vFogColor\",\n                \"logarithmicDepthConstant\",\n                \"invViewport\",\n                \"dataTextureSize\",\n                \"focal\",\n                \"eyePosition\",\n                \"kernelSize\",\n                \"viewDirectionFactor\",\n            ];\n            const samplers = [\"covariancesATexture\", \"covariancesBTexture\", \"centersTexture\", \"colorsTexture\", \"shTexture0\", \"shTexture1\", \"shTexture2\"];\n            const uniformBuffers = [\"Scene\", \"Mesh\"];\n            PrepareUniformsAndSamplersList({\n                uniformsNames: uniforms,\n                uniformBuffersNames: uniformBuffers,\n                samplers: samplers,\n                defines: defines,\n            });\n            AddClipPlaneUniforms(uniforms);\n            const join = defines.toString();\n            const effect = scene.getEngine().createEffect(\"gaussianSplatting\", {\n                attributes: attribs,\n                uniformsNames: uniforms,\n                uniformBuffersNames: uniformBuffers,\n                samplers: samplers,\n                defines: join,\n                onCompiled: this.onCompiled,\n                onError: this.onError,\n                indexParameters: {},\n                shaderLanguage: this._shaderLanguage,\n                extraInitializationsAsync: async () => {\n                    if (this._shaderLanguage === 1 /* ShaderLanguage.WGSL */) {\n                        await Promise.all([import(\"../../ShadersWGSL/gaussianSplatting.fragment\"), import(\"../../ShadersWGSL/gaussianSplatting.vertex\")]);\n                    }\n                    else {\n                        await Promise.all([import(\"../../Shaders/gaussianSplatting.fragment\"), import(\"../../Shaders/gaussianSplatting.vertex\")]);\n                    }\n                },\n            }, engine);\n            subMesh.setEffect(effect, defines, this._materialContext);\n        }\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\n            return false;\n        }\n        defines._renderId = scene.getRenderId();\n        drawWrapper._wasPreviouslyReady = true;\n        drawWrapper._wasPreviouslyUsingInstances = useInstances;\n        this._isDirty = false;\n        return true;\n    }\n    /**\n     * Bind material effect for a specific Gaussian Splatting mesh\n     * @param mesh Gaussian splatting mesh\n     * @param effect Splatting material or node material\n     * @param scene scene that contains mesh and camera used for rendering\n     */\n    static BindEffect(mesh, effect, scene) {\n        const engine = scene.getEngine();\n        const camera = scene.activeCamera;\n        const renderWidth = engine.getRenderWidth();\n        const renderHeight = engine.getRenderHeight();\n        const gsMesh = mesh;\n        const gsMaterial = gsMesh.material;\n        // check if rigcamera, get number of rigs\n        const numberOfRigs = camera?.rigParent?.rigCameras.length || 1;\n        effect.setFloat2(\"invViewport\", 1 / (renderWidth / numberOfRigs), 1 / renderHeight);\n        let focal = 1000;\n        if (camera) {\n            /*\n            more explicit version:\n            const t = camera.getProjectionMatrix().m[5];\n            const FovY = Math.atan(1.0 / t) * 2.0;\n            focal = renderHeight / 2.0 / Math.tan(FovY / 2.0);\n            Using a shorter version here to not have tan(atan) and 2.0 factor\n            */\n            const t = camera.getProjectionMatrix().m[5];\n            if (camera.fovMode == Camera.FOVMODE_VERTICAL_FIXED) {\n                focal = (renderHeight * t) / 2.0;\n            }\n            else {\n                focal = (renderWidth * t) / 2.0;\n            }\n        }\n        effect.setFloat2(\"focal\", focal, focal);\n        effect.setVector3(\"viewDirectionFactor\", gsMesh.viewDirectionFactor);\n        effect.setFloat(\"kernelSize\", gsMaterial && gsMaterial.kernelSize ? gsMaterial.kernelSize : GaussianSplattingMaterial.KernelSize);\n        scene.bindEyePosition(effect, \"eyePosition\", true);\n        if (gsMesh.covariancesATexture) {\n            const textureSize = gsMesh.covariancesATexture.getSize();\n            effect.setFloat2(\"dataTextureSize\", textureSize.width, textureSize.height);\n            effect.setTexture(\"covariancesATexture\", gsMesh.covariancesATexture);\n            effect.setTexture(\"covariancesBTexture\", gsMesh.covariancesBTexture);\n            effect.setTexture(\"centersTexture\", gsMesh.centersTexture);\n            effect.setTexture(\"colorsTexture\", gsMesh.colorsTexture);\n            if (gsMesh.shTextures) {\n                for (let i = 0; i < gsMesh.shTextures?.length; i++) {\n                    effect.setTexture(`shTexture${i}`, gsMesh.shTextures[i]);\n                }\n            }\n        }\n    }\n    /**\n     * Binds the submesh to this material by preparing the effect and shader to draw\n     * @param world defines the world transformation matrix\n     * @param mesh defines the mesh containing the submesh\n     * @param subMesh defines the submesh to bind the material to\n     */\n    bindForSubMesh(world, mesh, subMesh) {\n        const scene = this.getScene();\n        const defines = subMesh.materialDefines;\n        if (!defines) {\n            return;\n        }\n        const effect = subMesh.effect;\n        if (!effect) {\n            return;\n        }\n        this._activeEffect = effect;\n        // Matrices Mesh.\n        mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\n        mesh.transferToEffect(world);\n        // Bind data\n        const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);\n        if (mustRebind) {\n            this.bindView(effect);\n            this.bindViewProjection(effect);\n            GaussianSplattingMaterial.BindEffect(mesh, this._activeEffect, scene);\n            // Clip plane\n            BindClipPlane(effect, this, scene);\n        }\n        else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {\n            this._needToBindSceneUbo = true;\n        }\n        // Fog\n        BindFogParameters(scene, mesh, effect);\n        // Log. depth\n        if (this.useLogarithmicDepth) {\n            BindLogDepth(defines, effect, scene);\n        }\n        this._afterBind(mesh, this._activeEffect, subMesh);\n    }\n    /**\n     * Clones the material.\n     * @param name The cloned name.\n     * @returns The cloned material.\n     */\n    clone(name) {\n        return SerializationHelper.Clone(() => new GaussianSplattingMaterial(name, this.getScene()), this);\n    }\n    /**\n     * Serializes the current material to its JSON representation.\n     * @returns The JSON representation.\n     */\n    serialize() {\n        const serializationObject = super.serialize();\n        serializationObject.customType = \"BABYLON.GaussianSplattingMaterial\";\n        return serializationObject;\n    }\n    /**\n     * Gets the class name of the material\n     * @returns \"GaussianSplattingMaterial\"\n     */\n    getClassName() {\n        return \"GaussianSplattingMaterial\";\n    }\n    /**\n     * Parse a JSON input to create back a Gaussian Splatting material.\n     * @param source The JSON data to parse\n     * @param scene The scene to create the parsed material in\n     * @param rootUrl The root url of the assets the material depends upon\n     * @returns the instantiated GaussianSplattingMaterial.\n     */\n    static Parse(source, scene, rootUrl) {\n        return SerializationHelper.Parse(() => new GaussianSplattingMaterial(source.name, scene), source, scene, rootUrl);\n    }\n}\n/**\n * Point spread function (default 0.3). Can be overriden per GS material\n */\nGaussianSplattingMaterial.KernelSize = 0.3;\n/**\n * Compensation\n */\nGaussianSplattingMaterial.Compensation = false;\nRegisterClass(\"BABYLON.GaussianSplattingMaterial\", GaussianSplattingMaterial);\n//# sourceMappingURL=gaussianSplattingMaterial.js.map","/* eslint-disable @typescript-eslint/naming-convention */\nimport * as functions from \"./math.scalar.functions\";\nconst HCF = functions.HighestCommonFactor;\n/**\n * Scalar computation library\n */\nexport const Scalar = {\n    ...functions,\n    /**\n     * Two pi constants convenient for computation.\n     */\n    TwoPi: Math.PI * 2,\n    /**\n     * Returns -1 if value is negative and +1 is value is positive.\n     * @param value the value\n     * @returns the value itself if it's equal to zero.\n     */\n    Sign: Math.sign,\n    /**\n     * the log2 of value.\n     * @param value the value to compute log2 of\n     * @returns the log2 of value.\n     */\n    Log2: Math.log2,\n    /**\n     * Returns the highest common factor of two integers.\n     * @param a first parameter\n     * @param b second parameter\n     * @returns HCF of a and b\n     */\n    HCF,\n};\n/* eslint-enable @typescript-eslint/naming-convention */\n//# sourceMappingURL=math.scalar.js.map","import { SubMesh } from \"../subMesh\";\nimport { Mesh } from \"../mesh\";\nimport { VertexData } from \"../mesh.vertexData\";\nimport { Matrix, TmpVectors, Vector2, Vector3 } from \"core/Maths/math.vector\";\nimport { Logger } from \"core/Misc/logger\";\nimport { GaussianSplattingMaterial } from \"core/Materials/GaussianSplatting/gaussianSplattingMaterial\";\nimport { RawTexture } from \"core/Materials/Textures/rawTexture\";\nimport { Constants } from \"core/Engines/constants\";\nimport { Tools } from \"core/Misc/tools\";\nimport \"core/Meshes/thinInstanceMesh\";\nimport { ToHalfFloat } from \"core/Misc/textureTools\";\nimport { Scalar } from \"core/Maths/math.scalar\";\nimport { runCoroutineSync, runCoroutineAsync, createYieldingScheduler } from \"core/Misc/coroutine\";\nimport { EngineStore } from \"core/Engines/engineStore\";\n// @internal\nconst UnpackUnorm = (value, bits) => {\n    const t = (1 << bits) - 1;\n    return (value & t) / t;\n};\n// @internal\nconst Unpack111011 = (value, result) => {\n    result.x = UnpackUnorm(value >>> 21, 11);\n    result.y = UnpackUnorm(value >>> 11, 10);\n    result.z = UnpackUnorm(value, 11);\n};\n// @internal\nconst Unpack8888 = (value, result) => {\n    result[0] = UnpackUnorm(value >>> 24, 8) * 255;\n    result[1] = UnpackUnorm(value >>> 16, 8) * 255;\n    result[2] = UnpackUnorm(value >>> 8, 8) * 255;\n    result[3] = UnpackUnorm(value, 8) * 255;\n};\n// @internal\n// unpack quaternion with 2,10,10,10 format (largest element, 3x10bit element)\nconst UnpackRot = (value, result) => {\n    const norm = 1.0 / (Math.sqrt(2) * 0.5);\n    const a = (UnpackUnorm(value >>> 20, 10) - 0.5) * norm;\n    const b = (UnpackUnorm(value >>> 10, 10) - 0.5) * norm;\n    const c = (UnpackUnorm(value, 10) - 0.5) * norm;\n    const m = Math.sqrt(1.0 - (a * a + b * b + c * c));\n    switch (value >>> 30) {\n        case 0:\n            result.set(m, a, b, c);\n            break;\n        case 1:\n            result.set(a, m, b, c);\n            break;\n        case 2:\n            result.set(a, b, m, c);\n            break;\n        case 3:\n            result.set(a, b, c, m);\n            break;\n    }\n};\n/**\n * Representation of the types\n */\nvar PLYType;\n(function (PLYType) {\n    PLYType[PLYType[\"FLOAT\"] = 0] = \"FLOAT\";\n    PLYType[PLYType[\"INT\"] = 1] = \"INT\";\n    PLYType[PLYType[\"UINT\"] = 2] = \"UINT\";\n    PLYType[PLYType[\"DOUBLE\"] = 3] = \"DOUBLE\";\n    PLYType[PLYType[\"UCHAR\"] = 4] = \"UCHAR\";\n    PLYType[PLYType[\"UNDEFINED\"] = 5] = \"UNDEFINED\";\n})(PLYType || (PLYType = {}));\n/**\n * Usage types of the PLY values\n */\nvar PLYValue;\n(function (PLYValue) {\n    PLYValue[PLYValue[\"MIN_X\"] = 0] = \"MIN_X\";\n    PLYValue[PLYValue[\"MIN_Y\"] = 1] = \"MIN_Y\";\n    PLYValue[PLYValue[\"MIN_Z\"] = 2] = \"MIN_Z\";\n    PLYValue[PLYValue[\"MAX_X\"] = 3] = \"MAX_X\";\n    PLYValue[PLYValue[\"MAX_Y\"] = 4] = \"MAX_Y\";\n    PLYValue[PLYValue[\"MAX_Z\"] = 5] = \"MAX_Z\";\n    PLYValue[PLYValue[\"MIN_SCALE_X\"] = 6] = \"MIN_SCALE_X\";\n    PLYValue[PLYValue[\"MIN_SCALE_Y\"] = 7] = \"MIN_SCALE_Y\";\n    PLYValue[PLYValue[\"MIN_SCALE_Z\"] = 8] = \"MIN_SCALE_Z\";\n    PLYValue[PLYValue[\"MAX_SCALE_X\"] = 9] = \"MAX_SCALE_X\";\n    PLYValue[PLYValue[\"MAX_SCALE_Y\"] = 10] = \"MAX_SCALE_Y\";\n    PLYValue[PLYValue[\"MAX_SCALE_Z\"] = 11] = \"MAX_SCALE_Z\";\n    PLYValue[PLYValue[\"PACKED_POSITION\"] = 12] = \"PACKED_POSITION\";\n    PLYValue[PLYValue[\"PACKED_ROTATION\"] = 13] = \"PACKED_ROTATION\";\n    PLYValue[PLYValue[\"PACKED_SCALE\"] = 14] = \"PACKED_SCALE\";\n    PLYValue[PLYValue[\"PACKED_COLOR\"] = 15] = \"PACKED_COLOR\";\n    PLYValue[PLYValue[\"X\"] = 16] = \"X\";\n    PLYValue[PLYValue[\"Y\"] = 17] = \"Y\";\n    PLYValue[PLYValue[\"Z\"] = 18] = \"Z\";\n    PLYValue[PLYValue[\"SCALE_0\"] = 19] = \"SCALE_0\";\n    PLYValue[PLYValue[\"SCALE_1\"] = 20] = \"SCALE_1\";\n    PLYValue[PLYValue[\"SCALE_2\"] = 21] = \"SCALE_2\";\n    PLYValue[PLYValue[\"DIFFUSE_RED\"] = 22] = \"DIFFUSE_RED\";\n    PLYValue[PLYValue[\"DIFFUSE_GREEN\"] = 23] = \"DIFFUSE_GREEN\";\n    PLYValue[PLYValue[\"DIFFUSE_BLUE\"] = 24] = \"DIFFUSE_BLUE\";\n    PLYValue[PLYValue[\"OPACITY\"] = 25] = \"OPACITY\";\n    PLYValue[PLYValue[\"F_DC_0\"] = 26] = \"F_DC_0\";\n    PLYValue[PLYValue[\"F_DC_1\"] = 27] = \"F_DC_1\";\n    PLYValue[PLYValue[\"F_DC_2\"] = 28] = \"F_DC_2\";\n    PLYValue[PLYValue[\"F_DC_3\"] = 29] = \"F_DC_3\";\n    PLYValue[PLYValue[\"ROT_0\"] = 30] = \"ROT_0\";\n    PLYValue[PLYValue[\"ROT_1\"] = 31] = \"ROT_1\";\n    PLYValue[PLYValue[\"ROT_2\"] = 32] = \"ROT_2\";\n    PLYValue[PLYValue[\"ROT_3\"] = 33] = \"ROT_3\";\n    PLYValue[PLYValue[\"MIN_COLOR_R\"] = 34] = \"MIN_COLOR_R\";\n    PLYValue[PLYValue[\"MIN_COLOR_G\"] = 35] = \"MIN_COLOR_G\";\n    PLYValue[PLYValue[\"MIN_COLOR_B\"] = 36] = \"MIN_COLOR_B\";\n    PLYValue[PLYValue[\"MAX_COLOR_R\"] = 37] = \"MAX_COLOR_R\";\n    PLYValue[PLYValue[\"MAX_COLOR_G\"] = 38] = \"MAX_COLOR_G\";\n    PLYValue[PLYValue[\"MAX_COLOR_B\"] = 39] = \"MAX_COLOR_B\";\n    PLYValue[PLYValue[\"SH_0\"] = 40] = \"SH_0\";\n    PLYValue[PLYValue[\"SH_1\"] = 41] = \"SH_1\";\n    PLYValue[PLYValue[\"SH_2\"] = 42] = \"SH_2\";\n    PLYValue[PLYValue[\"SH_3\"] = 43] = \"SH_3\";\n    PLYValue[PLYValue[\"SH_4\"] = 44] = \"SH_4\";\n    PLYValue[PLYValue[\"SH_5\"] = 45] = \"SH_5\";\n    PLYValue[PLYValue[\"SH_6\"] = 46] = \"SH_6\";\n    PLYValue[PLYValue[\"SH_7\"] = 47] = \"SH_7\";\n    PLYValue[PLYValue[\"SH_8\"] = 48] = \"SH_8\";\n    PLYValue[PLYValue[\"SH_9\"] = 49] = \"SH_9\";\n    PLYValue[PLYValue[\"SH_10\"] = 50] = \"SH_10\";\n    PLYValue[PLYValue[\"SH_11\"] = 51] = \"SH_11\";\n    PLYValue[PLYValue[\"SH_12\"] = 52] = \"SH_12\";\n    PLYValue[PLYValue[\"SH_13\"] = 53] = \"SH_13\";\n    PLYValue[PLYValue[\"SH_14\"] = 54] = \"SH_14\";\n    PLYValue[PLYValue[\"SH_15\"] = 55] = \"SH_15\";\n    PLYValue[PLYValue[\"SH_16\"] = 56] = \"SH_16\";\n    PLYValue[PLYValue[\"SH_17\"] = 57] = \"SH_17\";\n    PLYValue[PLYValue[\"SH_18\"] = 58] = \"SH_18\";\n    PLYValue[PLYValue[\"SH_19\"] = 59] = \"SH_19\";\n    PLYValue[PLYValue[\"SH_20\"] = 60] = \"SH_20\";\n    PLYValue[PLYValue[\"SH_21\"] = 61] = \"SH_21\";\n    PLYValue[PLYValue[\"SH_22\"] = 62] = \"SH_22\";\n    PLYValue[PLYValue[\"SH_23\"] = 63] = \"SH_23\";\n    PLYValue[PLYValue[\"SH_24\"] = 64] = \"SH_24\";\n    PLYValue[PLYValue[\"SH_25\"] = 65] = \"SH_25\";\n    PLYValue[PLYValue[\"SH_26\"] = 66] = \"SH_26\";\n    PLYValue[PLYValue[\"SH_27\"] = 67] = \"SH_27\";\n    PLYValue[PLYValue[\"SH_28\"] = 68] = \"SH_28\";\n    PLYValue[PLYValue[\"SH_29\"] = 69] = \"SH_29\";\n    PLYValue[PLYValue[\"SH_30\"] = 70] = \"SH_30\";\n    PLYValue[PLYValue[\"SH_31\"] = 71] = \"SH_31\";\n    PLYValue[PLYValue[\"SH_32\"] = 72] = \"SH_32\";\n    PLYValue[PLYValue[\"SH_33\"] = 73] = \"SH_33\";\n    PLYValue[PLYValue[\"SH_34\"] = 74] = \"SH_34\";\n    PLYValue[PLYValue[\"SH_35\"] = 75] = \"SH_35\";\n    PLYValue[PLYValue[\"SH_36\"] = 76] = \"SH_36\";\n    PLYValue[PLYValue[\"SH_37\"] = 77] = \"SH_37\";\n    PLYValue[PLYValue[\"SH_38\"] = 78] = \"SH_38\";\n    PLYValue[PLYValue[\"SH_39\"] = 79] = \"SH_39\";\n    PLYValue[PLYValue[\"SH_40\"] = 80] = \"SH_40\";\n    PLYValue[PLYValue[\"SH_41\"] = 81] = \"SH_41\";\n    PLYValue[PLYValue[\"SH_42\"] = 82] = \"SH_42\";\n    PLYValue[PLYValue[\"SH_43\"] = 83] = \"SH_43\";\n    PLYValue[PLYValue[\"SH_44\"] = 84] = \"SH_44\";\n    PLYValue[PLYValue[\"UNDEFINED\"] = 85] = \"UNDEFINED\";\n})(PLYValue || (PLYValue = {}));\n/**\n * Class used to render a gaussian splatting mesh\n */\nexport class GaussianSplattingMesh extends Mesh {\n    /**\n     * View direction factor used to compute the SH view direction in the shader.\n     */\n    get viewDirectionFactor() {\n        return this._viewDirectionFactor;\n    }\n    /**\n     * SH degree. 0 = no sh (default). 1 = 3 parameters. 2 = 8 parameters. 3 = 15 parameters.\n     */\n    get shDegree() {\n        return this._shDegree;\n    }\n    /**\n     * Number of splats in the mesh\n     */\n    get splatCount() {\n        return this._splatIndex?.length;\n    }\n    /**\n     * returns the splats data array buffer that contains in order : postions (3 floats), size (3 floats), color (4 bytes), orientation quaternion (4 bytes)\n     */\n    get splatsData() {\n        return this._splatsData;\n    }\n    /**\n     * Gets the covariancesA texture\n     */\n    get covariancesATexture() {\n        return this._covariancesATexture;\n    }\n    /**\n     * Gets the covariancesB texture\n     */\n    get covariancesBTexture() {\n        return this._covariancesBTexture;\n    }\n    /**\n     * Gets the centers texture\n     */\n    get centersTexture() {\n        return this._centersTexture;\n    }\n    /**\n     * Gets the colors texture\n     */\n    get colorsTexture() {\n        return this._colorsTexture;\n    }\n    /**\n     * Gets the SH textures\n     */\n    get shTextures() {\n        return this._shTextures;\n    }\n    /**\n     * Gets the kernel size\n     * Documentation and mathematical explanations here:\n     * https://github.com/graphdeco-inria/gaussian-splatting/issues/294#issuecomment-1772688093\n     * https://github.com/autonomousvision/mip-splatting/issues/18#issuecomment-1929388931\n     */\n    get kernelSize() {\n        return this._material instanceof GaussianSplattingMaterial ? this._material.kernelSize : 0;\n    }\n    /**\n     * Get the compensation state\n     */\n    get compensation() {\n        return this._material instanceof GaussianSplattingMaterial ? this._material.compensation : false;\n    }\n    /**\n     * set rendering material\n     */\n    set material(value) {\n        this._material = value;\n        this._material.backFaceCulling = true;\n        this._material.cullBackFaces = false;\n        value.resetDrawCache();\n    }\n    /**\n     * get rendering material\n     */\n    get material() {\n        return this._material;\n    }\n    /**\n     * Creates a new gaussian splatting mesh\n     * @param name defines the name of the mesh\n     * @param url defines the url to load from (optional)\n     * @param scene defines the hosting scene (optional)\n     * @param keepInRam keep datas in ram for editing purpose\n     */\n    constructor(name, url = null, scene = null, keepInRam = false) {\n        super(name, scene);\n        this._vertexCount = 0;\n        this._worker = null;\n        this._frameIdLastUpdate = -1;\n        this._modelViewMatrix = Matrix.Identity();\n        this._canPostToWorker = true;\n        this._readyToDisplay = false;\n        this._covariancesATexture = null;\n        this._covariancesBTexture = null;\n        this._centersTexture = null;\n        this._colorsTexture = null;\n        this._splatPositions = null;\n        this._splatIndex = null;\n        this._shTextures = null;\n        this._splatsData = null;\n        this._sh = null;\n        this._keepInRam = false;\n        this._delayedTextureUpdate = null;\n        this._oldDirection = new Vector3();\n        this._useRGBACovariants = false;\n        this._material = null;\n        this._tmpCovariances = [0, 0, 0, 0, 0, 0];\n        this._sortIsDirty = false;\n        this._shDegree = 0;\n        this._viewDirectionFactor = new Vector3(1, 1, -1);\n        const vertexData = new VertexData();\n        vertexData.positions = [-2, -2, 0, 2, -2, 0, 2, 2, 0, -2, 2, 0];\n        vertexData.indices = [0, 1, 2, 0, 2, 3];\n        vertexData.applyToMesh(this);\n        this.subMeshes = [];\n        new SubMesh(0, 0, 4, 0, 6, this);\n        this.setEnabled(false);\n        // webGL2 and webGPU support for RG texture with float16 is fine. not webGL1\n        this._useRGBACovariants = !this.getEngine().isWebGPU && this.getEngine().version === 1.0;\n        this._keepInRam = keepInRam;\n        if (url) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.loadFileAsync(url);\n        }\n        this._material = new GaussianSplattingMaterial(this.name + \"_material\", this._scene);\n    }\n    /**\n     * Returns the class name\n     * @returns \"GaussianSplattingMesh\"\n     */\n    getClassName() {\n        return \"GaussianSplattingMesh\";\n    }\n    /**\n     * Returns the total number of vertices (splats) within the mesh\n     * @returns the total number of vertices\n     */\n    getTotalVertices() {\n        return this._vertexCount;\n    }\n    /**\n     * Is this node ready to be used/rendered\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\n     * @returns true when ready\n     */\n    isReady(completeCheck = false) {\n        if (!super.isReady(completeCheck, true)) {\n            return false;\n        }\n        if (!this._readyToDisplay) {\n            // mesh is ready when worker has done at least 1 sorting\n            this._postToWorker(true);\n            return false;\n        }\n        return true;\n    }\n    /** @internal */\n    _postToWorker(forced = false) {\n        const frameId = this.getScene().getFrameId();\n        if ((forced || frameId !== this._frameIdLastUpdate) && this._worker && this._scene.activeCamera && this._canPostToWorker) {\n            const cameraMatrix = this._scene.activeCamera.getViewMatrix();\n            this.getWorldMatrix().multiplyToRef(cameraMatrix, this._modelViewMatrix);\n            cameraMatrix.invertToRef(TmpVectors.Matrix[0]);\n            this.getWorldMatrix().multiplyToRef(TmpVectors.Matrix[0], TmpVectors.Matrix[1]);\n            Vector3.TransformNormalToRef(Vector3.Forward(this._scene.useRightHandedSystem), TmpVectors.Matrix[1], TmpVectors.Vector3[2]);\n            TmpVectors.Vector3[2].normalize();\n            const dot = Vector3.Dot(TmpVectors.Vector3[2], this._oldDirection);\n            if (forced || Math.abs(dot - 1) >= 0.01) {\n                this._oldDirection.copyFrom(TmpVectors.Vector3[2]);\n                this._frameIdLastUpdate = frameId;\n                this._canPostToWorker = false;\n                this._worker.postMessage({ view: this._modelViewMatrix.m, depthMix: this._depthMix, useRightHandedSystem: this._scene.useRightHandedSystem }, [\n                    this._depthMix.buffer,\n                ]);\n            }\n        }\n    }\n    /**\n     * Triggers the draw call for the mesh. Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager\n     * @param subMesh defines the subMesh to render\n     * @param enableAlphaMode defines if alpha mode can be changed\n     * @param effectiveMeshReplacement defines an optional mesh used to provide info for the rendering\n     * @returns the current mesh\n     */\n    render(subMesh, enableAlphaMode, effectiveMeshReplacement) {\n        this._postToWorker();\n        return super.render(subMesh, enableAlphaMode, effectiveMeshReplacement);\n    }\n    static _TypeNameToEnum(name) {\n        switch (name) {\n            case \"float\":\n                return 0 /* PLYType.FLOAT */;\n            case \"int\":\n                return 1 /* PLYType.INT */;\n                break;\n            case \"uint\":\n                return 2 /* PLYType.UINT */;\n            case \"double\":\n                return 3 /* PLYType.DOUBLE */;\n            case \"uchar\":\n                return 4 /* PLYType.UCHAR */;\n        }\n        return 5 /* PLYType.UNDEFINED */;\n    }\n    static _ValueNameToEnum(name) {\n        switch (name) {\n            case \"min_x\":\n                return 0 /* PLYValue.MIN_X */;\n            case \"min_y\":\n                return 1 /* PLYValue.MIN_Y */;\n            case \"min_z\":\n                return 2 /* PLYValue.MIN_Z */;\n            case \"max_x\":\n                return 3 /* PLYValue.MAX_X */;\n            case \"max_y\":\n                return 4 /* PLYValue.MAX_Y */;\n            case \"max_z\":\n                return 5 /* PLYValue.MAX_Z */;\n            case \"min_scale_x\":\n                return 6 /* PLYValue.MIN_SCALE_X */;\n            case \"min_scale_y\":\n                return 7 /* PLYValue.MIN_SCALE_Y */;\n            case \"min_scale_z\":\n                return 8 /* PLYValue.MIN_SCALE_Z */;\n            case \"max_scale_x\":\n                return 9 /* PLYValue.MAX_SCALE_X */;\n            case \"max_scale_y\":\n                return 10 /* PLYValue.MAX_SCALE_Y */;\n            case \"max_scale_z\":\n                return 11 /* PLYValue.MAX_SCALE_Z */;\n            case \"packed_position\":\n                return 12 /* PLYValue.PACKED_POSITION */;\n            case \"packed_rotation\":\n                return 13 /* PLYValue.PACKED_ROTATION */;\n            case \"packed_scale\":\n                return 14 /* PLYValue.PACKED_SCALE */;\n            case \"packed_color\":\n                return 15 /* PLYValue.PACKED_COLOR */;\n            case \"x\":\n                return 16 /* PLYValue.X */;\n            case \"y\":\n                return 17 /* PLYValue.Y */;\n            case \"z\":\n                return 18 /* PLYValue.Z */;\n            case \"scale_0\":\n                return 19 /* PLYValue.SCALE_0 */;\n            case \"scale_1\":\n                return 20 /* PLYValue.SCALE_1 */;\n            case \"scale_2\":\n                return 21 /* PLYValue.SCALE_2 */;\n            case \"diffuse_red\":\n            case \"red\":\n                return 22 /* PLYValue.DIFFUSE_RED */;\n            case \"diffuse_green\":\n            case \"green\":\n                return 23 /* PLYValue.DIFFUSE_GREEN */;\n            case \"diffuse_blue\":\n            case \"blue\":\n                return 24 /* PLYValue.DIFFUSE_BLUE */;\n            case \"f_dc_0\":\n                return 26 /* PLYValue.F_DC_0 */;\n            case \"f_dc_1\":\n                return 27 /* PLYValue.F_DC_1 */;\n            case \"f_dc_2\":\n                return 28 /* PLYValue.F_DC_2 */;\n            case \"f_dc_3\":\n                return 29 /* PLYValue.F_DC_3 */;\n            case \"opacity\":\n                return 25 /* PLYValue.OPACITY */;\n            case \"rot_0\":\n                return 30 /* PLYValue.ROT_0 */;\n            case \"rot_1\":\n                return 31 /* PLYValue.ROT_1 */;\n            case \"rot_2\":\n                return 32 /* PLYValue.ROT_2 */;\n            case \"rot_3\":\n                return 33 /* PLYValue.ROT_3 */;\n            case \"min_r\":\n                return 34 /* PLYValue.MIN_COLOR_R */;\n            case \"min_g\":\n                return 35 /* PLYValue.MIN_COLOR_G */;\n            case \"min_b\":\n                return 36 /* PLYValue.MIN_COLOR_B */;\n            case \"max_r\":\n                return 37 /* PLYValue.MAX_COLOR_R */;\n            case \"max_g\":\n                return 38 /* PLYValue.MAX_COLOR_G */;\n            case \"max_b\":\n                return 39 /* PLYValue.MAX_COLOR_B */;\n            case \"f_rest_0\":\n                return 40 /* PLYValue.SH_0 */;\n            case \"f_rest_1\":\n                return 41 /* PLYValue.SH_1 */;\n            case \"f_rest_2\":\n                return 42 /* PLYValue.SH_2 */;\n            case \"f_rest_3\":\n                return 43 /* PLYValue.SH_3 */;\n            case \"f_rest_4\":\n                return 44 /* PLYValue.SH_4 */;\n            case \"f_rest_5\":\n                return 45 /* PLYValue.SH_5 */;\n            case \"f_rest_6\":\n                return 46 /* PLYValue.SH_6 */;\n            case \"f_rest_7\":\n                return 47 /* PLYValue.SH_7 */;\n            case \"f_rest_8\":\n                return 48 /* PLYValue.SH_8 */;\n            case \"f_rest_9\":\n                return 49 /* PLYValue.SH_9 */;\n            case \"f_rest_10\":\n                return 50 /* PLYValue.SH_10 */;\n            case \"f_rest_11\":\n                return 51 /* PLYValue.SH_11 */;\n            case \"f_rest_12\":\n                return 52 /* PLYValue.SH_12 */;\n            case \"f_rest_13\":\n                return 53 /* PLYValue.SH_13 */;\n            case \"f_rest_14\":\n                return 54 /* PLYValue.SH_14 */;\n            case \"f_rest_15\":\n                return 55 /* PLYValue.SH_15 */;\n            case \"f_rest_16\":\n                return 56 /* PLYValue.SH_16 */;\n            case \"f_rest_17\":\n                return 57 /* PLYValue.SH_17 */;\n            case \"f_rest_18\":\n                return 58 /* PLYValue.SH_18 */;\n            case \"f_rest_19\":\n                return 59 /* PLYValue.SH_19 */;\n            case \"f_rest_20\":\n                return 60 /* PLYValue.SH_20 */;\n            case \"f_rest_21\":\n                return 61 /* PLYValue.SH_21 */;\n            case \"f_rest_22\":\n                return 62 /* PLYValue.SH_22 */;\n            case \"f_rest_23\":\n                return 63 /* PLYValue.SH_23 */;\n            case \"f_rest_24\":\n                return 64 /* PLYValue.SH_24 */;\n            case \"f_rest_25\":\n                return 65 /* PLYValue.SH_25 */;\n            case \"f_rest_26\":\n                return 66 /* PLYValue.SH_26 */;\n            case \"f_rest_27\":\n                return 67 /* PLYValue.SH_27 */;\n            case \"f_rest_28\":\n                return 68 /* PLYValue.SH_28 */;\n            case \"f_rest_29\":\n                return 69 /* PLYValue.SH_29 */;\n            case \"f_rest_30\":\n                return 70 /* PLYValue.SH_30 */;\n            case \"f_rest_31\":\n                return 71 /* PLYValue.SH_31 */;\n            case \"f_rest_32\":\n                return 72 /* PLYValue.SH_32 */;\n            case \"f_rest_33\":\n                return 73 /* PLYValue.SH_33 */;\n            case \"f_rest_34\":\n                return 74 /* PLYValue.SH_34 */;\n            case \"f_rest_35\":\n                return 75 /* PLYValue.SH_35 */;\n            case \"f_rest_36\":\n                return 76 /* PLYValue.SH_36 */;\n            case \"f_rest_37\":\n                return 77 /* PLYValue.SH_37 */;\n            case \"f_rest_38\":\n                return 78 /* PLYValue.SH_38 */;\n            case \"f_rest_39\":\n                return 79 /* PLYValue.SH_39 */;\n            case \"f_rest_40\":\n                return 80 /* PLYValue.SH_40 */;\n            case \"f_rest_41\":\n                return 81 /* PLYValue.SH_41 */;\n            case \"f_rest_42\":\n                return 82 /* PLYValue.SH_42 */;\n            case \"f_rest_43\":\n                return 83 /* PLYValue.SH_43 */;\n            case \"f_rest_44\":\n                return 84 /* PLYValue.SH_44 */;\n        }\n        return 85 /* PLYValue.UNDEFINED */;\n    }\n    /**\n     * Parse a PLY file header and returns metas infos on splats and chunks\n     * @param data the loaded buffer\n     * @returns a PLYHeader\n     */\n    static ParseHeader(data) {\n        const ubuf = new Uint8Array(data);\n        const header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));\n        const headerEnd = \"end_header\\n\";\n        const headerEndIndex = header.indexOf(headerEnd);\n        if (headerEndIndex < 0 || !header) {\n            // standard splat\n            return null;\n        }\n        const vertexCount = parseInt(/element vertex (\\d+)\\n/.exec(header)[1]);\n        const chunkElement = /element chunk (\\d+)\\n/.exec(header);\n        let chunkCount = 0;\n        if (chunkElement) {\n            chunkCount = parseInt(chunkElement[1]);\n        }\n        let rowVertexOffset = 0;\n        let rowChunkOffset = 0;\n        const offsets = {\n            double: 8,\n            int: 4,\n            uint: 4,\n            float: 4,\n            short: 2,\n            ushort: 2,\n            uchar: 1,\n            list: 0,\n        };\n        let ElementMode;\n        (function (ElementMode) {\n            ElementMode[ElementMode[\"Vertex\"] = 0] = \"Vertex\";\n            ElementMode[ElementMode[\"Chunk\"] = 1] = \"Chunk\";\n            ElementMode[ElementMode[\"SH\"] = 2] = \"SH\";\n        })(ElementMode || (ElementMode = {}));\n        let chunkMode = 1 /* ElementMode.Chunk */;\n        const vertexProperties = [];\n        const chunkProperties = [];\n        const filtered = header.slice(0, headerEndIndex).split(\"\\n\");\n        let shDegree = 0;\n        for (const prop of filtered) {\n            if (prop.startsWith(\"property \")) {\n                const [, typeName, name] = prop.split(\" \");\n                const value = GaussianSplattingMesh._ValueNameToEnum(name);\n                // SH degree 1,2 or 3 for 9, 24 or 45 values\n                if (value >= 84 /* PLYValue.SH_44 */) {\n                    shDegree = 3;\n                }\n                else if (value >= 64 /* PLYValue.SH_24 */) {\n                    shDegree = 2;\n                }\n                else if (value >= 48 /* PLYValue.SH_8 */) {\n                    shDegree = 1;\n                }\n                const type = GaussianSplattingMesh._TypeNameToEnum(typeName);\n                if (chunkMode == 1 /* ElementMode.Chunk */) {\n                    chunkProperties.push({ value, type, offset: rowChunkOffset });\n                    rowChunkOffset += offsets[typeName];\n                }\n                else if (chunkMode == 0 /* ElementMode.Vertex */) {\n                    vertexProperties.push({ value, type, offset: rowVertexOffset });\n                    rowVertexOffset += offsets[typeName];\n                }\n                else if (chunkMode == 2 /* ElementMode.SH */) {\n                    // SH doesn't count for vertex row size but its properties are used to retrieve SH\n                    vertexProperties.push({ value, type, offset: rowVertexOffset });\n                }\n                if (!offsets[typeName]) {\n                    Logger.Warn(`Unsupported property type: ${typeName}.`);\n                }\n            }\n            else if (prop.startsWith(\"element \")) {\n                const [, type] = prop.split(\" \");\n                if (type == \"chunk\") {\n                    chunkMode = 1 /* ElementMode.Chunk */;\n                }\n                else if (type == \"vertex\") {\n                    chunkMode = 0 /* ElementMode.Vertex */;\n                }\n                else if (type == \"sh\") {\n                    chunkMode = 2 /* ElementMode.SH */;\n                }\n            }\n        }\n        const dataView = new DataView(data, headerEndIndex + headerEnd.length);\n        const buffer = new ArrayBuffer(GaussianSplattingMesh._RowOutputLength * vertexCount);\n        let shBuffer = null;\n        let shCoefficientCount = 0;\n        if (shDegree) {\n            const shVectorCount = (shDegree + 1) * (shDegree + 1) - 1;\n            shCoefficientCount = shVectorCount * 3;\n            shBuffer = new ArrayBuffer(shCoefficientCount * vertexCount);\n        }\n        return {\n            vertexCount: vertexCount,\n            chunkCount: chunkCount,\n            rowVertexLength: rowVertexOffset,\n            rowChunkLength: rowChunkOffset,\n            vertexProperties: vertexProperties,\n            chunkProperties: chunkProperties,\n            dataView: dataView,\n            buffer: buffer,\n            shDegree: shDegree,\n            shCoefficientCount: shCoefficientCount,\n            shBuffer: shBuffer,\n        };\n    }\n    static _GetCompressedChunks(header, offset) {\n        if (!header.chunkCount) {\n            return null;\n        }\n        const dataView = header.dataView;\n        const compressedChunks = new Array(header.chunkCount);\n        for (let i = 0; i < header.chunkCount; i++) {\n            const currentChunk = {\n                min: new Vector3(),\n                max: new Vector3(),\n                minScale: new Vector3(),\n                maxScale: new Vector3(),\n                minColor: new Vector3(0, 0, 0),\n                maxColor: new Vector3(1, 1, 1),\n            };\n            compressedChunks[i] = currentChunk;\n            for (let propertyIndex = 0; propertyIndex < header.chunkProperties.length; propertyIndex++) {\n                const property = header.chunkProperties[propertyIndex];\n                let value;\n                switch (property.type) {\n                    case 0 /* PLYType.FLOAT */:\n                        value = dataView.getFloat32(property.offset + offset.value, true);\n                        break;\n                    default:\n                        continue;\n                }\n                switch (property.value) {\n                    case 0 /* PLYValue.MIN_X */:\n                        currentChunk.min.x = value;\n                        break;\n                    case 1 /* PLYValue.MIN_Y */:\n                        currentChunk.min.y = value;\n                        break;\n                    case 2 /* PLYValue.MIN_Z */:\n                        currentChunk.min.z = value;\n                        break;\n                    case 3 /* PLYValue.MAX_X */:\n                        currentChunk.max.x = value;\n                        break;\n                    case 4 /* PLYValue.MAX_Y */:\n                        currentChunk.max.y = value;\n                        break;\n                    case 5 /* PLYValue.MAX_Z */:\n                        currentChunk.max.z = value;\n                        break;\n                    case 6 /* PLYValue.MIN_SCALE_X */:\n                        currentChunk.minScale.x = value;\n                        break;\n                    case 7 /* PLYValue.MIN_SCALE_Y */:\n                        currentChunk.minScale.y = value;\n                        break;\n                    case 8 /* PLYValue.MIN_SCALE_Z */:\n                        currentChunk.minScale.z = value;\n                        break;\n                    case 9 /* PLYValue.MAX_SCALE_X */:\n                        currentChunk.maxScale.x = value;\n                        break;\n                    case 10 /* PLYValue.MAX_SCALE_Y */:\n                        currentChunk.maxScale.y = value;\n                        break;\n                    case 11 /* PLYValue.MAX_SCALE_Z */:\n                        currentChunk.maxScale.z = value;\n                        break;\n                    case 34 /* PLYValue.MIN_COLOR_R */:\n                        currentChunk.minColor.x = value;\n                        break;\n                    case 35 /* PLYValue.MIN_COLOR_G */:\n                        currentChunk.minColor.y = value;\n                        break;\n                    case 36 /* PLYValue.MIN_COLOR_B */:\n                        currentChunk.minColor.z = value;\n                        break;\n                    case 37 /* PLYValue.MAX_COLOR_R */:\n                        currentChunk.maxColor.x = value;\n                        break;\n                    case 38 /* PLYValue.MAX_COLOR_G */:\n                        currentChunk.maxColor.y = value;\n                        break;\n                    case 39 /* PLYValue.MAX_COLOR_B */:\n                        currentChunk.maxColor.z = value;\n                        break;\n                }\n            }\n            offset.value += header.rowChunkLength;\n        }\n        return compressedChunks;\n    }\n    static _GetSplat(header, index, compressedChunks, offset) {\n        const q = TmpVectors.Quaternion[0];\n        const temp3 = TmpVectors.Vector3[0];\n        const rowOutputLength = GaussianSplattingMesh._RowOutputLength;\n        const buffer = header.buffer;\n        const dataView = header.dataView;\n        const position = new Float32Array(buffer, index * rowOutputLength, 3);\n        const scale = new Float32Array(buffer, index * rowOutputLength + 12, 3);\n        const rgba = new Uint8ClampedArray(buffer, index * rowOutputLength + 24, 4);\n        const rot = new Uint8ClampedArray(buffer, index * rowOutputLength + 28, 4);\n        let sh = null;\n        if (header.shBuffer) {\n            sh = new Uint8ClampedArray(header.shBuffer, index * header.shCoefficientCount, header.shCoefficientCount);\n        }\n        const chunkIndex = index >> 8;\n        let r0 = 255;\n        let r1 = 0;\n        let r2 = 0;\n        let r3 = 0;\n        const plySH = [];\n        for (let propertyIndex = 0; propertyIndex < header.vertexProperties.length; propertyIndex++) {\n            const property = header.vertexProperties[propertyIndex];\n            let value;\n            switch (property.type) {\n                case 0 /* PLYType.FLOAT */:\n                    value = dataView.getFloat32(offset.value + property.offset, true);\n                    break;\n                case 1 /* PLYType.INT */:\n                    value = dataView.getInt32(offset.value + property.offset, true);\n                    break;\n                case 2 /* PLYType.UINT */:\n                    value = dataView.getUint32(offset.value + property.offset, true);\n                    break;\n                case 3 /* PLYType.DOUBLE */:\n                    value = dataView.getFloat64(offset.value + property.offset, true);\n                    break;\n                case 4 /* PLYType.UCHAR */:\n                    value = dataView.getUint8(offset.value + property.offset);\n                    break;\n                default:\n                    continue;\n            }\n            switch (property.value) {\n                case 12 /* PLYValue.PACKED_POSITION */:\n                    {\n                        const compressedChunk = compressedChunks[chunkIndex];\n                        Unpack111011(value, temp3);\n                        position[0] = Scalar.Lerp(compressedChunk.min.x, compressedChunk.max.x, temp3.x);\n                        position[1] = Scalar.Lerp(compressedChunk.min.y, compressedChunk.max.y, temp3.y);\n                        position[2] = Scalar.Lerp(compressedChunk.min.z, compressedChunk.max.z, temp3.z);\n                    }\n                    break;\n                case 13 /* PLYValue.PACKED_ROTATION */:\n                    {\n                        UnpackRot(value, q);\n                        r0 = q.x;\n                        r1 = q.y;\n                        r2 = q.z;\n                        r3 = q.w;\n                    }\n                    break;\n                case 14 /* PLYValue.PACKED_SCALE */:\n                    {\n                        const compressedChunk = compressedChunks[chunkIndex];\n                        Unpack111011(value, temp3);\n                        scale[0] = Math.exp(Scalar.Lerp(compressedChunk.minScale.x, compressedChunk.maxScale.x, temp3.x));\n                        scale[1] = Math.exp(Scalar.Lerp(compressedChunk.minScale.y, compressedChunk.maxScale.y, temp3.y));\n                        scale[2] = Math.exp(Scalar.Lerp(compressedChunk.minScale.z, compressedChunk.maxScale.z, temp3.z));\n                    }\n                    break;\n                case 15 /* PLYValue.PACKED_COLOR */:\n                    {\n                        const compressedChunk = compressedChunks[chunkIndex];\n                        Unpack8888(value, rgba);\n                        rgba[0] = Scalar.Lerp(compressedChunk.minColor.x, compressedChunk.maxColor.x, rgba[0] / 255) * 255;\n                        rgba[1] = Scalar.Lerp(compressedChunk.minColor.y, compressedChunk.maxColor.y, rgba[1] / 255) * 255;\n                        rgba[2] = Scalar.Lerp(compressedChunk.minColor.z, compressedChunk.maxColor.z, rgba[2] / 255) * 255;\n                    }\n                    break;\n                case 16 /* PLYValue.X */:\n                    position[0] = value;\n                    break;\n                case 17 /* PLYValue.Y */:\n                    position[1] = value;\n                    break;\n                case 18 /* PLYValue.Z */:\n                    position[2] = value;\n                    break;\n                case 19 /* PLYValue.SCALE_0 */:\n                    scale[0] = Math.exp(value);\n                    break;\n                case 20 /* PLYValue.SCALE_1 */:\n                    scale[1] = Math.exp(value);\n                    break;\n                case 21 /* PLYValue.SCALE_2 */:\n                    scale[2] = Math.exp(value);\n                    break;\n                case 22 /* PLYValue.DIFFUSE_RED */:\n                    rgba[0] = value;\n                    break;\n                case 23 /* PLYValue.DIFFUSE_GREEN */:\n                    rgba[1] = value;\n                    break;\n                case 24 /* PLYValue.DIFFUSE_BLUE */:\n                    rgba[2] = value;\n                    break;\n                case 26 /* PLYValue.F_DC_0 */:\n                    rgba[0] = (0.5 + GaussianSplattingMesh._SH_C0 * value) * 255;\n                    break;\n                case 27 /* PLYValue.F_DC_1 */:\n                    rgba[1] = (0.5 + GaussianSplattingMesh._SH_C0 * value) * 255;\n                    break;\n                case 28 /* PLYValue.F_DC_2 */:\n                    rgba[2] = (0.5 + GaussianSplattingMesh._SH_C0 * value) * 255;\n                    break;\n                case 29 /* PLYValue.F_DC_3 */:\n                    rgba[3] = (0.5 + GaussianSplattingMesh._SH_C0 * value) * 255;\n                    break;\n                case 25 /* PLYValue.OPACITY */:\n                    rgba[3] = (1 / (1 + Math.exp(-value))) * 255;\n                    break;\n                case 30 /* PLYValue.ROT_0 */:\n                    r0 = value;\n                    break;\n                case 31 /* PLYValue.ROT_1 */:\n                    r1 = value;\n                    break;\n                case 32 /* PLYValue.ROT_2 */:\n                    r2 = value;\n                    break;\n                case 33 /* PLYValue.ROT_3 */:\n                    r3 = value;\n                    break;\n            }\n            if (sh && property.value >= 40 /* PLYValue.SH_0 */ && property.value <= 84 /* PLYValue.SH_44 */) {\n                const shIndex = property.value - 40 /* PLYValue.SH_0 */;\n                if (property.type == 4 /* PLYType.UCHAR */ && header.chunkCount) {\n                    // compressed ply. dataView points to beginning of vertex\n                    // could be improved with a direct copy instead of a per SH index computation + copy\n                    const compressedValue = dataView.getUint8(header.rowChunkLength * header.chunkCount + header.vertexCount * header.rowVertexLength + index * header.shCoefficientCount + shIndex);\n                    // compressed .ply SH import : https://github.com/playcanvas/engine/blob/fda3f0368b45d7381f0b5a1722bd2056128eaebe/src/scene/gsplat/gsplat-compressed-data.js#L88C81-L88C98\n                    plySH[shIndex] = (compressedValue * (8 / 255) - 4) * 127.5 + 127.5;\n                }\n                else {\n                    const clampedValue = Scalar.Clamp(value * 127.5 + 127.5, 0, 255);\n                    plySH[shIndex] = clampedValue;\n                }\n            }\n        }\n        if (sh) {\n            const shDim = header.shDegree == 1 ? 3 : header.shDegree == 2 ? 8 : 15;\n            for (let j = 0; j < shDim; j++) {\n                sh[j * 3 + 0] = plySH[j];\n                sh[j * 3 + 1] = plySH[j + shDim];\n                sh[j * 3 + 2] = plySH[j + shDim * 2];\n            }\n        }\n        q.set(r1, r2, r3, r0);\n        q.normalize();\n        rot[0] = q.w * 127.5 + 127.5;\n        rot[1] = q.x * 127.5 + 127.5;\n        rot[2] = q.y * 127.5 + 127.5;\n        rot[3] = q.z * 127.5 + 127.5;\n        offset.value += header.rowVertexLength;\n    }\n    /**\n     * Converts a .ply data with SH coefficients splat\n     * if data array buffer is not ply, returns the original buffer\n     * @param data the .ply data to load\n     * @param useCoroutine use coroutine and yield\n     * @returns the loaded splat buffer and optional array of sh coefficients\n     */\n    static *ConvertPLYWithSHToSplat(data, useCoroutine = false) {\n        const header = GaussianSplattingMesh.ParseHeader(data);\n        if (!header) {\n            return { buffer: data };\n        }\n        const offset = { value: 0 };\n        const compressedChunks = GaussianSplattingMesh._GetCompressedChunks(header, offset);\n        for (let i = 0; i < header.vertexCount; i++) {\n            GaussianSplattingMesh._GetSplat(header, i, compressedChunks, offset);\n            if (i % GaussianSplattingMesh._PlyConversionBatchSize === 0 && useCoroutine) {\n                yield;\n            }\n        }\n        let sh = null;\n        // make SH texture buffers\n        if (header.shDegree && header.shBuffer) {\n            const textureCount = Math.ceil(header.shCoefficientCount / 16); // 4 components can be stored per texture, 4 sh per component\n            let shIndexRead = 0;\n            const ubuf = new Uint8Array(header.shBuffer);\n            // sh is an array of uint8array that will be used to create sh textures\n            sh = [];\n            const splatCount = header.vertexCount;\n            const engine = EngineStore.LastCreatedEngine;\n            if (engine) {\n                const width = engine.getCaps().maxTextureSize;\n                const height = Math.ceil(splatCount / width);\n                // create array for the number of textures needed.\n                for (let textureIndex = 0; textureIndex < textureCount; textureIndex++) {\n                    const texture = new Uint8Array(height * width * 4 * 4); // 4 components per texture, 4 sh per component\n                    sh.push(texture);\n                }\n                for (let i = 0; i < splatCount; i++) {\n                    for (let shIndexWrite = 0; shIndexWrite < header.shCoefficientCount; shIndexWrite++) {\n                        const shValue = ubuf[shIndexRead++];\n                        const textureIndex = Math.floor(shIndexWrite / 16);\n                        const shArray = sh[textureIndex];\n                        const byteIndexInTexture = shIndexWrite % 16; // [0..15]\n                        const offsetPerSplat = i * 16; // 16 sh values per texture per splat.\n                        shArray[byteIndexInTexture + offsetPerSplat] = shValue;\n                    }\n                }\n            }\n        }\n        return { buffer: header.buffer, sh: sh };\n    }\n    /**\n     * Converts a .ply data array buffer to splat\n     * if data array buffer is not ply, returns the original buffer\n     * @param data the .ply data to load\n     * @param useCoroutine use coroutine and yield\n     * @returns the loaded splat buffer without SH coefficient, whether ply contains or not SH.\n     */\n    static *ConvertPLYToSplat(data, useCoroutine = false) {\n        const header = GaussianSplattingMesh.ParseHeader(data);\n        if (!header) {\n            return data;\n        }\n        const offset = { value: 0 };\n        const compressedChunks = GaussianSplattingMesh._GetCompressedChunks(header, offset);\n        for (let i = 0; i < header.vertexCount; i++) {\n            GaussianSplattingMesh._GetSplat(header, i, compressedChunks, offset);\n            if (i % GaussianSplattingMesh._PlyConversionBatchSize === 0 && useCoroutine) {\n                yield;\n            }\n        }\n        return header.buffer;\n    }\n    /**\n     * Converts a .ply data array buffer to splat\n     * if data array buffer is not ply, returns the original buffer\n     * @param data the .ply data to load\n     * @returns the loaded splat buffer\n     */\n    static async ConvertPLYToSplatAsync(data) {\n        return await runCoroutineAsync(GaussianSplattingMesh.ConvertPLYToSplat(data, true), createYieldingScheduler());\n    }\n    /**\n     * Converts a .ply with SH data array buffer to splat\n     * if data array buffer is not ply, returns the original buffer\n     * @param data the .ply data to load\n     * @returns the loaded splat buffer with SH\n     */\n    static async ConvertPLYWithSHToSplatAsync(data) {\n        return await runCoroutineAsync(GaussianSplattingMesh.ConvertPLYWithSHToSplat(data, true), createYieldingScheduler());\n    }\n    /**\n     * Loads a .splat Gaussian Splatting array buffer asynchronously\n     * @param data arraybuffer containing splat file\n     * @returns a promise that resolves when the operation is complete\n     */\n    async loadDataAsync(data) {\n        return await this.updateDataAsync(data);\n    }\n    /**\n     * Loads a .splat Gaussian or .ply Splatting file asynchronously\n     * @param url path to the splat file to load\n     * @returns a promise that resolves when the operation is complete\n     * @deprecated Please use SceneLoader.ImportMeshAsync instead\n     */\n    async loadFileAsync(url) {\n        const plyBuffer = await Tools.LoadFileAsync(url, true);\n        const splatsData = await GaussianSplattingMesh.ConvertPLYWithSHToSplatAsync(plyBuffer);\n        await this.updateDataAsync(splatsData.buffer, splatsData.sh);\n    }\n    /**\n     * Releases resources associated with this mesh.\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n     */\n    dispose(doNotRecurse) {\n        this._covariancesATexture?.dispose();\n        this._covariancesBTexture?.dispose();\n        this._centersTexture?.dispose();\n        this._colorsTexture?.dispose();\n        if (this._shTextures) {\n            for (const shTexture of this._shTextures) {\n                shTexture.dispose();\n            }\n        }\n        this._covariancesATexture = null;\n        this._covariancesBTexture = null;\n        this._centersTexture = null;\n        this._colorsTexture = null;\n        this._shTextures = null;\n        this._worker?.terminate();\n        this._worker = null;\n        super.dispose(doNotRecurse, true);\n    }\n    _copyTextures(source) {\n        this._covariancesATexture = source.covariancesATexture?.clone();\n        this._covariancesBTexture = source.covariancesBTexture?.clone();\n        this._centersTexture = source.centersTexture?.clone();\n        this._colorsTexture = source.colorsTexture?.clone();\n        if (source._shTextures) {\n            this._shTextures = [];\n            for (const shTexture of this._shTextures) {\n                this._shTextures?.push(shTexture.clone());\n            }\n        }\n    }\n    /**\n     * Returns a new Mesh object generated from the current mesh properties.\n     * @param name is a string, the name given to the new mesh\n     * @returns a new Gaussian Splatting Mesh\n     */\n    clone(name = \"\") {\n        const newGS = new GaussianSplattingMesh(name, undefined, this.getScene());\n        newGS._copySource(this);\n        newGS.makeGeometryUnique();\n        newGS._vertexCount = this._vertexCount;\n        newGS._copyTextures(this);\n        newGS._modelViewMatrix = Matrix.Identity();\n        newGS._splatPositions = this._splatPositions;\n        newGS._readyToDisplay = false;\n        newGS._instanciateWorker();\n        const binfo = this.getBoundingInfo();\n        newGS.getBoundingInfo().reConstruct(binfo.minimum, binfo.maximum, this.getWorldMatrix());\n        newGS.forcedInstanceCount = newGS._vertexCount;\n        newGS.setEnabled(true);\n        return newGS;\n    }\n    _makeSplat(index, fBuffer, uBuffer, covA, covB, colorArray, minimum, maximum) {\n        const matrixRotation = TmpVectors.Matrix[0];\n        const matrixScale = TmpVectors.Matrix[1];\n        const quaternion = TmpVectors.Quaternion[0];\n        const covBSItemSize = this._useRGBACovariants ? 4 : 2;\n        const x = fBuffer[8 * index + 0];\n        const y = -fBuffer[8 * index + 1];\n        const z = fBuffer[8 * index + 2];\n        this._splatPositions[4 * index + 0] = x;\n        this._splatPositions[4 * index + 1] = y;\n        this._splatPositions[4 * index + 2] = z;\n        minimum.minimizeInPlaceFromFloats(x, y, z);\n        maximum.maximizeInPlaceFromFloats(x, y, z);\n        quaternion.set((uBuffer[32 * index + 28 + 1] - 127.5) / 127.5, (uBuffer[32 * index + 28 + 2] - 127.5) / 127.5, (uBuffer[32 * index + 28 + 3] - 127.5) / 127.5, -(uBuffer[32 * index + 28 + 0] - 127.5) / 127.5);\n        quaternion.normalize();\n        quaternion.toRotationMatrix(matrixRotation);\n        Matrix.ScalingToRef(fBuffer[8 * index + 3 + 0] * 2, fBuffer[8 * index + 3 + 1] * 2, fBuffer[8 * index + 3 + 2] * 2, matrixScale);\n        const m = matrixRotation.multiplyToRef(matrixScale, TmpVectors.Matrix[0]).m;\n        const covariances = this._tmpCovariances;\n        covariances[0] = m[0] * m[0] + m[1] * m[1] + m[2] * m[2];\n        covariances[1] = m[0] * m[4] + m[1] * m[5] + m[2] * m[6];\n        covariances[2] = m[0] * m[8] + m[1] * m[9] + m[2] * m[10];\n        covariances[3] = m[4] * m[4] + m[5] * m[5] + m[6] * m[6];\n        covariances[4] = m[4] * m[8] + m[5] * m[9] + m[6] * m[10];\n        covariances[5] = m[8] * m[8] + m[9] * m[9] + m[10] * m[10];\n        // normalize covA, covB\n        let factor = -10000;\n        for (let covIndex = 0; covIndex < 6; covIndex++) {\n            factor = Math.max(factor, Math.abs(covariances[covIndex]));\n        }\n        this._splatPositions[4 * index + 3] = factor;\n        const transform = factor;\n        covA[index * 4 + 0] = ToHalfFloat(covariances[0] / transform);\n        covA[index * 4 + 1] = ToHalfFloat(covariances[1] / transform);\n        covA[index * 4 + 2] = ToHalfFloat(covariances[2] / transform);\n        covA[index * 4 + 3] = ToHalfFloat(covariances[3] / transform);\n        covB[index * covBSItemSize + 0] = ToHalfFloat(covariances[4] / transform);\n        covB[index * covBSItemSize + 1] = ToHalfFloat(covariances[5] / transform);\n        // colors\n        colorArray[index * 4 + 0] = uBuffer[32 * index + 24 + 0];\n        colorArray[index * 4 + 1] = uBuffer[32 * index + 24 + 1];\n        colorArray[index * 4 + 2] = uBuffer[32 * index + 24 + 2];\n        colorArray[index * 4 + 3] = uBuffer[32 * index + 24 + 3];\n    }\n    _updateTextures(covA, covB, colorArray, sh) {\n        const textureSize = this._getTextureSize(this._vertexCount);\n        // Update the textures\n        const createTextureFromData = (data, width, height, format) => {\n            return new RawTexture(data, width, height, format, this._scene, false, false, Constants.TEXTURE_BILINEAR_SAMPLINGMODE, Constants.TEXTURETYPE_FLOAT);\n        };\n        const createTextureFromDataU8 = (data, width, height, format) => {\n            return new RawTexture(data, width, height, format, this._scene, false, false, Constants.TEXTURE_BILINEAR_SAMPLINGMODE, Constants.TEXTURETYPE_UNSIGNED_BYTE);\n        };\n        const createTextureFromDataU32 = (data, width, height, format) => {\n            return new RawTexture(data, width, height, format, this._scene, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTURETYPE_UNSIGNED_INTEGER);\n        };\n        const createTextureFromDataF16 = (data, width, height, format) => {\n            return new RawTexture(data, width, height, format, this._scene, false, false, Constants.TEXTURE_BILINEAR_SAMPLINGMODE, Constants.TEXTURETYPE_HALF_FLOAT);\n        };\n        if (this._covariancesATexture) {\n            this._delayedTextureUpdate = { covA: covA, covB: covB, colors: colorArray, centers: this._splatPositions, sh: sh };\n            const positions = Float32Array.from(this._splatPositions);\n            const vertexCount = this._vertexCount;\n            this._worker.postMessage({ positions, vertexCount }, [positions.buffer]);\n            this._postToWorker(true);\n        }\n        else {\n            this._covariancesATexture = createTextureFromDataF16(covA, textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA);\n            this._covariancesBTexture = createTextureFromDataF16(covB, textureSize.x, textureSize.y, this._useRGBACovariants ? Constants.TEXTUREFORMAT_RGBA : Constants.TEXTUREFORMAT_RG);\n            this._centersTexture = createTextureFromData(this._splatPositions, textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA);\n            this._colorsTexture = createTextureFromDataU8(colorArray, textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA);\n            if (sh) {\n                this._shTextures = [];\n                for (const shData of sh) {\n                    const buffer = new Uint32Array(shData.buffer);\n                    const shTexture = createTextureFromDataU32(buffer, textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA_INTEGER);\n                    shTexture.wrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\n                    shTexture.wrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\n                    this._shTextures.push(shTexture);\n                }\n            }\n            this._instanciateWorker();\n        }\n    }\n    *_updateData(data, isAsync, sh) {\n        // if a covariance texture is present, then it's not a creation but an update\n        if (!this._covariancesATexture) {\n            this._readyToDisplay = false;\n        }\n        // Parse the data\n        const uBuffer = new Uint8Array(data);\n        const fBuffer = new Float32Array(uBuffer.buffer);\n        if (this._keepInRam) {\n            this._splatsData = data;\n            if (sh) {\n                this._sh = sh;\n            }\n        }\n        const vertexCount = uBuffer.length / GaussianSplattingMesh._RowOutputLength;\n        if (vertexCount != this._vertexCount) {\n            this._updateSplatIndexBuffer(vertexCount);\n        }\n        this._vertexCount = vertexCount;\n        // degree == 1 for 1 texture (3 terms), 2 for 2 textures(8 terms) and 3 for 3 textures (15 terms)\n        this._shDegree = sh ? sh.length : 0;\n        const textureSize = this._getTextureSize(vertexCount);\n        const textureLength = textureSize.x * textureSize.y;\n        const lineCountUpdate = GaussianSplattingMesh.ProgressiveUpdateAmount ?? textureSize.y;\n        const textureLengthPerUpdate = textureSize.x * lineCountUpdate;\n        this._splatPositions = new Float32Array(4 * textureLength);\n        const covA = new Uint16Array(textureLength * 4);\n        const covB = new Uint16Array((this._useRGBACovariants ? 4 : 2) * textureLength);\n        const colorArray = new Uint8Array(textureLength * 4);\n        const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n        if (GaussianSplattingMesh.ProgressiveUpdateAmount) {\n            // create textures with not filled-yet array, then update directly portions of it\n            this._updateTextures(covA, covB, colorArray, sh);\n            this.setEnabled(true);\n            const partCount = Math.ceil(textureSize.y / lineCountUpdate);\n            for (let partIndex = 0; partIndex < partCount; partIndex++) {\n                const updateLine = partIndex * lineCountUpdate;\n                const splatIndexBase = updateLine * textureSize.x;\n                for (let i = 0; i < textureLengthPerUpdate; i++) {\n                    this._makeSplat(splatIndexBase + i, fBuffer, uBuffer, covA, covB, colorArray, minimum, maximum);\n                }\n                this._updateSubTextures(this._splatPositions, covA, covB, colorArray, updateLine, Math.min(lineCountUpdate, textureSize.y - updateLine));\n                // Update the binfo\n                this.getBoundingInfo().reConstruct(minimum, maximum, this.getWorldMatrix());\n                if (isAsync) {\n                    yield;\n                }\n            }\n            // sort will be dirty here as just finished filled positions will not be sorted\n            const positions = Float32Array.from(this._splatPositions);\n            const vertexCount = this._vertexCount;\n            this._worker.postMessage({ positions, vertexCount }, [positions.buffer]);\n            this._sortIsDirty = true;\n        }\n        else {\n            for (let i = 0; i < vertexCount; i++) {\n                this._makeSplat(i, fBuffer, uBuffer, covA, covB, colorArray, minimum, maximum);\n                if (isAsync && i % GaussianSplattingMesh._SplatBatchSize === 0) {\n                    yield;\n                }\n            }\n            // textures\n            this._updateTextures(covA, covB, colorArray, sh);\n            // Update the binfo\n            this.getBoundingInfo().reConstruct(minimum, maximum, this.getWorldMatrix());\n            this.setEnabled(true);\n        }\n        this._postToWorker(true);\n    }\n    /**\n     * Update asynchronously the buffer\n     * @param data array buffer containing center, color, orientation and scale of splats\n     * @param sh optional array of uint8 array for SH data\n     * @returns a promise\n     */\n    async updateDataAsync(data, sh) {\n        return await runCoroutineAsync(this._updateData(data, true, sh), createYieldingScheduler());\n    }\n    /**\n     * @experimental\n     * Update data from GS (position, orientation, color, scaling)\n     * @param data array that contain all the datas\n     * @param sh optional array of uint8 array for SH data\n     */\n    updateData(data, sh) {\n        runCoroutineSync(this._updateData(data, false, sh));\n    }\n    /**\n     * Refreshes the bounding info, taking into account all the thin instances defined\n     * @returns the current Gaussian Splatting\n     */\n    refreshBoundingInfo() {\n        this.thinInstanceRefreshBoundingInfo(false);\n        return this;\n    }\n    // in case size is different\n    _updateSplatIndexBuffer(vertexCount) {\n        if (!this._splatIndex || vertexCount > this._splatIndex.length) {\n            this._splatIndex = new Float32Array(vertexCount);\n            this.thinInstanceSetBuffer(\"splatIndex\", this._splatIndex, 1, false);\n        }\n        this.forcedInstanceCount = vertexCount;\n    }\n    _updateSubTextures(centers, covA, covB, colors, lineStart, lineCount, sh) {\n        const updateTextureFromData = (texture, data, width, lineStart, lineCount) => {\n            this.getEngine().updateTextureData(texture.getInternalTexture(), data, 0, lineStart, width, lineCount, 0, 0, false);\n        };\n        const textureSize = this._getTextureSize(this._vertexCount);\n        const covBSItemSize = this._useRGBACovariants ? 4 : 2;\n        const texelStart = lineStart * textureSize.x;\n        const texelCount = lineCount * textureSize.x;\n        const covAView = new Uint16Array(covA.buffer, texelStart * 4 * Uint16Array.BYTES_PER_ELEMENT, texelCount * 4);\n        const covBView = new Uint16Array(covB.buffer, texelStart * covBSItemSize * Uint16Array.BYTES_PER_ELEMENT, texelCount * covBSItemSize);\n        const colorsView = new Uint8Array(colors.buffer, texelStart * 4, texelCount * 4);\n        const centersView = new Float32Array(centers.buffer, texelStart * 4 * Float32Array.BYTES_PER_ELEMENT, texelCount * 4);\n        updateTextureFromData(this._covariancesATexture, covAView, textureSize.x, lineStart, lineCount);\n        updateTextureFromData(this._covariancesBTexture, covBView, textureSize.x, lineStart, lineCount);\n        updateTextureFromData(this._centersTexture, centersView, textureSize.x, lineStart, lineCount);\n        updateTextureFromData(this._colorsTexture, colorsView, textureSize.x, lineStart, lineCount);\n        if (sh) {\n            for (let i = 0; i < sh.length; i++) {\n                const componentCount = 4;\n                const shView = new Uint8Array(this._sh[i].buffer, texelStart * componentCount, texelCount * componentCount);\n                updateTextureFromData(this._shTextures[i], shView, textureSize.x, lineStart, lineCount);\n            }\n        }\n    }\n    _instanciateWorker() {\n        if (!this._vertexCount) {\n            return;\n        }\n        this._updateSplatIndexBuffer(this._vertexCount);\n        // Start the worker thread\n        this._worker?.terminate();\n        this._worker = new Worker(URL.createObjectURL(new Blob([\"(\", GaussianSplattingMesh._CreateWorker.toString(), \")(self)\"], {\n            type: \"application/javascript\",\n        })));\n        this._depthMix = new BigInt64Array(this._vertexCount);\n        const positions = Float32Array.from(this._splatPositions);\n        const vertexCount = this._vertexCount;\n        this._worker.postMessage({ positions, vertexCount }, [positions.buffer]);\n        this._worker.onmessage = (e) => {\n            this._depthMix = e.data.depthMix;\n            const indexMix = new Uint32Array(e.data.depthMix.buffer);\n            if (this._splatIndex) {\n                for (let j = 0; j < this._vertexCount; j++) {\n                    this._splatIndex[j] = indexMix[2 * j];\n                }\n            }\n            if (this._delayedTextureUpdate) {\n                const textureSize = this._getTextureSize(vertexCount);\n                this._updateSubTextures(this._delayedTextureUpdate.centers, this._delayedTextureUpdate.covA, this._delayedTextureUpdate.covB, this._delayedTextureUpdate.colors, 0, textureSize.y, this._delayedTextureUpdate.sh);\n                this._delayedTextureUpdate = null;\n            }\n            this.thinInstanceBufferUpdated(\"splatIndex\");\n            this._canPostToWorker = true;\n            this._readyToDisplay = true;\n            // sort is dirty when GS is visible for progressive update with a this message arriving but positions were partially filled\n            // another update needs to be kicked. The kick can't happen just when the position buffer is ready because _canPostToWorker might be false.\n            if (this._sortIsDirty) {\n                this._postToWorker(true);\n                this._sortIsDirty = false;\n            }\n        };\n    }\n    _getTextureSize(length) {\n        const engine = this._scene.getEngine();\n        const width = engine.getCaps().maxTextureSize;\n        let height = 1;\n        if (engine.version === 1 && !engine.isWebGPU) {\n            while (width * height < length) {\n                height *= 2;\n            }\n        }\n        else {\n            height = Math.ceil(length / width);\n        }\n        if (height > width) {\n            Logger.Error(\"GaussianSplatting texture size: (\" + width + \", \" + height + \"), maxTextureSize: \" + width);\n            height = width;\n        }\n        return new Vector2(width, height);\n    }\n}\nGaussianSplattingMesh._RowOutputLength = 3 * 4 + 3 * 4 + 4 + 4; // Vector3 position, Vector3 scale, 1 u8 quaternion, 1 color with alpha\nGaussianSplattingMesh._SH_C0 = 0.28209479177387814;\n// batch size between 2 yield calls. This value is a tradeoff between updates overhead and framerate hiccups\n// This step is faster the PLY conversion. So batch size can be bigger\nGaussianSplattingMesh._SplatBatchSize = 327680;\n// batch size between 2 yield calls during the PLY to splat conversion.\nGaussianSplattingMesh._PlyConversionBatchSize = 32768;\n/**\n * Set the number of batch (a batch is 16384 splats) after which a display update is performed\n * A value of 0 (default) means display update will not happens before splat is ready.\n */\nGaussianSplattingMesh.ProgressiveUpdateAmount = 0;\nGaussianSplattingMesh._CreateWorker = function (self) {\n    let vertexCount = 0;\n    let positions;\n    let depthMix;\n    let indices;\n    let floatMix;\n    self.onmessage = (e) => {\n        // updated on init\n        if (e.data.positions) {\n            positions = e.data.positions;\n            vertexCount = e.data.vertexCount;\n        }\n        // udpate on view changed\n        else {\n            const viewProj = e.data.view;\n            if (!positions || !viewProj) {\n                // Sanity check, it shouldn't happen!\n                throw new Error(\"positions or view is not defined!\");\n            }\n            depthMix = e.data.depthMix;\n            indices = new Uint32Array(depthMix.buffer);\n            floatMix = new Float32Array(depthMix.buffer);\n            // Sort\n            for (let j = 0; j < vertexCount; j++) {\n                indices[2 * j] = j;\n            }\n            let depthFactor = -1;\n            if (e.data.useRightHandedSystem) {\n                depthFactor = 1;\n            }\n            for (let j = 0; j < vertexCount; j++) {\n                floatMix[2 * j + 1] = 10000 + (viewProj[2] * positions[4 * j + 0] + viewProj[6] * positions[4 * j + 1] + viewProj[10] * positions[4 * j + 2]) * depthFactor;\n            }\n            depthMix.sort();\n            self.postMessage({ depthMix }, [depthMix.buffer]);\n        }\n    };\n};\n//# sourceMappingURL=gaussianSplattingMesh.js.map","import { Color4, Color3 } from \"../Maths/math\";\nimport { Vector2, Vector3, Vector4, TmpVectors, Matrix } from \"../Maths/math.vector\";\nimport { Logger } from \"../Misc/logger\";\nimport { VertexBuffer } from \"../Buffers/buffer\";\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { CloudPoint, PointsGroup } from \"./cloudPoint\";\nimport { Ray } from \"../Culling/ray\";\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\nimport { BaseTexture } from \"./../Materials/Textures/baseTexture\";\nimport { RandomRange } from \"../Maths/math.scalar.functions\";\n/** Defines the 4 color options */\nexport var PointColor;\n(function (PointColor) {\n    /** color value */\n    PointColor[PointColor[\"Color\"] = 2] = \"Color\";\n    /** uv value */\n    PointColor[PointColor[\"UV\"] = 1] = \"UV\";\n    /** random value */\n    PointColor[PointColor[\"Random\"] = 0] = \"Random\";\n    /** stated value */\n    PointColor[PointColor[\"Stated\"] = 3] = \"Stated\";\n})(PointColor || (PointColor = {}));\n/**\n * The PointCloudSystem (PCS) is a single updatable mesh. The points corresponding to the vertices of this big mesh.\n * As it is just a mesh, the PointCloudSystem has all the same properties as any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.\n\n * The PointCloudSystem is also a particle system, with each point being a particle. It provides some methods to manage the particles.\n * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.\n *\n * Full documentation here : TO BE ENTERED\n */\nexport class PointsCloudSystem {\n    /**\n     * Gets the particle positions computed by the Point Cloud System\n     */\n    get positions() {\n        return this._positions32;\n    }\n    /**\n     * Gets the particle colors computed by the Point Cloud System\n     */\n    get colors() {\n        return this._colors32;\n    }\n    /**\n     * Gets the particle uvs computed by the Point Cloud System\n     */\n    get uvs() {\n        return this._uvs32;\n    }\n    /**\n     * Creates a PCS (Points Cloud System) object\n     * @param name (String) is the PCS name, this will be the underlying mesh name\n     * @param pointSize (number) is the size for each point. Has no effect on a WebGPU engine.\n     * @param scene (Scene) is the scene in which the PCS is added\n     * @param options defines the options of the PCS e.g.\n     * * updatable (optional boolean, default true) : if the PCS must be updatable or immutable\n     */\n    constructor(name, pointSize, scene, options) {\n        /**\n         *  The PCS array of cloud point objects. Just access each particle as with any classic array.\n         *  Example : var p = SPS.particles[i];\n         */\n        this.particles = new Array();\n        /**\n         * The PCS total number of particles. Read only. Use PCS.counter instead if you need to set your own value.\n         */\n        this.nbParticles = 0;\n        /**\n         * This a counter for your own usage. It's not set by any SPS functions.\n         */\n        this.counter = 0;\n        /**\n         * This empty object is intended to store some PCS specific or temporary values in order to lower the Garbage Collector activity.\n         * Please read :\n         */\n        this.vars = {};\n        this._promises = [];\n        this._positions = new Array();\n        this._indices = new Array();\n        this._normals = new Array();\n        this._colors = new Array();\n        this._uvs = new Array();\n        this._updatable = true;\n        this._isVisibilityBoxLocked = false;\n        this._alwaysVisible = false;\n        this._groups = new Array(); //start indices for each group of particles\n        this._groupCounter = 0;\n        this._computeParticleColor = true;\n        this._computeParticleTexture = true;\n        this._computeParticleRotation = true;\n        this._computeBoundingBox = false;\n        this._isReady = false;\n        this.name = name;\n        this._size = pointSize;\n        this._scene = scene || EngineStore.LastCreatedScene;\n        if (options && options.updatable !== undefined) {\n            this._updatable = options.updatable;\n        }\n        else {\n            this._updatable = true;\n        }\n    }\n    /**\n     * Builds the PCS underlying mesh. Returns a standard Mesh.\n     * If no points were added to the PCS, the returned mesh is just a single point.\n     * @param material The material to use to render the mesh. If not provided, will create a default one\n     * @returns a promise for the created mesh\n     */\n    async buildMeshAsync(material) {\n        await Promise.all(this._promises);\n        this._isReady = true;\n        return await this._buildMeshAsync(material);\n    }\n    async _buildMeshAsync(material) {\n        if (this.nbParticles === 0) {\n            this.addPoints(1);\n        }\n        this._positions32 = new Float32Array(this._positions);\n        this._uvs32 = new Float32Array(this._uvs);\n        this._colors32 = new Float32Array(this._colors);\n        const vertexData = new VertexData();\n        vertexData.set(this._positions32, VertexBuffer.PositionKind);\n        if (this._uvs32.length > 0) {\n            vertexData.set(this._uvs32, VertexBuffer.UVKind);\n        }\n        let ec = 0; //emissive color value 0 for UVs, 1 for color\n        if (this._colors32.length > 0) {\n            ec = 1;\n            vertexData.set(this._colors32, VertexBuffer.ColorKind);\n        }\n        const mesh = new Mesh(this.name, this._scene);\n        vertexData.applyToMesh(mesh, this._updatable);\n        this.mesh = mesh;\n        // free memory\n        this._positions = null;\n        this._uvs = null;\n        this._colors = null;\n        if (!this._updatable) {\n            this.particles.length = 0;\n        }\n        let mat = material;\n        if (!mat) {\n            mat = new StandardMaterial(\"point cloud material\", this._scene);\n            mat.emissiveColor = new Color3(ec, ec, ec);\n            mat.disableLighting = true;\n            mat.pointsCloud = true;\n            mat.pointSize = this._size;\n        }\n        mesh.material = mat;\n        return mesh;\n    }\n    // adds a new particle object in the particles array\n    _addParticle(idx, group, groupId, idxInGroup) {\n        const cp = new CloudPoint(idx, group, groupId, idxInGroup, this);\n        this.particles.push(cp);\n        return cp;\n    }\n    _randomUnitVector(particle) {\n        particle.position = new Vector3(Math.random(), Math.random(), Math.random());\n        particle.color = new Color4(1, 1, 1, 1);\n    }\n    _getColorIndicesForCoord(pointsGroup, x, y, width) {\n        const imageData = pointsGroup._groupImageData;\n        const color = y * (width * 4) + x * 4;\n        const colorIndices = [color, color + 1, color + 2, color + 3];\n        const redIndex = colorIndices[0];\n        const greenIndex = colorIndices[1];\n        const blueIndex = colorIndices[2];\n        const alphaIndex = colorIndices[3];\n        const redForCoord = imageData[redIndex];\n        const greenForCoord = imageData[greenIndex];\n        const blueForCoord = imageData[blueIndex];\n        const alphaForCoord = imageData[alphaIndex];\n        return new Color4(redForCoord / 255, greenForCoord / 255, blueForCoord / 255, alphaForCoord);\n    }\n    _setPointsColorOrUV(mesh, pointsGroup, isVolume, colorFromTexture, hasTexture, color, range, uvSetIndex) {\n        uvSetIndex = uvSetIndex ?? 0;\n        if (isVolume) {\n            mesh.updateFacetData();\n        }\n        const boundInfo = mesh.getBoundingInfo();\n        const diameter = 2 * boundInfo.boundingSphere.radius;\n        let meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n        const meshInd = mesh.getIndices();\n        const meshUV = mesh.getVerticesData(VertexBuffer.UVKind + (uvSetIndex ? uvSetIndex + 1 : \"\"));\n        const meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);\n        const place = Vector3.Zero();\n        mesh.computeWorldMatrix();\n        const meshMatrix = mesh.getWorldMatrix();\n        if (!meshMatrix.isIdentity()) {\n            meshPos = meshPos.slice(0);\n            for (let p = 0; p < meshPos.length / 3; p++) {\n                Vector3.TransformCoordinatesFromFloatsToRef(meshPos[3 * p], meshPos[3 * p + 1], meshPos[3 * p + 2], meshMatrix, place);\n                meshPos[3 * p] = place.x;\n                meshPos[3 * p + 1] = place.y;\n                meshPos[3 * p + 2] = place.z;\n            }\n        }\n        let idxPoints = 0;\n        let id0 = 0;\n        let id1 = 0;\n        let id2 = 0;\n        let v0X = 0;\n        let v0Y = 0;\n        let v0Z = 0;\n        let v1X = 0;\n        let v1Y = 0;\n        let v1Z = 0;\n        let v2X = 0;\n        let v2Y = 0;\n        let v2Z = 0;\n        const vertex0 = Vector3.Zero();\n        const vertex1 = Vector3.Zero();\n        const vertex2 = Vector3.Zero();\n        const vec0 = Vector3.Zero();\n        const vec1 = Vector3.Zero();\n        let uv0X = 0;\n        let uv0Y = 0;\n        let uv1X = 0;\n        let uv1Y = 0;\n        let uv2X = 0;\n        let uv2Y = 0;\n        const uv0 = Vector2.Zero();\n        const uv1 = Vector2.Zero();\n        const uv2 = Vector2.Zero();\n        const uvec0 = Vector2.Zero();\n        const uvec1 = Vector2.Zero();\n        let col0X = 0;\n        let col0Y = 0;\n        let col0Z = 0;\n        let col0A = 0;\n        let col1X = 0;\n        let col1Y = 0;\n        let col1Z = 0;\n        let col1A = 0;\n        let col2X = 0;\n        let col2Y = 0;\n        let col2Z = 0;\n        let col2A = 0;\n        const col0 = Vector4.Zero();\n        const col1 = Vector4.Zero();\n        const col2 = Vector4.Zero();\n        const colvec0 = Vector4.Zero();\n        const colvec1 = Vector4.Zero();\n        let lamda = 0;\n        let mu = 0;\n        range = range ? range : 0;\n        let facetPoint;\n        let uvPoint;\n        let colPoint = new Vector4(0, 0, 0, 0);\n        let norm = Vector3.Zero();\n        let tang = Vector3.Zero();\n        let biNorm = Vector3.Zero();\n        let angle = 0;\n        let facetPlaneVec = Vector3.Zero();\n        let gap = 0;\n        let distance = 0;\n        const ray = new Ray(Vector3.Zero(), new Vector3(1, 0, 0));\n        let pickInfo;\n        let direction = Vector3.Zero();\n        for (let index = 0; index < meshInd.length / 3; index++) {\n            id0 = meshInd[3 * index];\n            id1 = meshInd[3 * index + 1];\n            id2 = meshInd[3 * index + 2];\n            v0X = meshPos[3 * id0];\n            v0Y = meshPos[3 * id0 + 1];\n            v0Z = meshPos[3 * id0 + 2];\n            v1X = meshPos[3 * id1];\n            v1Y = meshPos[3 * id1 + 1];\n            v1Z = meshPos[3 * id1 + 2];\n            v2X = meshPos[3 * id2];\n            v2Y = meshPos[3 * id2 + 1];\n            v2Z = meshPos[3 * id2 + 2];\n            vertex0.set(v0X, v0Y, v0Z);\n            vertex1.set(v1X, v1Y, v1Z);\n            vertex2.set(v2X, v2Y, v2Z);\n            vertex1.subtractToRef(vertex0, vec0);\n            vertex2.subtractToRef(vertex1, vec1);\n            if (meshUV) {\n                uv0X = meshUV[2 * id0];\n                uv0Y = meshUV[2 * id0 + 1];\n                uv1X = meshUV[2 * id1];\n                uv1Y = meshUV[2 * id1 + 1];\n                uv2X = meshUV[2 * id2];\n                uv2Y = meshUV[2 * id2 + 1];\n                uv0.set(uv0X, uv0Y);\n                uv1.set(uv1X, uv1Y);\n                uv2.set(uv2X, uv2Y);\n                uv1.subtractToRef(uv0, uvec0);\n                uv2.subtractToRef(uv1, uvec1);\n            }\n            if (meshCol && colorFromTexture) {\n                col0X = meshCol[4 * id0];\n                col0Y = meshCol[4 * id0 + 1];\n                col0Z = meshCol[4 * id0 + 2];\n                col0A = meshCol[4 * id0 + 3];\n                col1X = meshCol[4 * id1];\n                col1Y = meshCol[4 * id1 + 1];\n                col1Z = meshCol[4 * id1 + 2];\n                col1A = meshCol[4 * id1 + 3];\n                col2X = meshCol[4 * id2];\n                col2Y = meshCol[4 * id2 + 1];\n                col2Z = meshCol[4 * id2 + 2];\n                col2A = meshCol[4 * id2 + 3];\n                col0.set(col0X, col0Y, col0Z, col0A);\n                col1.set(col1X, col1Y, col1Z, col1A);\n                col2.set(col2X, col2Y, col2Z, col2A);\n                col1.subtractToRef(col0, colvec0);\n                col2.subtractToRef(col1, colvec1);\n            }\n            let width;\n            let height;\n            let deltaS;\n            let deltaV;\n            let h;\n            let s;\n            let v;\n            let hsvCol;\n            const statedColor = new Color3(0, 0, 0);\n            const colPoint3 = new Color3(0, 0, 0);\n            let pointColors;\n            let particle;\n            for (let i = 0; i < pointsGroup._groupDensity[index]; i++) {\n                idxPoints = this.particles.length;\n                this._addParticle(idxPoints, pointsGroup, this._groupCounter, index + i);\n                particle = this.particles[idxPoints];\n                //form a point inside the facet v0, v1, v2;\n                lamda = Math.sqrt(RandomRange(0, 1));\n                mu = RandomRange(0, 1);\n                facetPoint = vertex0.add(vec0.scale(lamda)).add(vec1.scale(lamda * mu));\n                if (isVolume) {\n                    norm = mesh.getFacetNormal(index).normalize().scale(-1);\n                    tang = vec0.clone().normalize();\n                    biNorm = Vector3.Cross(norm, tang);\n                    angle = RandomRange(0, 2 * Math.PI);\n                    facetPlaneVec = tang.scale(Math.cos(angle)).add(biNorm.scale(Math.sin(angle)));\n                    angle = RandomRange(0.1, Math.PI / 2);\n                    direction = facetPlaneVec.scale(Math.cos(angle)).add(norm.scale(Math.sin(angle)));\n                    ray.origin = facetPoint.add(direction.scale(0.00001));\n                    ray.direction = direction;\n                    ray.length = diameter;\n                    pickInfo = ray.intersectsMesh(mesh);\n                    if (pickInfo.hit) {\n                        distance = pickInfo.pickedPoint.subtract(facetPoint).length();\n                        gap = RandomRange(0, 1) * distance;\n                        facetPoint.addInPlace(direction.scale(gap));\n                    }\n                }\n                particle.position = facetPoint.clone();\n                this._positions.push(particle.position.x, particle.position.y, particle.position.z);\n                if (colorFromTexture !== undefined) {\n                    if (meshUV) {\n                        uvPoint = uv0.add(uvec0.scale(lamda)).add(uvec1.scale(lamda * mu));\n                        if (colorFromTexture) {\n                            //Set particle color to texture color\n                            if (hasTexture && pointsGroup._groupImageData !== null) {\n                                width = pointsGroup._groupImgWidth;\n                                height = pointsGroup._groupImgHeight;\n                                pointColors = this._getColorIndicesForCoord(pointsGroup, Math.round(uvPoint.x * width), Math.round(uvPoint.y * height), width);\n                                particle.color = pointColors;\n                                this._colors.push(pointColors.r, pointColors.g, pointColors.b, pointColors.a);\n                            }\n                            else {\n                                if (meshCol) {\n                                    //failure in texture and colors available\n                                    colPoint = col0.add(colvec0.scale(lamda)).add(colvec1.scale(lamda * mu));\n                                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                                }\n                                else {\n                                    colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\n                                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                                }\n                            }\n                        }\n                        else {\n                            //Set particle uv based on a mesh uv\n                            particle.uv = uvPoint.clone();\n                            this._uvs.push(particle.uv.x, particle.uv.y);\n                        }\n                    }\n                }\n                else {\n                    if (color) {\n                        statedColor.set(color.r, color.g, color.b);\n                        deltaS = RandomRange(-range, range);\n                        deltaV = RandomRange(-range, range);\n                        hsvCol = statedColor.toHSV();\n                        h = hsvCol.r;\n                        s = hsvCol.g + deltaS;\n                        v = hsvCol.b + deltaV;\n                        if (s < 0) {\n                            s = 0;\n                        }\n                        if (s > 1) {\n                            s = 1;\n                        }\n                        if (v < 0) {\n                            v = 0;\n                        }\n                        if (v > 1) {\n                            v = 1;\n                        }\n                        Color3.HSVtoRGBToRef(h, s, v, colPoint3);\n                        colPoint.set(colPoint3.r, colPoint3.g, colPoint3.b, 1);\n                    }\n                    else {\n                        colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\n                    }\n                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                }\n            }\n        }\n    }\n    // stores mesh texture in dynamic texture for color pixel retrieval\n    // when pointColor type is color for surface points\n    _colorFromTexture(mesh, pointsGroup, isVolume) {\n        if (mesh.material === null) {\n            Logger.Warn(mesh.name + \"has no material.\");\n            pointsGroup._groupImageData = null;\n            this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\n            return;\n        }\n        const mat = mesh.material;\n        const textureList = mat.getActiveTextures();\n        if (textureList.length === 0) {\n            Logger.Warn(mesh.name + \"has no usable texture.\");\n            pointsGroup._groupImageData = null;\n            this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\n            return;\n        }\n        const clone = mesh.clone();\n        clone.setEnabled(false);\n        this._promises.push(new Promise((resolve) => {\n            BaseTexture.WhenAllReady(textureList, () => {\n                let n = pointsGroup._textureNb;\n                if (n < 0) {\n                    n = 0;\n                }\n                if (n > textureList.length - 1) {\n                    n = textureList.length - 1;\n                }\n                const finalize = () => {\n                    pointsGroup._groupImgWidth = textureList[n].getSize().width;\n                    pointsGroup._groupImgHeight = textureList[n].getSize().height;\n                    this._setPointsColorOrUV(clone, pointsGroup, isVolume, true, true, undefined, undefined, textureList[n].coordinatesIndex);\n                    clone.dispose();\n                    resolve();\n                };\n                pointsGroup._groupImageData = null;\n                const dataPromise = textureList[n].readPixels();\n                if (!dataPromise) {\n                    finalize();\n                }\n                else {\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n                    dataPromise.then((data) => {\n                        pointsGroup._groupImageData = data;\n                        finalize();\n                    });\n                }\n            });\n        }));\n    }\n    // calculates the point density per facet of a mesh for surface points\n    _calculateDensity(nbPoints, positions, indices) {\n        let id0;\n        let id1;\n        let id2;\n        let v0X;\n        let v0Y;\n        let v0Z;\n        let v1X;\n        let v1Y;\n        let v1Z;\n        let v2X;\n        let v2Y;\n        let v2Z;\n        const vertex0 = Vector3.Zero();\n        const vertex1 = Vector3.Zero();\n        const vertex2 = Vector3.Zero();\n        const vec0 = Vector3.Zero();\n        const vec1 = Vector3.Zero();\n        const normal = Vector3.Zero();\n        let area;\n        const cumulativeAreas = [];\n        let surfaceArea = 0;\n        const nbFacets = indices.length / 3;\n        //surface area\n        for (let index = 0; index < nbFacets; index++) {\n            id0 = indices[3 * index];\n            id1 = indices[3 * index + 1];\n            id2 = indices[3 * index + 2];\n            v0X = positions[3 * id0];\n            v0Y = positions[3 * id0 + 1];\n            v0Z = positions[3 * id0 + 2];\n            v1X = positions[3 * id1];\n            v1Y = positions[3 * id1 + 1];\n            v1Z = positions[3 * id1 + 2];\n            v2X = positions[3 * id2];\n            v2Y = positions[3 * id2 + 1];\n            v2Z = positions[3 * id2 + 2];\n            vertex0.set(v0X, v0Y, v0Z);\n            vertex1.set(v1X, v1Y, v1Z);\n            vertex2.set(v2X, v2Y, v2Z);\n            vertex1.subtractToRef(vertex0, vec0);\n            vertex2.subtractToRef(vertex1, vec1);\n            Vector3.CrossToRef(vec0, vec1, normal);\n            area = 0.5 * normal.length();\n            surfaceArea += area;\n            cumulativeAreas[index] = surfaceArea;\n        }\n        const density = new Array(nbFacets);\n        let remainingPoints = nbPoints;\n        for (let index = nbFacets - 1; index > 0; index--) {\n            const cumulativeArea = cumulativeAreas[index];\n            if (cumulativeArea === 0) {\n                // avoiding division by 0 upon degenerate triangles\n                density[index] = 0;\n            }\n            else {\n                const area = cumulativeArea - cumulativeAreas[index - 1];\n                const facetPointsWithFraction = (area / cumulativeArea) * remainingPoints;\n                const floored = Math.floor(facetPointsWithFraction);\n                const fraction = facetPointsWithFraction - floored;\n                const extraPoint = Number(Math.random() < fraction);\n                const facetPoints = floored + extraPoint;\n                density[index] = facetPoints;\n                remainingPoints -= facetPoints;\n            }\n        }\n        density[0] = remainingPoints;\n        return density;\n    }\n    /**\n     * Adds points to the PCS in random positions within a unit sphere\n     * @param nb (positive integer) the number of particles to be created from this model\n     * @param pointFunction is an optional javascript function to be called for each particle on PCS creation\n     * @returns the number of groups in the system\n     */\n    addPoints(nb, pointFunction = this._randomUnitVector) {\n        const pointsGroup = new PointsGroup(this._groupCounter, pointFunction);\n        let cp;\n        // particles\n        let idx = this.nbParticles;\n        for (let i = 0; i < nb; i++) {\n            cp = this._addParticle(idx, pointsGroup, this._groupCounter, i);\n            if (pointsGroup && pointsGroup._positionFunction) {\n                pointsGroup._positionFunction(cp, idx, i);\n            }\n            this._positions.push(cp.position.x, cp.position.y, cp.position.z);\n            if (cp.color) {\n                this._colors.push(cp.color.r, cp.color.g, cp.color.b, cp.color.a);\n            }\n            if (cp.uv) {\n                this._uvs.push(cp.uv.x, cp.uv.y);\n            }\n            idx++;\n        }\n        this.nbParticles += nb;\n        this._groupCounter++;\n        return this._groupCounter;\n    }\n    /**\n     * Adds points to the PCS from the surface of the model shape\n     * @param mesh is any Mesh object that will be used as a surface model for the points\n     * @param nb (positive integer) the number of particles to be created from this model\n     * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\n     * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\n     * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\n     * @returns the number of groups in the system\n     */\n    addSurfacePoints(mesh, nb, colorWith, color, range) {\n        let colored = colorWith ? colorWith : 0 /* PointColor.Random */;\n        if (isNaN(colored) || colored < 0 || colored > 3) {\n            colored = 0 /* PointColor.Random */;\n        }\n        const meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n        const meshInd = mesh.getIndices();\n        this._groups.push(this._groupCounter);\n        const pointsGroup = new PointsGroup(this._groupCounter, null);\n        pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\n        if (colored === 2 /* PointColor.Color */) {\n            pointsGroup._textureNb = color ? color : 0;\n        }\n        else {\n            color = color ? color : new Color4(1, 1, 1, 1);\n        }\n        switch (colored) {\n            case 2 /* PointColor.Color */:\n                this._colorFromTexture(mesh, pointsGroup, false);\n                break;\n            case 1 /* PointColor.UV */:\n                this._setPointsColorOrUV(mesh, pointsGroup, false, false, false);\n                break;\n            case 0 /* PointColor.Random */:\n                this._setPointsColorOrUV(mesh, pointsGroup, false);\n                break;\n            case 3 /* PointColor.Stated */:\n                this._setPointsColorOrUV(mesh, pointsGroup, false, undefined, undefined, color, range);\n                break;\n        }\n        this.nbParticles += nb;\n        this._groupCounter++;\n        return this._groupCounter - 1;\n    }\n    /**\n     * Adds points to the PCS inside the model shape\n     * @param mesh is any Mesh object that will be used as a surface model for the points\n     * @param nb (positive integer) the number of particles to be created from this model\n     * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\n     * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\n     * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\n     * @returns the number of groups in the system\n     */\n    addVolumePoints(mesh, nb, colorWith, color, range) {\n        let colored = colorWith ? colorWith : 0 /* PointColor.Random */;\n        if (isNaN(colored) || colored < 0 || colored > 3) {\n            colored = 0 /* PointColor.Random */;\n        }\n        const meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n        const meshInd = mesh.getIndices();\n        this._groups.push(this._groupCounter);\n        const pointsGroup = new PointsGroup(this._groupCounter, null);\n        pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\n        if (colored === 2 /* PointColor.Color */) {\n            pointsGroup._textureNb = color ? color : 0;\n        }\n        else {\n            color = color ? color : new Color4(1, 1, 1, 1);\n        }\n        switch (colored) {\n            case 2 /* PointColor.Color */:\n                this._colorFromTexture(mesh, pointsGroup, true);\n                break;\n            case 1 /* PointColor.UV */:\n                this._setPointsColorOrUV(mesh, pointsGroup, true, false, false);\n                break;\n            case 0 /* PointColor.Random */:\n                this._setPointsColorOrUV(mesh, pointsGroup, true);\n                break;\n            case 3 /* PointColor.Stated */:\n                this._setPointsColorOrUV(mesh, pointsGroup, true, undefined, undefined, color, range);\n                break;\n        }\n        this.nbParticles += nb;\n        this._groupCounter++;\n        return this._groupCounter - 1;\n    }\n    /**\n     *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.\n     *  This method calls `updateParticle()` for each particle of the SPS.\n     *  For an animated SPS, it is usually called within the render loop.\n     * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_\n     * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_\n     * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_\n     * @returns the PCS.\n     */\n    setParticles(start = 0, end = this.nbParticles - 1, update = true) {\n        if (!this._updatable || !this._isReady) {\n            return this;\n        }\n        // custom beforeUpdate\n        this.beforeUpdateParticles(start, end, update);\n        const rotMatrix = TmpVectors.Matrix[0];\n        const mesh = this.mesh;\n        const colors32 = this._colors32;\n        const positions32 = this._positions32;\n        const uvs32 = this._uvs32;\n        const tempVectors = TmpVectors.Vector3;\n        const camAxisX = tempVectors[5].copyFromFloats(1.0, 0.0, 0.0);\n        const camAxisY = tempVectors[6].copyFromFloats(0.0, 1.0, 0.0);\n        const camAxisZ = tempVectors[7].copyFromFloats(0.0, 0.0, 1.0);\n        const minimum = tempVectors[8].setAll(Number.MAX_VALUE);\n        const maximum = tempVectors[9].setAll(-Number.MAX_VALUE);\n        Matrix.IdentityToRef(rotMatrix);\n        let idx = 0; // current index of the particle\n        if (this.mesh?.isFacetDataEnabled) {\n            this._computeBoundingBox = true;\n        }\n        end = end >= this.nbParticles ? this.nbParticles - 1 : end;\n        if (this._computeBoundingBox) {\n            if (start != 0 || end != this.nbParticles - 1) {\n                // only some particles are updated, then use the current existing BBox basis. Note : it can only increase.\n                const boundingInfo = this.mesh?.getBoundingInfo();\n                if (boundingInfo) {\n                    minimum.copyFrom(boundingInfo.minimum);\n                    maximum.copyFrom(boundingInfo.maximum);\n                }\n            }\n        }\n        idx = 0; // particle index\n        let pindex = 0; //index in positions array\n        let cindex = 0; //index in color array\n        let uindex = 0; //index in uv array\n        // particle loop\n        for (let p = start; p <= end; p++) {\n            const particle = this.particles[p];\n            idx = particle.idx;\n            pindex = 3 * idx;\n            cindex = 4 * idx;\n            uindex = 2 * idx;\n            // call to custom user function to update the particle properties\n            this.updateParticle(particle);\n            const particleRotationMatrix = particle._rotationMatrix;\n            const particlePosition = particle.position;\n            const particleGlobalPosition = particle._globalPosition;\n            if (this._computeParticleRotation) {\n                particle.getRotationMatrix(rotMatrix);\n            }\n            const particleHasParent = particle.parentId !== null;\n            if (particleHasParent) {\n                const parent = this.particles[particle.parentId];\n                const parentRotationMatrix = parent._rotationMatrix;\n                const parentGlobalPosition = parent._globalPosition;\n                const rotatedY = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];\n                const rotatedX = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];\n                const rotatedZ = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];\n                particleGlobalPosition.x = parentGlobalPosition.x + rotatedX;\n                particleGlobalPosition.y = parentGlobalPosition.y + rotatedY;\n                particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ;\n                if (this._computeParticleRotation) {\n                    const rotMatrixValues = rotMatrix.m;\n                    particleRotationMatrix[0] =\n                        rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];\n                    particleRotationMatrix[1] =\n                        rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];\n                    particleRotationMatrix[2] =\n                        rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];\n                    particleRotationMatrix[3] =\n                        rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];\n                    particleRotationMatrix[4] =\n                        rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];\n                    particleRotationMatrix[5] =\n                        rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];\n                    particleRotationMatrix[6] =\n                        rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];\n                    particleRotationMatrix[7] =\n                        rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];\n                    particleRotationMatrix[8] =\n                        rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];\n                }\n            }\n            else {\n                particleGlobalPosition.x = 0;\n                particleGlobalPosition.y = 0;\n                particleGlobalPosition.z = 0;\n                if (this._computeParticleRotation) {\n                    const rotMatrixValues = rotMatrix.m;\n                    particleRotationMatrix[0] = rotMatrixValues[0];\n                    particleRotationMatrix[1] = rotMatrixValues[1];\n                    particleRotationMatrix[2] = rotMatrixValues[2];\n                    particleRotationMatrix[3] = rotMatrixValues[4];\n                    particleRotationMatrix[4] = rotMatrixValues[5];\n                    particleRotationMatrix[5] = rotMatrixValues[6];\n                    particleRotationMatrix[6] = rotMatrixValues[8];\n                    particleRotationMatrix[7] = rotMatrixValues[9];\n                    particleRotationMatrix[8] = rotMatrixValues[10];\n                }\n            }\n            const pivotBackTranslation = tempVectors[11];\n            if (particle.translateFromPivot) {\n                pivotBackTranslation.setAll(0.0);\n            }\n            else {\n                pivotBackTranslation.copyFrom(particle.pivot);\n            }\n            // positions\n            const tmpVertex = tempVectors[0];\n            tmpVertex.copyFrom(particle.position);\n            const vertexX = tmpVertex.x - particle.pivot.x;\n            const vertexY = tmpVertex.y - particle.pivot.y;\n            const vertexZ = tmpVertex.z - particle.pivot.z;\n            let rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];\n            let rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];\n            let rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];\n            rotatedX += pivotBackTranslation.x;\n            rotatedY += pivotBackTranslation.y;\n            rotatedZ += pivotBackTranslation.z;\n            const px = (positions32[pindex] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ);\n            const py = (positions32[pindex + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ);\n            const pz = (positions32[pindex + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ);\n            if (this._computeBoundingBox) {\n                minimum.minimizeInPlaceFromFloats(px, py, pz);\n                maximum.maximizeInPlaceFromFloats(px, py, pz);\n            }\n            if (this._computeParticleColor && particle.color) {\n                const color = particle.color;\n                const colors32 = this._colors32;\n                colors32[cindex] = color.r;\n                colors32[cindex + 1] = color.g;\n                colors32[cindex + 2] = color.b;\n                colors32[cindex + 3] = color.a;\n            }\n            if (this._computeParticleTexture && particle.uv) {\n                const uv = particle.uv;\n                const uvs32 = this._uvs32;\n                uvs32[uindex] = uv.x;\n                uvs32[uindex + 1] = uv.y;\n            }\n        }\n        // if the VBO must be updated\n        if (mesh) {\n            if (update) {\n                if (this._computeParticleColor) {\n                    mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);\n                }\n                if (this._computeParticleTexture) {\n                    mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);\n                }\n                mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);\n            }\n            if (this._computeBoundingBox) {\n                if (mesh.hasBoundingInfo) {\n                    mesh.getBoundingInfo().reConstruct(minimum, maximum, mesh._worldMatrix);\n                }\n                else {\n                    mesh.buildBoundingInfo(minimum, maximum, mesh._worldMatrix);\n                }\n            }\n        }\n        this.afterUpdateParticles(start, end, update);\n        return this;\n    }\n    /**\n     * Disposes the PCS.\n     */\n    dispose() {\n        this.mesh?.dispose();\n        this.vars = null;\n        // drop references to internal big arrays for the GC\n        this._positions = null;\n        this._indices = null;\n        this._normals = null;\n        this._uvs = null;\n        this._colors = null;\n        this._indices32 = null;\n        this._positions32 = null;\n        this._uvs32 = null;\n        this._colors32 = null;\n    }\n    /**\n     * Visibility helper : Recomputes the visible size according to the mesh bounding box\n     * doc :\n     * @returns the PCS.\n     */\n    refreshVisibleSize() {\n        if (!this._isVisibilityBoxLocked) {\n            this.mesh?.refreshBoundingInfo();\n        }\n        return this;\n    }\n    /**\n     * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.\n     * @param size the size (float) of the visibility box\n     * note : this doesn't lock the PCS mesh bounding box.\n     * doc :\n     */\n    setVisibilityBox(size) {\n        if (!this.mesh) {\n            return;\n        }\n        const vis = size / 2;\n        this.mesh.buildBoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));\n    }\n    /**\n     * Gets whether the PCS is always visible or not\n     * doc :\n     */\n    get isAlwaysVisible() {\n        return this._alwaysVisible;\n    }\n    /**\n     * Sets the PCS as always visible or not\n     * doc :\n     */\n    set isAlwaysVisible(val) {\n        if (!this.mesh) {\n            return;\n        }\n        this._alwaysVisible = val;\n        this.mesh.alwaysSelectAsActiveMesh = val;\n    }\n    /**\n     * Tells to `setParticles()` to compute the particle rotations or not\n     * Default value : false. The PCS is faster when it's set to false\n     * Note : particle rotations are only applied to parent particles\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate\n     */\n    set computeParticleRotation(val) {\n        this._computeParticleRotation = val;\n    }\n    /**\n     * Tells to `setParticles()` to compute the particle colors or not.\n     * Default value : true. The PCS is faster when it's set to false.\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\n     */\n    set computeParticleColor(val) {\n        this._computeParticleColor = val;\n    }\n    set computeParticleTexture(val) {\n        this._computeParticleTexture = val;\n    }\n    /**\n     * Gets if `setParticles()` computes the particle colors or not.\n     * Default value : false. The PCS is faster when it's set to false.\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\n     */\n    get computeParticleColor() {\n        return this._computeParticleColor;\n    }\n    /**\n     * Gets if `setParticles()` computes the particle textures or not.\n     * Default value : false. The PCS is faster when it's set to false.\n     * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.\n     */\n    get computeParticleTexture() {\n        return this._computeParticleTexture;\n    }\n    /**\n     * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.\n     */\n    set computeBoundingBox(val) {\n        this._computeBoundingBox = val;\n    }\n    /**\n     * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.\n     */\n    get computeBoundingBox() {\n        return this._computeBoundingBox;\n    }\n    // =======================================================================\n    // Particle behavior logic\n    // these following methods may be overwritten by users to fit their needs\n    /**\n     * This function does nothing. It may be overwritten to set all the particle first values.\n     * The PCS doesn't call this function, you may have to call it by your own.\n     * doc :\n     */\n    initParticles() { }\n    /**\n     * This function does nothing. It may be overwritten to recycle a particle\n     * The PCS doesn't call this function, you can to call it\n     * doc :\n     * @param particle The particle to recycle\n     * @returns the recycled particle\n     */\n    recycleParticle(particle) {\n        return particle;\n    }\n    /**\n     * Updates a particle : this function should  be overwritten by the user.\n     * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.\n     * doc :\n     * @example : just set a particle position or velocity and recycle conditions\n     * @param particle The particle to update\n     * @returns the updated particle\n     */\n    updateParticle(particle) {\n        return particle;\n    }\n    /**\n     * This will be called before any other treatment by `setParticles()` and will be passed three parameters.\n     * This does nothing and may be overwritten by the user.\n     * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n     * @param update the boolean update value actually passed to setParticles()\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    beforeUpdateParticles(start, stop, update) { }\n    /**\n     * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.\n     * This will be passed three parameters.\n     * This does nothing and may be overwritten by the user.\n     * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n     * @param update the boolean update value actually passed to setParticles()\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    afterUpdateParticles(start, stop, update) { }\n}\n//# sourceMappingURL=pointsCloudSystem.js.map","import { Color4, Vector2, Vector3, TmpVectors, Quaternion } from \"../Maths/math\";\n/**\n * Represents one particle of a points cloud system.\n */\nexport class CloudPoint {\n    /**\n     * Creates a Point Cloud object.\n     * Don't create particles manually, use instead the PCS internal tools like _addParticle()\n     * @param particleIndex (integer) is the particle index in the PCS pool. It's also the particle identifier.\n     * @param group (PointsGroup) is the group the particle belongs to\n     * @param groupId (integer) is the group identifier in the PCS.\n     * @param idxInGroup (integer) is the index of the particle in the current point group (ex: the 10th point of addPoints(30))\n     * @param pcs defines the PCS it is associated to\n     */\n    constructor(particleIndex, group, groupId, idxInGroup, pcs) {\n        /**\n         * particle global index\n         */\n        this.idx = 0;\n        /**\n         * The color of the particle\n         */\n        this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n        /**\n         * The world space position of the particle.\n         */\n        this.position = Vector3.Zero();\n        /**\n         * The world space rotation of the particle. (Not use if rotationQuaternion is set)\n         */\n        this.rotation = Vector3.Zero();\n        /**\n         * The uv of the particle.\n         */\n        this.uv = new Vector2(0.0, 0.0);\n        /**\n         * The current speed of the particle.\n         */\n        this.velocity = Vector3.Zero();\n        /**\n         * The pivot point in the particle local space.\n         */\n        this.pivot = Vector3.Zero();\n        /**\n         * Must the particle be translated from its pivot point in its local space ?\n         * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.\n         * Default : false\n         */\n        this.translateFromPivot = false;\n        /**\n         * Index of this particle in the global \"positions\" array (Internal use)\n         * @internal\n         */\n        this._pos = 0;\n        /**\n         * @internal Index of this particle in the global \"indices\" array (Internal use)\n         */\n        this._ind = 0;\n        /**\n         * Group id of this particle\n         */\n        this.groupId = 0;\n        /**\n         * Index of the particle in its group id (Internal use)\n         */\n        this.idxInGroup = 0;\n        /**\n         * @internal Still set as invisible in order to skip useless computations (Internal use)\n         */\n        this._stillInvisible = false;\n        /**\n         * @internal Last computed particle rotation matrix\n         */\n        this._rotationMatrix = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];\n        /**\n         * Parent particle Id, if any.\n         * Default null.\n         */\n        this.parentId = null;\n        /**\n         * @internal Internal global position in the PCS.\n         */\n        this._globalPosition = Vector3.Zero();\n        this.idx = particleIndex;\n        this._group = group;\n        this.groupId = groupId;\n        this.idxInGroup = idxInGroup;\n        this._pcs = pcs;\n    }\n    /**\n     * get point size\n     */\n    get size() {\n        return this.size;\n    }\n    /**\n     * Set point size\n     */\n    set size(scale) {\n        this.size = scale;\n    }\n    /**\n     * Legacy support, changed quaternion to rotationQuaternion\n     */\n    get quaternion() {\n        return this.rotationQuaternion;\n    }\n    /**\n     * Legacy support, changed quaternion to rotationQuaternion\n     */\n    set quaternion(q) {\n        this.rotationQuaternion = q;\n    }\n    /**\n     * Returns a boolean. True if the particle intersects a mesh, else false\n     * The intersection is computed on the particle position and Axis Aligned Bounding Box (AABB) or Sphere\n     * @param target is the object (point or mesh) what the intersection is computed against\n     * @param isSphere is boolean flag when false (default) bounding box of mesh is used, when true the bounding sphere is used\n     * @returns true if it intersects\n     */\n    intersectsMesh(target, isSphere) {\n        if (!target.hasBoundingInfo) {\n            return false;\n        }\n        if (!this._pcs.mesh) {\n            throw new Error(\"Point Cloud System doesnt contain the Mesh\");\n        }\n        if (isSphere) {\n            return target.getBoundingInfo().boundingSphere.intersectsPoint(this.position.add(this._pcs.mesh.position));\n        }\n        const bbox = target.getBoundingInfo().boundingBox;\n        const maxX = bbox.maximumWorld.x;\n        const minX = bbox.minimumWorld.x;\n        const maxY = bbox.maximumWorld.y;\n        const minY = bbox.minimumWorld.y;\n        const maxZ = bbox.maximumWorld.z;\n        const minZ = bbox.minimumWorld.z;\n        const x = this.position.x + this._pcs.mesh.position.x;\n        const y = this.position.y + this._pcs.mesh.position.y;\n        const z = this.position.z + this._pcs.mesh.position.z;\n        return minX <= x && x <= maxX && minY <= y && y <= maxY && minZ <= z && z <= maxZ;\n    }\n    /**\n     * get the rotation matrix of the particle\n     * @internal\n     */\n    getRotationMatrix(m) {\n        let quaternion;\n        if (this.rotationQuaternion) {\n            quaternion = this.rotationQuaternion;\n        }\n        else {\n            quaternion = TmpVectors.Quaternion[0];\n            const rotation = this.rotation;\n            Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\n        }\n        quaternion.toRotationMatrix(m);\n    }\n}\n/**\n * Represents a group of points in a points cloud system\n *  * PCS internal tool, don't use it manually.\n */\nexport class PointsGroup {\n    /**\n     * Get or set the groupId\n     * @deprecated Please use groupId instead\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    get groupID() {\n        return this.groupId;\n    }\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    set groupID(groupID) {\n        this.groupId = groupID;\n    }\n    /**\n     * Creates a points group object. This is an internal reference to produce particles for the PCS.\n     * PCS internal tool, don't use it manually.\n     * @internal\n     */\n    constructor(id, posFunction) {\n        this.groupId = id;\n        this._positionFunction = posFunction;\n    }\n}\n//# sourceMappingURL=cloudPoint.js.map","import { Scalar } from \"core/Maths/math.scalar\";\nconst SH_C0 = 0.28209479177387814;\nasync function LoadWebpImageData(rootUrlOrData, filename, engine) {\n    const promise = new Promise((resolve, reject) => {\n        const image = engine.createCanvasImage();\n        if (!image) {\n            throw new Error(\"Failed to create ImageBitmap\");\n        }\n        image.onload = () => {\n            try {\n                // Draw to canvas\n                const canvas = engine.createCanvas(image.width, image.height);\n                if (!canvas) {\n                    throw new Error(\"Failed to create canvas\");\n                }\n                const ctx = canvas.getContext(\"2d\");\n                if (!ctx) {\n                    throw new Error(\"Failed to get 2D context\");\n                }\n                ctx.drawImage(image, 0, 0);\n                // Extract pixel data (RGBA per pixel)\n                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                resolve({ bits: new Uint8Array(imageData.data.buffer), width: imageData.width });\n            }\n            catch (error) {\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                reject(`Error loading image ${image.src} with exception: ${error}`);\n            }\n        };\n        image.onerror = (error) => {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            reject(`Error loading image ${image.src} with exception: ${error}`);\n        };\n        image.crossOrigin = \"anonymous\"; // To avoid CORS issues\n        let objectUrl;\n        if (typeof rootUrlOrData === \"string\") {\n            // old behavior: URL + filename\n            if (!filename) {\n                throw new Error(\"filename is required when using a URL\");\n            }\n            image.src = rootUrlOrData + filename;\n        }\n        else {\n            // new behavior: Uint8Array\n            const blob = new Blob([rootUrlOrData], { type: \"image/webp\" });\n            objectUrl = URL.createObjectURL(blob);\n            image.src = objectUrl;\n        }\n    });\n    return await promise;\n}\nasync function ParseSogDatas(data, imageDataArrays, scene) {\n    const splatCount = data.count ? data.count : data.means.shape[0];\n    const rowOutputLength = 3 * 4 + 3 * 4 + 4 + 4; // 32\n    const buffer = new ArrayBuffer(rowOutputLength * splatCount);\n    const position = new Float32Array(buffer);\n    const scale = new Float32Array(buffer);\n    const rgba = new Uint8ClampedArray(buffer);\n    const rot = new Uint8ClampedArray(buffer);\n    // Undo the symmetric log transform used at encode time:\n    const unlog = (n) => Math.sign(n) * (Math.exp(Math.abs(n)) - 1);\n    const meansl = imageDataArrays[0].bits;\n    const meansu = imageDataArrays[1].bits;\n    // Check that data.means.mins is an array\n    if (!Array.isArray(data.means.mins) || !Array.isArray(data.means.maxs)) {\n        throw new Error(\"Missing arrays in SOG data.\");\n    }\n    // --- Positions\n    for (let i = 0; i < splatCount; i++) {\n        const index = i * 4;\n        for (let j = 0; j < 3; j++) {\n            const meansMin = data.means.mins[j];\n            const meansMax = data.means.maxs[j];\n            const meansup = meansu[index + j];\n            const meanslow = meansl[index + j];\n            const q = (meansup << 8) | meanslow;\n            const n = Scalar.Lerp(meansMin, meansMax, q / 65535);\n            position[i * 8 + j] = unlog(n);\n        }\n    }\n    // --- Scales\n    const scales = imageDataArrays[2].bits;\n    if (data.version === 2) {\n        if (!data.scales.codebook) {\n            throw new Error(\"Missing codebook in SOG version 2 scales data.\");\n        }\n        for (let i = 0; i < splatCount; i++) {\n            const index = i * 4;\n            for (let j = 0; j < 3; j++) {\n                const sc = data.scales.codebook[scales[index + j]];\n                const sce = Math.exp(sc);\n                scale[i * 8 + 3 + j] = sce;\n            }\n        }\n    }\n    else {\n        if (!Array.isArray(data.scales.mins) || !Array.isArray(data.scales.maxs)) {\n            throw new Error(\"Missing arrays in SOG scales data.\");\n        }\n        for (let i = 0; i < splatCount; i++) {\n            const index = i * 4;\n            for (let j = 0; j < 3; j++) {\n                const sc = scales[index + j];\n                const lsc = Scalar.Lerp(data.scales.mins[j], data.scales.maxs[j], sc / 255);\n                const lsce = Math.exp(lsc);\n                scale[i * 8 + 3 + j] = lsce;\n            }\n        }\n    }\n    // --- Colors/SH0\n    const colors = imageDataArrays[4].bits;\n    if (data.version === 2) {\n        if (!data.sh0.codebook) {\n            throw new Error(\"Missing codebook in SOG version 2 sh0 data.\");\n        }\n        for (let i = 0; i < splatCount; i++) {\n            const index = i * 4;\n            for (let j = 0; j < 3; j++) {\n                const component = 0.5 + data.sh0.codebook[colors[index + j]] * SH_C0;\n                rgba[i * 32 + 24 + j] = Math.max(0, Math.min(255, Math.round(255 * component)));\n            }\n            rgba[i * 32 + 24 + 3] = colors[index + 3];\n        }\n    }\n    else {\n        if (!Array.isArray(data.sh0.mins) || !Array.isArray(data.sh0.maxs)) {\n            throw new Error(\"Missing arrays in SOG sh0 data.\");\n        }\n        for (let i = 0; i < splatCount; i++) {\n            const index = i * 4;\n            for (let j = 0; j < 4; j++) {\n                const colorsMin = data.sh0.mins[j];\n                const colorsMax = data.sh0.maxs[j];\n                const colort = colors[index + j];\n                const c = Scalar.Lerp(colorsMin, colorsMax, colort / 255);\n                let csh;\n                if (j < 3) {\n                    csh = 0.5 + c * SH_C0;\n                }\n                else {\n                    csh = 1.0 / (1.0 + Math.exp(-c));\n                }\n                rgba[i * 32 + 24 + j] = Math.max(0, Math.min(255, Math.round(255 * csh)));\n            }\n        }\n    }\n    // --- Rotations\n    // Dequantize the stored three components:\n    const toComp = (c) => ((c / 255 - 0.5) * 2.0) / Math.SQRT2;\n    const quatArray = imageDataArrays[3].bits;\n    for (let i = 0; i < splatCount; i++) {\n        const quatsr = quatArray[i * 4 + 0];\n        const quatsg = quatArray[i * 4 + 1];\n        const quatsb = quatArray[i * 4 + 2];\n        const quatsa = quatArray[i * 4 + 3];\n        const a = toComp(quatsr);\n        const b = toComp(quatsg);\n        const c = toComp(quatsb);\n        const mode = quatsa - 252; // 0..3 (R,G,B,A is one of the four components)\n        // Reconstruct the omitted component so that ||q|| = 1 and w.l.o.g. the omitted one is non-negative\n        const t = a * a + b * b + c * c;\n        const d = Math.sqrt(Math.max(0, 1 - t));\n        // Place components according to mode\n        let q;\n        switch (mode) {\n            case 0:\n                q = [d, a, b, c];\n                break; // omitted = x\n            case 1:\n                q = [a, d, b, c];\n                break; // omitted = y\n            case 2:\n                q = [a, b, d, c];\n                break; // omitted = z\n            case 3:\n                q = [a, b, c, d];\n                break; // omitted = w\n            default:\n                throw new Error(\"Invalid quaternion mode\");\n        }\n        rot[i * 32 + 28 + 0] = q[0] * 127.5 + 127.5;\n        rot[i * 32 + 28 + 1] = q[1] * 127.5 + 127.5;\n        rot[i * 32 + 28 + 2] = q[2] * 127.5 + 127.5;\n        rot[i * 32 + 28 + 3] = q[3] * 127.5 + 127.5;\n    }\n    // --- SH\n    if (data.shN) {\n        const coeffCounts = [0, 3, 8, 15];\n        const coeffs = data.shN.bands ? coeffCounts[data.shN.bands] : data.shN.shape[1] / 3; // 3 components per coeff\n        const shCentroids = imageDataArrays[5].bits;\n        const shLabelsData = imageDataArrays[6].bits;\n        const shCentroidsWidth = imageDataArrays[5].width;\n        const shComponentCount = coeffs * 3;\n        const textureCount = Math.ceil(shComponentCount / 16); // 4 components can be stored per texture, 4 sh per component\n        //let shIndexRead = byteOffset;\n        // sh is an array of uint8array that will be used to create sh textures\n        const sh = [];\n        const engine = scene.getEngine();\n        const width = engine.getCaps().maxTextureSize;\n        const height = Math.ceil(splatCount / width);\n        // create array for the number of textures needed.\n        for (let textureIndex = 0; textureIndex < textureCount; textureIndex++) {\n            const texture = new Uint8Array(height * width * 4 * 4); // 4 components per texture, 4 sh per component\n            sh.push(texture);\n        }\n        if (data.version === 2) {\n            if (!data.shN.codebook) {\n                throw new Error(\"Missing codebook in SOG version 2 shN data.\");\n            }\n            for (let i = 0; i < splatCount; i++) {\n                const n = shLabelsData[i * 4 + 0] + (shLabelsData[i * 4 + 1] << 8);\n                const u = (n % 64) * coeffs;\n                const v = Math.floor(n / 64);\n                for (let k = 0; k < coeffs; k++) {\n                    for (let j = 0; j < 3; j++) {\n                        const shIndexWrite = k * 3 + j;\n                        const textureIndex = Math.floor(shIndexWrite / 16);\n                        const shArray = sh[textureIndex];\n                        const byteIndexInTexture = shIndexWrite % 16; // [0..15]\n                        const offsetPerSplat = i * 16; // 16 sh values per texture per splat.\n                        const shValue = data.shN.codebook[shCentroids[(u + k) * 4 + j + v * shCentroidsWidth * 4]] * 127.5 + 127.5;\n                        shArray[byteIndexInTexture + offsetPerSplat] = Math.max(0, Math.min(255, shValue));\n                    }\n                }\n            }\n        }\n        else {\n            for (let i = 0; i < splatCount; i++) {\n                const n = shLabelsData[i * 4 + 0] + (shLabelsData[i * 4 + 1] << 8);\n                const u = (n % 64) * coeffs;\n                const v = Math.floor(n / 64);\n                const shMin = data.shN.mins;\n                const shMax = data.shN.maxs;\n                for (let j = 0; j < 3; j++) {\n                    for (let k = 0; k < coeffs / 3; k++) {\n                        const shIndexWrite = k * 3 + j;\n                        const textureIndex = Math.floor(shIndexWrite / 16);\n                        const shArray = sh[textureIndex];\n                        const byteIndexInTexture = shIndexWrite % 16; // [0..15]\n                        const offsetPerSplat = i * 16; // 16 sh values per texture per splat.\n                        const shValue = Scalar.Lerp(shMin, shMax, shCentroids[(u + k) * 4 + j + v * shCentroidsWidth * 4] / 255) * 127.5 + 127.5;\n                        shArray[byteIndexInTexture + offsetPerSplat] = Math.max(0, Math.min(255, shValue));\n                    }\n                }\n            }\n        }\n        return await new Promise((resolve) => {\n            resolve({ mode: 0 /* Mode.Splat */, data: buffer, hasVertexColors: false, sh: sh });\n        });\n    }\n    return await new Promise((resolve) => {\n        resolve({ mode: 0 /* Mode.Splat */, data: buffer, hasVertexColors: false });\n    });\n}\n/**\n * Parse SOG data from either a SOGRootData object (with webp files loaded from rootUrl) or from a Map of filenames to Uint8Array file data (including meta.json)\n * @param dataOrFiles Either the SOGRootData or a Map of filenames to Uint8Array file data (including meta.json)\n * @param rootUrl Base URL to load webp files from (if dataOrFiles is SOGRootData)\n * @param scene The Babylon.js scene\n * @returns Parsed data\n */\nexport async function ParseSogMeta(dataOrFiles, rootUrl, scene) {\n    let data;\n    let files;\n    if (dataOrFiles instanceof Map) {\n        files = dataOrFiles;\n        const metaFile = files.get(\"meta.json\");\n        if (!metaFile) {\n            throw new Error(\"meta.json not found in files Map\");\n        }\n        data = JSON.parse(new TextDecoder().decode(metaFile));\n    }\n    else {\n        data = dataOrFiles;\n    }\n    // Collect all file names\n    const urls = [...data.means.files, ...data.scales.files, ...data.quats.files, ...data.sh0.files];\n    if (data.shN) {\n        urls.push(...data.shN.files);\n    }\n    // Load webp images in parallel\n    const imageDataArrays = await Promise.all(urls.map(async (fileName) => {\n        if (files && files.has(fileName)) {\n            // load from in-memory Uint8Array\n            const fileData = files.get(fileName);\n            return await LoadWebpImageData(fileData, fileName, scene.getEngine());\n        }\n        else {\n            // fallback: load from URL\n            return await LoadWebpImageData(rootUrl, fileName, scene.getEngine());\n        }\n    }));\n    return await ParseSogDatas(data, imageDataArrays, scene);\n}\n//# sourceMappingURL=sog.js.map","import { RegisterSceneLoaderPlugin } from \"core/Loading/sceneLoader\";\nimport { SPLATFileLoaderMetadata } from \"./splatFileLoader.metadata\";\nimport { GaussianSplattingMesh } from \"core/Meshes/GaussianSplatting/gaussianSplattingMesh\";\nimport { AssetContainer } from \"core/assetContainer\";\nimport { Mesh } from \"core/Meshes/mesh\";\nimport { Logger } from \"core/Misc/logger\";\nimport { Vector3 } from \"core/Maths/math.vector\";\nimport { PointsCloudSystem } from \"core/Particles/pointsCloudSystem\";\nimport { Color4 } from \"core/Maths/math.color\";\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\nimport { ParseSpz } from \"./spz\";\nimport { ParseSogMeta } from \"./sog\";\nimport { Tools } from \"core/Misc/tools\";\n/**\n * @experimental\n * SPLAT file type loader.\n * This is a babylon scene loader plugin.\n */\nexport class SPLATFileLoader {\n    /**\n     * Creates loader for gaussian splatting files\n     * @param loadingOptions options for loading and parsing splat and PLY files.\n     */\n    constructor(loadingOptions = SPLATFileLoader._DefaultLoadingOptions) {\n        /**\n         * Defines the name of the plugin.\n         */\n        this.name = SPLATFileLoaderMetadata.name;\n        this._assetContainer = null;\n        /**\n         * Defines the extensions the splat loader is able to load.\n         * force data to come in as an ArrayBuffer\n         */\n        this.extensions = SPLATFileLoaderMetadata.extensions;\n        this._loadingOptions = loadingOptions;\n    }\n    /** @internal */\n    createPlugin(options) {\n        return new SPLATFileLoader(options[SPLATFileLoaderMetadata.name]);\n    }\n    /**\n     * Imports  from the loaded gaussian splatting data and adds them to the scene\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\n     * @param scene the scene the meshes should be added to\n     * @param data the gaussian splatting data to load\n     * @param rootUrl root url to load from\n     * @param _onProgress callback called while file is loading\n     * @param _fileName Defines the name of the file to load\n     * @returns a promise containing the loaded meshes, particles, skeletons and animations\n     */\n    async importMeshAsync(meshesNames, scene, data, rootUrl, _onProgress, _fileName) {\n        // eslint-disable-next-line github/no-then\n        return await this._parseAsync(meshesNames, scene, data, rootUrl).then((meshes) => {\n            return {\n                meshes: meshes,\n                particleSystems: [],\n                skeletons: [],\n                animationGroups: [],\n                transformNodes: [],\n                geometries: [],\n                lights: [],\n                spriteManagers: [],\n            };\n        });\n    }\n    static _BuildPointCloud(pointcloud, data) {\n        if (!data.byteLength) {\n            return false;\n        }\n        const uBuffer = new Uint8Array(data);\n        const fBuffer = new Float32Array(data);\n        // parsed array contains room for position(3floats), normal(3floats), color (4b), quantized quaternion (4b)\n        const rowLength = 3 * 4 + 3 * 4 + 4 + 4;\n        const vertexCount = uBuffer.length / rowLength;\n        const pointcloudfunc = function (particle, i) {\n            const x = fBuffer[8 * i + 0];\n            const y = fBuffer[8 * i + 1];\n            const z = fBuffer[8 * i + 2];\n            particle.position = new Vector3(x, y, z);\n            const r = uBuffer[rowLength * i + 24 + 0] / 255;\n            const g = uBuffer[rowLength * i + 24 + 1] / 255;\n            const b = uBuffer[rowLength * i + 24 + 2] / 255;\n            particle.color = new Color4(r, g, b, 1);\n        };\n        pointcloud.addPoints(vertexCount, pointcloudfunc);\n        return true;\n    }\n    static _BuildMesh(scene, parsedPLY) {\n        const mesh = new Mesh(\"PLYMesh\", scene);\n        const uBuffer = new Uint8Array(parsedPLY.data);\n        const fBuffer = new Float32Array(parsedPLY.data);\n        const rowLength = 3 * 4 + 3 * 4 + 4 + 4;\n        const vertexCount = uBuffer.length / rowLength;\n        const positions = [];\n        const vertexData = new VertexData();\n        for (let i = 0; i < vertexCount; i++) {\n            const x = fBuffer[8 * i + 0];\n            const y = fBuffer[8 * i + 1];\n            const z = fBuffer[8 * i + 2];\n            positions.push(x, y, z);\n        }\n        if (parsedPLY.hasVertexColors) {\n            const colors = new Float32Array(vertexCount * 4);\n            for (let i = 0; i < vertexCount; i++) {\n                const r = uBuffer[rowLength * i + 24 + 0] / 255;\n                const g = uBuffer[rowLength * i + 24 + 1] / 255;\n                const b = uBuffer[rowLength * i + 24 + 2] / 255;\n                colors[i * 4 + 0] = r;\n                colors[i * 4 + 1] = g;\n                colors[i * 4 + 2] = b;\n                colors[i * 4 + 3] = 1;\n            }\n            vertexData.colors = colors;\n        }\n        vertexData.positions = positions;\n        vertexData.indices = parsedPLY.faces;\n        vertexData.applyToMesh(mesh);\n        return mesh;\n    }\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax, @typescript-eslint/naming-convention\n    async _unzipWithFFlateAsync(data) {\n        // ensure fflate is loaded\n        if (typeof window.fflate === \"undefined\") {\n            await Tools.LoadScriptAsync(this._loadingOptions.deflateURL ?? \"https://unpkg.com/fflate/umd/index.js\");\n        }\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        const { unzipSync } = window.fflate;\n        const unzipped = unzipSync(data); // { [filename: string]: Uint8Array }\n        const files = new Map();\n        for (const [name, content] of Object.entries(unzipped)) {\n            files.set(name, content);\n        }\n        return files;\n    }\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    _parseAsync(meshesNames, scene, data, rootUrl) {\n        const babylonMeshesArray = []; //The mesh for babylon\n        const makeGSFromParsedSOG = (parsedSOG) => {\n            scene._blockEntityCollection = !!this._assetContainer;\n            const gaussianSplatting = new GaussianSplattingMesh(\"GaussianSplatting\", null, scene, this._loadingOptions.keepInRam);\n            gaussianSplatting._parentContainer = this._assetContainer;\n            gaussianSplatting.viewDirectionFactor.set(1, -1, 1);\n            babylonMeshesArray.push(gaussianSplatting);\n            gaussianSplatting.updateData(parsedSOG.data, parsedSOG.sh);\n            scene._blockEntityCollection = false;\n        };\n        // check if data is json string\n        if (typeof data === \"string\") {\n            const dataSOG = JSON.parse(data);\n            if (dataSOG && dataSOG.means && dataSOG.scales && dataSOG.quats && dataSOG.sh0) {\n                return new Promise((resolve) => {\n                    ParseSogMeta(dataSOG, rootUrl, scene)\n                        // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n                        .then((parsedSOG) => {\n                        makeGSFromParsedSOG(parsedSOG);\n                        resolve(babylonMeshesArray);\n                    })\n                        // eslint-disable-next-line github/no-then\n                        .catch(() => {\n                        throw new Error(\"Failed to parse SOG data.\");\n                    });\n                });\n            }\n        }\n        const u8 = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\n        // ZIP signature check for SOG\n        if (u8[0] === 0x50 && u8[1] === 0x4b) {\n            return new Promise((resolve) => {\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n                this._unzipWithFFlateAsync(u8).then((files) => {\n                    ParseSogMeta(files, rootUrl, scene)\n                        // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n                        .then((parsedSOG) => {\n                        makeGSFromParsedSOG(parsedSOG);\n                        resolve(babylonMeshesArray);\n                    }) // eslint-disable-next-line github/no-then\n                        .catch(() => {\n                        throw new Error(\"Failed to parse SOG zip data.\");\n                    });\n                });\n            });\n        }\n        const readableStream = new ReadableStream({\n            start(controller) {\n                controller.enqueue(new Uint8Array(data)); // Enqueue the ArrayBuffer as a Uint8Array\n                controller.close();\n            },\n        });\n        // Use GZip DecompressionStream\n        const decompressionStream = new DecompressionStream(\"gzip\");\n        const decompressedStream = readableStream.pipeThrough(decompressionStream);\n        return new Promise((resolve) => {\n            new Response(decompressedStream)\n                .arrayBuffer()\n                // eslint-disable-next-line github/no-then\n                .then((buffer) => {\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n                ParseSpz(buffer, scene, this._loadingOptions).then((parsedSPZ) => {\n                    scene._blockEntityCollection = !!this._assetContainer;\n                    const gaussianSplatting = new GaussianSplattingMesh(\"GaussianSplatting\", null, scene, this._loadingOptions.keepInRam);\n                    if (parsedSPZ.trainedWithAntialiasing) {\n                        const gsMaterial = gaussianSplatting.material;\n                        gsMaterial.kernelSize = 0.1;\n                        gsMaterial.compensation = true;\n                    }\n                    gaussianSplatting._parentContainer = this._assetContainer;\n                    babylonMeshesArray.push(gaussianSplatting);\n                    gaussianSplatting.updateData(parsedSPZ.data, parsedSPZ.sh);\n                    scene._blockEntityCollection = false;\n                    resolve(babylonMeshesArray);\n                });\n            })\n                // eslint-disable-next-line github/no-then\n                .catch(() => {\n                // Catch any decompression errors\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n                SPLATFileLoader._ConvertPLYToSplat(data).then(async (parsedPLY) => {\n                    scene._blockEntityCollection = !!this._assetContainer;\n                    switch (parsedPLY.mode) {\n                        case 0 /* Mode.Splat */:\n                            {\n                                const gaussianSplatting = new GaussianSplattingMesh(\"GaussianSplatting\", null, scene, this._loadingOptions.keepInRam);\n                                gaussianSplatting._parentContainer = this._assetContainer;\n                                babylonMeshesArray.push(gaussianSplatting);\n                                gaussianSplatting.updateData(parsedPLY.data, parsedPLY.sh);\n                                if (parsedPLY.compressed || !parsedPLY.rawSplat) {\n                                    gaussianSplatting.viewDirectionFactor.set(-1, -1, 1);\n                                }\n                            }\n                            break;\n                        case 1 /* Mode.PointCloud */:\n                            {\n                                const pointcloud = new PointsCloudSystem(\"PointCloud\", 1, scene);\n                                if (SPLATFileLoader._BuildPointCloud(pointcloud, parsedPLY.data)) {\n                                    // eslint-disable-next-line github/no-then\n                                    await pointcloud.buildMeshAsync().then((mesh) => {\n                                        babylonMeshesArray.push(mesh);\n                                    });\n                                }\n                                else {\n                                    pointcloud.dispose();\n                                }\n                            }\n                            break;\n                        case 2 /* Mode.Mesh */:\n                            {\n                                if (parsedPLY.faces) {\n                                    babylonMeshesArray.push(SPLATFileLoader._BuildMesh(scene, parsedPLY));\n                                }\n                                else {\n                                    throw new Error(\"PLY mesh doesn't contain face informations.\");\n                                }\n                            }\n                            break;\n                        default:\n                            throw new Error(\"Unsupported Splat mode\");\n                    }\n                    scene._blockEntityCollection = false;\n                    resolve(babylonMeshesArray);\n                });\n            });\n        });\n    }\n    /**\n     * Load into an asset container.\n     * @param scene The scene to load into\n     * @param data The data to import\n     * @param rootUrl The root url for scene and resources\n     * @returns The loaded asset container\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadAssetContainerAsync(scene, data, rootUrl) {\n        const container = new AssetContainer(scene);\n        this._assetContainer = container;\n        return (this.importMeshAsync(null, scene, data, rootUrl)\n            // eslint-disable-next-line github/no-then\n            .then((result) => {\n            for (const mesh of result.meshes) {\n                container.meshes.push(mesh);\n            }\n            // mesh material will be null before 1st rendered frame.\n            this._assetContainer = null;\n            return container;\n        })\n            // eslint-disable-next-line github/no-then\n            .catch((ex) => {\n            this._assetContainer = null;\n            throw ex;\n        }));\n    }\n    /**\n     * Imports all objects from the loaded OBJ data and adds them to the scene\n     * @param scene the scene the objects should be added to\n     * @param data the OBJ data to load\n     * @param rootUrl root url to load from\n     * @returns a promise which completes when objects have been loaded to the scene\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    loadAsync(scene, data, rootUrl) {\n        //Get the 3D model\n        // eslint-disable-next-line github/no-then\n        return this.importMeshAsync(null, scene, data, rootUrl).then(() => {\n            // return void\n        });\n    }\n    /**\n     * Code from https://github.com/dylanebert/gsplat.js/blob/main/src/loaders/PLYLoader.ts Under MIT license\n     * Converts a .ply data array buffer to splat\n     * if data array buffer is not ply, returns the original buffer\n     * @param data the .ply data to load\n     * @returns the loaded splat buffer\n     */\n    static _ConvertPLYToSplat(data) {\n        const ubuf = new Uint8Array(data);\n        const header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));\n        const headerEnd = \"end_header\\n\";\n        const headerEndIndex = header.indexOf(headerEnd);\n        if (headerEndIndex < 0 || !header) {\n            // standard splat\n            return new Promise((resolve) => {\n                resolve({ mode: 0 /* Mode.Splat */, data: data, rawSplat: true });\n            });\n        }\n        const vertexCount = parseInt(/element vertex (\\d+)\\n/.exec(header)[1]);\n        const faceElement = /element face (\\d+)\\n/.exec(header);\n        let faceCount = 0;\n        if (faceElement) {\n            faceCount = parseInt(faceElement[1]);\n        }\n        const chunkElement = /element chunk (\\d+)\\n/.exec(header);\n        let chunkCount = 0;\n        if (chunkElement) {\n            chunkCount = parseInt(chunkElement[1]);\n        }\n        let rowVertexOffset = 0;\n        let rowChunkOffset = 0;\n        const offsets = {\n            double: 8,\n            int: 4,\n            uint: 4,\n            float: 4,\n            short: 2,\n            ushort: 2,\n            uchar: 1,\n            list: 0,\n        };\n        let ElementMode;\n        (function (ElementMode) {\n            ElementMode[ElementMode[\"Vertex\"] = 0] = \"Vertex\";\n            ElementMode[ElementMode[\"Chunk\"] = 1] = \"Chunk\";\n            ElementMode[ElementMode[\"SH\"] = 2] = \"SH\";\n        })(ElementMode || (ElementMode = {}));\n        let chunkMode = 1 /* ElementMode.Chunk */;\n        const vertexProperties = [];\n        const chunkProperties = [];\n        const filtered = header.slice(0, headerEndIndex).split(\"\\n\");\n        for (const prop of filtered) {\n            if (prop.startsWith(\"property \")) {\n                const [, type, name] = prop.split(\" \");\n                if (chunkMode == 1 /* ElementMode.Chunk */) {\n                    chunkProperties.push({ name, type, offset: rowChunkOffset });\n                    rowChunkOffset += offsets[type];\n                }\n                else if (chunkMode == 0 /* ElementMode.Vertex */) {\n                    vertexProperties.push({ name, type, offset: rowVertexOffset });\n                    rowVertexOffset += offsets[type];\n                }\n                else if (chunkMode == 2 /* ElementMode.SH */) {\n                    vertexProperties.push({ name, type, offset: rowVertexOffset });\n                }\n                if (!offsets[type]) {\n                    Logger.Warn(`Unsupported property type: ${type}.`);\n                }\n            }\n            else if (prop.startsWith(\"element \")) {\n                const [, type] = prop.split(\" \");\n                if (type == \"chunk\") {\n                    chunkMode = 1 /* ElementMode.Chunk */;\n                }\n                else if (type == \"vertex\") {\n                    chunkMode = 0 /* ElementMode.Vertex */;\n                }\n                else if (type == \"sh\") {\n                    chunkMode = 2 /* ElementMode.SH */;\n                }\n            }\n        }\n        const rowVertexLength = rowVertexOffset;\n        const rowChunkLength = rowChunkOffset;\n        // eslint-disable-next-line github/no-then\n        return GaussianSplattingMesh.ConvertPLYWithSHToSplatAsync(data).then(async (splatsData) => {\n            const dataView = new DataView(data, headerEndIndex + headerEnd.length);\n            let offset = rowChunkLength * chunkCount + rowVertexLength * vertexCount;\n            // faces\n            const faces = [];\n            if (faceCount) {\n                for (let i = 0; i < faceCount; i++) {\n                    const faceVertexCount = dataView.getUint8(offset);\n                    if (faceVertexCount != 3) {\n                        continue; // only support triangles\n                    }\n                    offset += 1;\n                    for (let j = 0; j < faceVertexCount; j++) {\n                        const vertexIndex = dataView.getUint32(offset + (2 - j) * 4, true); // change face winding\n                        faces.push(vertexIndex);\n                    }\n                    offset += 12;\n                }\n            }\n            // early exit for chunked/quantized ply\n            if (chunkCount) {\n                return await new Promise((resolve) => {\n                    resolve({ mode: 0 /* Mode.Splat */, data: splatsData.buffer, sh: splatsData.sh, faces: faces, hasVertexColors: false, compressed: true, rawSplat: false });\n                });\n            }\n            // count available properties. if all necessary are present then it's a splat. Otherwise, it's a point cloud\n            // if faces are found, then it's a standard mesh\n            let propertyCount = 0;\n            let propertyColorCount = 0;\n            const splatProperties = [\"x\", \"y\", \"z\", \"scale_0\", \"scale_1\", \"scale_2\", \"opacity\", \"rot_0\", \"rot_1\", \"rot_2\", \"rot_3\"];\n            const splatColorProperties = [\"red\", \"green\", \"blue\", \"f_dc_0\", \"f_dc_1\", \"f_dc_2\"];\n            for (let propertyIndex = 0; propertyIndex < vertexProperties.length; propertyIndex++) {\n                const property = vertexProperties[propertyIndex];\n                if (splatProperties.includes(property.name)) {\n                    propertyCount++;\n                }\n                if (splatColorProperties.includes(property.name)) {\n                    propertyColorCount++;\n                }\n            }\n            const hasMandatoryProperties = propertyCount == splatProperties.length && propertyColorCount == 3;\n            const currentMode = faceCount ? 2 /* Mode.Mesh */ : hasMandatoryProperties ? 0 /* Mode.Splat */ : 1 /* Mode.PointCloud */;\n            // parsed ready ready to be used as a splat\n            return await new Promise((resolve) => {\n                resolve({ mode: currentMode, data: splatsData.buffer, sh: splatsData.sh, faces: faces, hasVertexColors: !!propertyColorCount, compressed: false, rawSplat: false });\n            });\n        });\n    }\n}\nSPLATFileLoader._DefaultLoadingOptions = {\n    keepInRam: false,\n    flipY: false,\n};\n// Add this loader into the register plugin\nRegisterSceneLoaderPlugin(new SPLATFileLoader());\n//# sourceMappingURL=splatFileLoader.js.map","/* eslint-disable @typescript-eslint/promise-function-async */\nimport { Scalar } from \"core/Maths/math.scalar\";\n/**\n * Parses SPZ data and returns a promise resolving to an IParsedPLY object.\n * @param data The ArrayBuffer containing SPZ data.\n * @param scene The Babylon.js scene.\n * @param loadingOptions Options for loading Gaussian Splatting files.\n * @returns A promise resolving to the parsed SPZ data.\n */\nexport function ParseSpz(data, scene, loadingOptions) {\n    const ubuf = new Uint8Array(data);\n    const ubufu32 = new Uint32Array(data.slice(0, 12)); // Only need ubufu32[0] to [2]\n    // debug infos\n    const splatCount = ubufu32[2];\n    const shDegree = ubuf[12];\n    const fractionalBits = ubuf[13];\n    const flags = ubuf[14];\n    const reserved = ubuf[15];\n    const version = ubufu32[1];\n    // check magic and version\n    if (reserved || ubufu32[0] != 0x5053474e || (version != 2 && version != 3)) {\n        // reserved must be 0\n        return new Promise((resolve) => {\n            resolve({ mode: 3 /* Mode.Reject */, data: buffer, hasVertexColors: false });\n        });\n    }\n    const rowOutputLength = 3 * 4 + 3 * 4 + 4 + 4; // 32\n    const buffer = new ArrayBuffer(rowOutputLength * splatCount);\n    const positionScale = 1.0 / (1 << fractionalBits);\n    const int32View = new Int32Array(1);\n    const uint8View = new Uint8Array(int32View.buffer);\n    const read24bComponent = function (u8, offset) {\n        uint8View[0] = u8[offset + 0];\n        uint8View[1] = u8[offset + 1];\n        uint8View[2] = u8[offset + 2];\n        uint8View[3] = u8[offset + 2] & 0x80 ? 0xff : 0x00;\n        return int32View[0] * positionScale;\n    };\n    let byteOffset = 16;\n    const position = new Float32Array(buffer);\n    const scale = new Float32Array(buffer);\n    const rgba = new Uint8ClampedArray(buffer);\n    const rot = new Uint8ClampedArray(buffer);\n    let coordinateSign = 1;\n    let quaternionOffset = 0;\n    if (!loadingOptions.flipY) {\n        coordinateSign = -1;\n        quaternionOffset = 255;\n    }\n    // positions\n    for (let i = 0; i < splatCount; i++) {\n        position[i * 8 + 0] = read24bComponent(ubuf, byteOffset + 0);\n        position[i * 8 + 1] = coordinateSign * read24bComponent(ubuf, byteOffset + 3);\n        position[i * 8 + 2] = coordinateSign * read24bComponent(ubuf, byteOffset + 6);\n        byteOffset += 9;\n    }\n    // colors\n    const shC0 = 0.282;\n    for (let i = 0; i < splatCount; i++) {\n        for (let component = 0; component < 3; component++) {\n            const byteValue = ubuf[byteOffset + splatCount + i * 3 + component];\n            // 0.15 is hard coded value from spz\n            // Scale factor for DC color components. To convert to RGB, we should multiply by 0.282, but it can\n            // be useful to represent base colors that are out of range if the higher spherical harmonics bands\n            // bring them back into range so we multiply by a smaller value.\n            const value = (byteValue - 127.5) / (0.15 * 255);\n            rgba[i * 32 + 24 + component] = Scalar.Clamp((0.5 + shC0 * value) * 255, 0, 255);\n        }\n        rgba[i * 32 + 24 + 3] = ubuf[byteOffset + i];\n    }\n    byteOffset += splatCount * 4;\n    // scales\n    for (let i = 0; i < splatCount; i++) {\n        scale[i * 8 + 3 + 0] = Math.exp(ubuf[byteOffset + 0] / 16.0 - 10.0);\n        scale[i * 8 + 3 + 1] = Math.exp(ubuf[byteOffset + 1] / 16.0 - 10.0);\n        scale[i * 8 + 3 + 2] = Math.exp(ubuf[byteOffset + 2] / 16.0 - 10.0);\n        byteOffset += 3;\n    }\n    // convert quaternion\n    if (version >= 3) {\n        /*\n            In version 3, rotations are represented as the smallest three components of the normalized rotation quaternion, for optimal rotation accuracy.\n            The largest component can be derived from the others and is not stored. Its index is stored on 2 bits\n            and each of the smallest three components is encoded as a 10-bit signed integer.\n        */\n        const sqrt12 = Math.SQRT1_2;\n        for (let i = 0; i < splatCount; i++) {\n            const r = [ubuf[byteOffset + 0], ubuf[byteOffset + 1], ubuf[byteOffset + 2], ubuf[byteOffset + 3]];\n            const comp = r[0] + (r[1] << 8) + (r[2] << 16) + (r[3] << 24);\n            const cmask = (1 << 9) - 1;\n            const rotation = [];\n            const iLargest = comp >>> 30;\n            let remaining = comp;\n            let sumSquares = 0;\n            for (let i = 3; i >= 0; --i) {\n                if (i !== iLargest) {\n                    const mag = remaining & cmask;\n                    const negbit = (remaining >>> 9) & 0x1;\n                    remaining = remaining >>> 10;\n                    rotation[i] = sqrt12 * (mag / cmask);\n                    if (negbit === 1) {\n                        rotation[i] = -rotation[i];\n                    }\n                    // accumulate the sum of squares\n                    sumSquares += rotation[i] * rotation[i];\n                }\n            }\n            const square = 1 - sumSquares;\n            rotation[iLargest] = Math.sqrt(Math.max(square, 0));\n            rotation[1] *= coordinateSign;\n            rotation[2] *= coordinateSign;\n            const shuffle = [3, 0, 1, 2]; // shuffle to match the order of the quaternion components in the splat file\n            for (let j = 0; j < 4; j++) {\n                rot[i * 32 + 28 + j] = Math.round(127.5 + rotation[shuffle[j]] * 127.5);\n            }\n            byteOffset += 4;\n        }\n    }\n    else {\n        /*\n            In version 2, rotations are represented as the `(x, y, z)` components of the normalized rotation quaternion. The\n            `w` component can be derived from the others and is not stored. Each component is encoded as an\n            8-bit signed integer.\n        */\n        for (let i = 0; i < splatCount; i++) {\n            const x = ubuf[byteOffset + 0];\n            const y = ubuf[byteOffset + 1] * coordinateSign + quaternionOffset;\n            const z = ubuf[byteOffset + 2] * coordinateSign + quaternionOffset;\n            const nx = x / 127.5 - 1;\n            const ny = y / 127.5 - 1;\n            const nz = z / 127.5 - 1;\n            rot[i * 32 + 28 + 1] = x;\n            rot[i * 32 + 28 + 2] = y;\n            rot[i * 32 + 28 + 3] = z;\n            const v = 1 - (nx * nx + ny * ny + nz * nz);\n            rot[i * 32 + 28 + 0] = 127.5 + Math.sqrt(v < 0 ? 0 : v) * 127.5;\n            byteOffset += 3;\n        }\n    }\n    //SH\n    if (shDegree) {\n        // shVectorCount is : 3 for dim = 1, 8 for dim = 2 and 15 for dim = 3\n        // number of vec3 vector needed per splat\n        const shVectorCount = (shDegree + 1) * (shDegree + 1) - 1; // minus 1 because sh0 is color\n        // number of component values : 3 per vector3 (45)\n        const shComponentCount = shVectorCount * 3;\n        const textureCount = Math.ceil(shComponentCount / 16); // 4 components can be stored per texture, 4 sh per component\n        let shIndexRead = byteOffset;\n        // sh is an array of uint8array that will be used to create sh textures\n        const sh = [];\n        const engine = scene.getEngine();\n        const width = engine.getCaps().maxTextureSize;\n        const height = Math.ceil(splatCount / width);\n        // create array for the number of textures needed.\n        for (let textureIndex = 0; textureIndex < textureCount; textureIndex++) {\n            const texture = new Uint8Array(height * width * 4 * 4); // 4 components per texture, 4 sh per component\n            sh.push(texture);\n        }\n        for (let i = 0; i < splatCount; i++) {\n            for (let shIndexWrite = 0; shIndexWrite < shComponentCount; shIndexWrite++) {\n                const shValue = ubuf[shIndexRead++];\n                const textureIndex = Math.floor(shIndexWrite / 16);\n                const shArray = sh[textureIndex];\n                const byteIndexInTexture = shIndexWrite % 16; // [0..15]\n                const offsetPerSplat = i * 16; // 16 sh values per texture per splat.\n                shArray[byteIndexInTexture + offsetPerSplat] = shValue;\n            }\n        }\n        return new Promise((resolve) => {\n            resolve({ mode: 0 /* Mode.Splat */, data: buffer, hasVertexColors: false, sh: sh, trainedWithAntialiasing: !!flags });\n        });\n    }\n    return new Promise((resolve) => {\n        resolve({ mode: 0 /* Mode.Splat */, data: buffer, hasVertexColors: false, trainedWithAntialiasing: !!flags });\n    });\n}\n//# sourceMappingURL=spz.js.map"],"names":["name","ShaderStore","IncludesShadersStore","shader","ShadersStore","gaussianSplattingPixelShader","gaussianSplattingVertexShader","IncludesShadersStoreWGSL","ShadersStoreWGSL","gaussianSplattingPixelShaderWGSL","gaussianSplattingVertexShaderWGSL","GaussianSplattingMaterialDefines","MaterialDefines","constructor","super","this","FOG","THIN_INSTANCES","LOGARITHMICDEPTH","CLIPPLANE","CLIPPLANE2","CLIPPLANE3","CLIPPLANE4","CLIPPLANE5","CLIPPLANE6","SH_DEGREE","COMPENSATION","rebuild","GaussianSplattingMaterial","PushMaterial","scene","kernelSize","KernelSize","_compensation","Compensation","_isDirty","backFaceCulling","compensation","value","hasRenderTargetTextures","needAlphaTesting","needAlphaBlending","isReadyForSubMesh","mesh","subMesh","useInstances","drawWrapper","_drawWrapper","defines","materialDefines","markAsUnprocessed","effect","isFrozen","_wasPreviouslyReady","_wasPreviouslyUsingInstances","getScene","_isReadyForSubMesh","engine","getEngine","gsMesh","PrepareDefinesForMisc","_useLogarithmicDepth","pointsCloud","fogEnabled","undefined","_setVertexOutputInvariant","PrepareDefinesForFrameBoundValues","PrepareDefinesForAttributes","version","isWebGPU","shDegree","splatMaterial","material","isDirty","markAsProcessed","resetCachedMaterial","attribs","VertexBuffer","PositionKind","PrepareAttributesForInstances","uniforms","samplers","uniformBuffers","PrepareUniformsAndSamplersList","uniformsNames","uniformBuffersNames","AddClipPlaneUniforms","join","toString","createEffect","attributes","onCompiled","onError","indexParameters","shaderLanguage","_shaderLanguage","extraInitializationsAsync","async","Promise","all","resolve","then","gaussianSplatting_fragment","gaussianSplatting_vertex","gaussianSplatting_fragment$1","gaussianSplatting_vertex$1","setEffect","_materialContext","isReady","_renderId","getRenderId","BindEffect","camera","activeCamera","renderWidth","getRenderWidth","renderHeight","getRenderHeight","gsMaterial","numberOfRigs","rigParent","rigCameras","length","setFloat2","focal","t","getProjectionMatrix","m","fovMode","Camera","FOVMODE_VERTICAL_FIXED","setVector3","viewDirectionFactor","setFloat","bindEyePosition","covariancesATexture","textureSize","getSize","width","height","setTexture","covariancesBTexture","centersTexture","colorsTexture","shTextures","i","bindForSubMesh","world","_activeEffect","getMeshUniformBuffer","bindToEffect","transferToEffect","_mustRebind","visibility","bindView","bindViewProjection","BindClipPlane","_features","needToAlwaysBindUniformBuffers","_needToBindSceneUbo","BindFogParameters","useLogarithmicDepth","BindLogDepth","_afterBind","clone","SerializationHelper","Clone","serialize","serializationObject","customType","getClassName","Parse","source","rootUrl","RegisterClass","HCF","functions.HighestCommonFactor","Scalar","functions","TwoPi","Math","PI","Sign","sign","Log2","log2","UnpackUnorm","bits","Unpack111011","result","x","y","z","Unpack8888","UnpackRot","norm","sqrt","a","b","c","set","PLYType","PLYValue","PointColor","GaussianSplattingMesh","Mesh","_viewDirectionFactor","_shDegree","splatCount","_splatIndex","splatsData","_splatsData","_covariancesATexture","_covariancesBTexture","_centersTexture","_colorsTexture","_shTextures","_material","cullBackFaces","resetDrawCache","url","keepInRam","_vertexCount","_worker","_frameIdLastUpdate","_modelViewMatrix","Matrix","Identity","_canPostToWorker","_readyToDisplay","_splatPositions","_sh","_keepInRam","_delayedTextureUpdate","_oldDirection","Vector3","_useRGBACovariants","_tmpCovariances","_sortIsDirty","vertexData","VertexData","positions","indices","applyToMesh","subMeshes","SubMesh","setEnabled","loadFileAsync","_scene","getTotalVertices","completeCheck","_postToWorker","forced","frameId","getFrameId","cameraMatrix","getViewMatrix","getWorldMatrix","multiplyToRef","invertToRef","TmpVectors","TransformNormalToRef","Forward","useRightHandedSystem","normalize","dot","Dot","abs","copyFrom","postMessage","view","depthMix","_depthMix","buffer","render","enableAlphaMode","effectiveMeshReplacement","_TypeNameToEnum","_ValueNameToEnum","ParseHeader","data","ubuf","Uint8Array","header","TextDecoder","decode","slice","headerEnd","headerEndIndex","indexOf","vertexCount","parseInt","exec","chunkElement","chunkCount","rowVertexOffset","rowChunkOffset","offsets","double","int","uint","float","short","ushort","uchar","list","ElementMode","chunkMode","vertexProperties","chunkProperties","filtered","split","prop","startsWith","typeName","type","push","offset","Logger","Warn","dataView","DataView","ArrayBuffer","_RowOutputLength","shBuffer","shCoefficientCount","rowVertexLength","rowChunkLength","_GetCompressedChunks","compressedChunks","Array","currentChunk","min","max","minScale","maxScale","minColor","maxColor","propertyIndex","property","getFloat32","_GetSplat","index","q","Quaternion","temp3","rowOutputLength","position","Float32Array","scale","rgba","Uint8ClampedArray","rot","sh","chunkIndex","r0","r1","r2","r3","plySH","getInt32","getUint32","getFloat64","getUint8","compressedChunk","Lerp","w","exp","_SH_C0","shIndex","compressedValue","clampedValue","Clamp","shDim","j","ConvertPLYWithSHToSplat","useCoroutine","_PlyConversionBatchSize","textureCount","ceil","shIndexRead","EngineStore","LastCreatedEngine","getCaps","maxTextureSize","textureIndex","texture","shIndexWrite","shValue","floor","ConvertPLYToSplat","ConvertPLYToSplatAsync","runCoroutineAsync","createYieldingScheduler","ConvertPLYWithSHToSplatAsync","loadDataAsync","updateDataAsync","plyBuffer","Tools","LoadFileAsync","dispose","doNotRecurse","shTexture","terminate","_copyTextures","newGS","_copySource","makeGeometryUnique","_instanciateWorker","binfo","getBoundingInfo","reConstruct","minimum","maximum","forcedInstanceCount","_makeSplat","fBuffer","uBuffer","covA","covB","colorArray","matrixRotation","matrixScale","quaternion","covBSItemSize","minimizeInPlaceFromFloats","maximizeInPlaceFromFloats","toRotationMatrix","ScalingToRef","covariances","factor","covIndex","transform","ToHalfFloat","_updateTextures","_getTextureSize","createTextureFromData","format","RawTexture","Constants","TEXTURE_BILINEAR_SAMPLINGMODE","TEXTURETYPE_FLOAT","createTextureFromDataU8","TEXTURETYPE_UNSIGNED_BYTE","createTextureFromDataU32","TEXTURE_NEAREST_SAMPLINGMODE","TEXTURETYPE_UNSIGNED_INTEGER","createTextureFromDataF16","TEXTURETYPE_HALF_FLOAT","colors","centers","from","TEXTUREFORMAT_RGBA","TEXTUREFORMAT_RG","shData","Uint32Array","TEXTUREFORMAT_RGBA_INTEGER","wrapU","TEXTURE_CLAMP_ADDRESSMODE","wrapV","_updateData","isAsync","_updateSplatIndexBuffer","textureLength","lineCountUpdate","ProgressiveUpdateAmount","textureLengthPerUpdate","Uint16Array","Number","MAX_VALUE","partCount","partIndex","updateLine","splatIndexBase","_updateSubTextures","_SplatBatchSize","updateData","runCoroutineSync","refreshBoundingInfo","thinInstanceRefreshBoundingInfo","thinInstanceSetBuffer","lineStart","lineCount","updateTextureFromData","updateTextureData","getInternalTexture","texelStart","texelCount","covAView","BYTES_PER_ELEMENT","covBView","colorsView","centersView","componentCount","shView","Worker","URL","createObjectURL","Blob","_CreateWorker","BigInt64Array","onmessage","e","indexMix","thinInstanceBufferUpdated","Error","Vector2","self","floatMix","viewProj","depthFactor","sort","CloudPoint","particleIndex","group","groupId","idxInGroup","pcs","idx","color","Color4","Zero","rotation","uv","velocity","pivot","translateFromPivot","_pos","_ind","_stillInvisible","_rotationMatrix","parentId","_globalPosition","_group","_pcs","size","rotationQuaternion","intersectsMesh","target","isSphere","hasBoundingInfo","boundingSphere","intersectsPoint","add","bbox","boundingBox","maxX","maximumWorld","minX","minimumWorld","maxY","minY","maxZ","minZ","getRotationMatrix","RotationYawPitchRollToRef","PointsGroup","groupID","id","posFunction","_positionFunction","PointsCloudSystem","_positions32","_colors32","uvs","_uvs32","pointSize","options","particles","nbParticles","counter","vars","_promises","_positions","_indices","_normals","_colors","_uvs","_updatable","_isVisibilityBoxLocked","_alwaysVisible","_groups","_groupCounter","_computeParticleColor","_computeParticleTexture","_computeParticleRotation","_computeBoundingBox","_isReady","_size","LastCreatedScene","updatable","buildMeshAsync","_buildMeshAsync","addPoints","UVKind","ec","ColorKind","mat","StandardMaterial","emissiveColor","Color3","disableLighting","_addParticle","cp","_randomUnitVector","particle","random","_getColorIndicesForCoord","pointsGroup","imageData","_groupImageData","colorIndices","greenIndex","blueIndex","alphaIndex","redForCoord","greenForCoord","blueForCoord","alphaForCoord","_setPointsColorOrUV","isVolume","colorFromTexture","hasTexture","range","uvSetIndex","updateFacetData","diameter","radius","meshPos","getVerticesData","meshInd","getIndices","meshUV","meshCol","place","computeWorldMatrix","meshMatrix","isIdentity","p","TransformCoordinatesFromFloatsToRef","idxPoints","id0","id1","id2","v0X","v0Y","v0Z","v1X","v1Y","v1Z","v2X","v2Y","v2Z","vertex0","vertex1","vertex2","vec0","vec1","uv0X","uv0Y","uv1X","uv1Y","uv2X","uv2Y","uv0","uv1","uv2","uvec0","uvec1","col0X","col0Y","col0Z","col0A","col1X","col1Y","col1Z","col1A","col2X","col2Y","col2Z","col2A","col0","Vector4","col1","col2","colvec0","colvec1","facetPoint","uvPoint","lamda","mu","colPoint","tang","biNorm","angle","facetPlaneVec","gap","distance","ray","Ray","pickInfo","direction","deltaS","deltaV","h","s","v","hsvCol","subtractToRef","statedColor","colPoint3","pointColors","_groupDensity","RandomRange","getFacetNormal","Cross","cos","sin","origin","hit","pickedPoint","subtract","addInPlace","_groupImgWidth","_groupImgHeight","round","r","g","toHSV","HSVtoRGBToRef","_colorFromTexture","textureList","getActiveTextures","BaseTexture","WhenAllReady","n","_textureNb","finalize","coordinatesIndex","dataPromise","readPixels","_calculateDensity","nbPoints","normal","area","cumulativeAreas","surfaceArea","nbFacets","CrossToRef","density","remainingPoints","cumulativeArea","facetPointsWithFraction","floored","fraction","facetPoints","nb","pointFunction","addSurfacePoints","colorWith","colored","isNaN","addVolumePoints","setParticles","start","end","update","beforeUpdateParticles","rotMatrix","colors32","positions32","uvs32","tempVectors","camAxisX","copyFromFloats","camAxisY","camAxisZ","setAll","IdentityToRef","isFacetDataEnabled","boundingInfo","pindex","cindex","uindex","updateParticle","particleRotationMatrix","particlePosition","particleGlobalPosition","parent","parentRotationMatrix","parentGlobalPosition","rotatedY","rotatedX","rotatedZ","rotMatrixValues","pivotBackTranslation","tmpVertex","vertexX","vertexY","vertexZ","px","py","pz","updateVerticesData","_worldMatrix","buildBoundingInfo","afterUpdateParticles","_indices32","refreshVisibleSize","setVisibilityBox","vis","isAlwaysVisible","val","alwaysSelectAsActiveMesh","computeParticleRotation","computeParticleColor","computeParticleTexture","computeBoundingBox","initParticles","recycleParticle","stop","SH_C0","LoadWebpImageData","rootUrlOrData","filename","promise","reject","image","createCanvasImage","objectUrl","onload","canvas","createCanvas","ctx","getContext","drawImage","getImageData","error","src","onerror","crossOrigin","blob","ParseSogMeta","dataOrFiles","files","Map","metaFile","get","JSON","parse","urls","means","scales","quats","sh0","shN","imageDataArrays","map","fileName","has","fileData","count","shape","unlog","meansl","meansu","isArray","mins","maxs","meansMin","meansMax","codebook","sc","sce","lsc","lsce","component","colorsMin","colorsMax","colort","csh","toComp","SQRT2","quatArray","quatsr","quatsg","quatsb","quatsa","mode","d","coeffCounts","coeffs","bands","shCentroids","shLabelsData","shCentroidsWidth","shComponentCount","u","k","shArray","byteIndexInTexture","offsetPerSplat","shMin","shMax","hasVertexColors","ParseSogDatas","SPLATFileLoader","loadingOptions","_DefaultLoadingOptions","SPLATFileLoaderMetadata","_assetContainer","extensions","_loadingOptions","createPlugin","importMeshAsync","meshesNames","_onProgress","_fileName","_parseAsync","meshes","particleSystems","skeletons","animationGroups","transformNodes","geometries","lights","spriteManagers","_BuildPointCloud","pointcloud","byteLength","_BuildMesh","parsedPLY","faces","_unzipWithFFlateAsync","window","fflate","LoadScriptAsync","deflateURL","unzipSync","unzipped","content","Object","entries","babylonMeshesArray","makeGSFromParsedSOG","parsedSOG","_blockEntityCollection","gaussianSplatting","_parentContainer","dataSOG","catch","u8","readableStream","ReadableStream","controller","enqueue","close","decompressionStream","DecompressionStream","decompressedStream","pipeThrough","Response","arrayBuffer","ubufu32","fractionalBits","flags","reserved","positionScale","int32View","Int32Array","uint8View","read24bComponent","byteOffset","coordinateSign","quaternionOffset","flipY","sqrt12","SQRT1_2","comp","cmask","iLargest","remaining","sumSquares","mag","negbit","square","shuffle","nx","ny","nz","trainedWithAntialiasing","ParseSpz","parsedSPZ","_ConvertPLYToSplat","compressed","rawSplat","loadAssetContainerAsync","container","AssetContainer","ex","loadAsync","faceElement","faceCount","faceVertexCount","vertexIndex","propertyCount","propertyColorCount","splatProperties","splatColorProperties","includes","hasMandatoryProperties","currentMode","RegisterSceneLoaderPlugin"],"mappings":"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GACX,IAAK,eACD,OAAO,GACX,IAAK,IACD,OAAO,GACX,IAAK,IACD,OAAO,GACX,IAAK,IACD,OAAO,GACX,IAAK,UACD,OAAO,GACX,IAAK,UACD,OAAO,GACX,IAAK,UACD,OAAO,GACX,IAAK,cACL,IAAK,MACD,OAAO,GACX,IAAK,gBACL,IAAK,QACD,OAAO,GACX,IAAK,eACL,IAAK,OACD,OAAO,GACX,IAAK,SACD,OAAO,GACX,IAAK,SACD,OAAO,GACX,IAAK,SACD,OAAO,GACX,IAAK,SACD,OAAO,GACX,IAAK,UACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK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"}