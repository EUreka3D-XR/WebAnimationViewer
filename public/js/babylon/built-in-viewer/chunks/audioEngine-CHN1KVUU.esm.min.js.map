{"version":3,"file":"audioEngine-CHN1KVUU.esm.min.js","sources":["../../../../../dev/core/dist/AudioV2/abstractAudio/audioEngineV2.js","../../../../../dev/core/dist/AudioV2/abstractAudio/subProperties/abstractSpatialAudioListener.js","../../../../../dev/core/dist/AudioV2/abstractAudio/components/spatialAudioAttacherComponent.js","../../../../../dev/core/dist/AudioV2/abstractAudio/subProperties/spatialAudioListener.js","../../../../../dev/core/dist/AudioV2/webAudio/components/spatialWebAudioUpdaterComponent.js","../../../../../dev/core/dist/AudioV2/audioUtils.js","../../../../../dev/core/dist/AudioV2/webAudio/components/webAudioParameterComponent.js","../../../../../dev/core/dist/AudioV2/webAudio/subProperties/spatialWebAudioListener.js","../../../../../dev/core/dist/AudioV2/abstractAudio/abstractAudioNode.js","../../../../../dev/core/dist/AudioV2/abstractAudio/mainAudioOut.js","../../../../../dev/core/dist/AudioV2/webAudio/webAudioMainOut.js","../../../../../dev/core/dist/AudioV2/webAudio/webAudioUnmuteUI.js","../../../../../dev/core/dist/AudioV2/webAudio/webAudioEngine.js","../../../../../dev/core/dist/Audio/audioEngine.js"],"sourcesContent":["const Instances = [];\n/**\n * Gets the most recently created v2 audio engine.\n * @returns The most recently created v2 audio engine.\n */\nexport function LastCreatedAudioEngine() {\n    if (Instances.length === 0) {\n        return null;\n    }\n    return Instances[Instances.length - 1];\n}\n/**\n * Abstract base class for v2 audio engines.\n *\n * A v2 audio engine based on the WebAudio API can be created with the {@link CreateAudioEngineAsync} function.\n */\nexport class AudioEngineV2 {\n    constructor(options) {\n        /** Not owned, but all items should be in `_nodes` container, too, which is owned. */\n        this._mainBuses = new Set();\n        /** Owned top-level sound and bus nodes. */\n        this._nodes = new Set();\n        this._defaultMainBus = null;\n        this._parameterRampDuration = 0.01;\n        Instances.push(this);\n        if (typeof options.parameterRampDuration === \"number\") {\n            this.parameterRampDuration = options.parameterRampDuration;\n        }\n    }\n    /**\n     * The default main bus that will be used for audio buses and sounds if their `outBus` option is not set.\n     * @see {@link IAudioBusOptions.outBus}\n     * @see {@link IAbstractSoundOptions.outBus}\n     */\n    get defaultMainBus() {\n        if (this._mainBuses.size === 0) {\n            return null;\n        }\n        if (!this._defaultMainBus) {\n            this._defaultMainBus = Array.from(this._mainBuses)[0];\n        }\n        return this._defaultMainBus;\n    }\n    /**\n     * The smoothing duration to use when changing audio parameters, in seconds. Defaults to `0.01` (10 milliseconds).\n     *\n     * Due to limitations in some browsers, it is not recommended to set this value to longer than `0.01` seconds.\n     *\n     * Setting this value to longer than `0.01` seconds may result in errors being throw when setting audio parameters.\n     */\n    get parameterRampDuration() {\n        return this._parameterRampDuration;\n    }\n    set parameterRampDuration(value) {\n        this._parameterRampDuration = Math.max(0, value);\n    }\n    /**\n     * Releases associated resources.\n     */\n    dispose() {\n        if (Instances.includes(this)) {\n            Instances.splice(Instances.indexOf(this), 1);\n        }\n        const nodeIt = this._nodes.values();\n        for (let next = nodeIt.next(); !next.done; next = nodeIt.next()) {\n            next.value.dispose();\n        }\n        this._mainBuses.clear();\n        this._nodes.clear();\n        this._defaultMainBus = null;\n    }\n    /**\n     * Unlocks the audio engine if it is locked.\n     * - Note that the returned promise may already be resolved if the audio engine is already unlocked.\n     * @returns A promise that is resolved when the audio engine is unlocked.\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    unlockAsync() {\n        return this.resumeAsync();\n    }\n    _addMainBus(mainBus) {\n        this._mainBuses.add(mainBus);\n        this._addNode(mainBus);\n    }\n    _removeMainBus(mainBus) {\n        this._mainBuses.delete(mainBus);\n        this._defaultMainBus = null;\n        this._removeNode(mainBus);\n    }\n    _addNode(node) {\n        this._nodes.add(node);\n    }\n    _removeNode(node) {\n        this._nodes.delete(node);\n    }\n}\n/**\n * @internal\n * @param engine - The given audio engine. If `null` then the last created audio engine is used.\n * @returns the given audio engine or the last created audio engine.\n * @throws An error if the resulting engine is `null`.\n */\nexport function _GetAudioEngine(engine) {\n    if (!engine) {\n        engine = LastCreatedAudioEngine();\n    }\n    if (engine) {\n        return engine;\n    }\n    throw new Error(\"No audio engine.\");\n}\n/**\n * Creates a new audio bus.\n * @param name - The name of the audio bus.\n * @param options - The options to use when creating the audio bus.\n * @param engine - The audio engine.\n * @returns A promise that resolves with the created audio bus.\n */\n// eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\nexport function CreateAudioBusAsync(name, options = {}, engine = null) {\n    engine = _GetAudioEngine(engine);\n    return engine.createBusAsync(name, options);\n}\n/**\n * Creates a new main audio bus.\n * @param name - The name of the main audio bus.\n * @param options - The options to use when creating the main audio bus.\n * @param engine - The audio engine.\n * @returns A promise that resolves with the created main audio bus.\n */\n// eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\nexport function CreateMainAudioBusAsync(name, options = {}, engine = null) {\n    engine = _GetAudioEngine(engine);\n    return engine.createMainBusAsync(name, options);\n}\n/**\n * Creates a new microphone sound source.\n * @param name - The name of the sound.\n * @param options - The options for the sound source.\n * @param engine - The audio engine.\n * @returns A promise that resolves to the created sound source.\n */\n// eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\nexport function CreateMicrophoneSoundSourceAsync(name, options = {}, engine = null) {\n    engine = _GetAudioEngine(engine);\n    return engine.createMicrophoneSoundSourceAsync(name, options);\n}\n/**\n * Creates a new static sound.\n * @param name - The name of the sound.\n * @param source - The source of the sound.\n * @param options - The options for the static sound.\n * @param engine - The audio engine.\n * @returns A promise that resolves to the created static sound.\n */\n// eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\nexport function CreateSoundAsync(name, source, options = {}, engine = null) {\n    engine = _GetAudioEngine(engine);\n    return engine.createSoundAsync(name, source, options);\n}\n/**\n * Creates a new static sound buffer.\n * @param source - The source of the sound buffer.\n * @param options - The options for the static sound buffer.\n * @param engine - The audio engine.\n * @returns A promise that resolves to the created static sound buffer.\n */\nexport async function CreateSoundBufferAsync(source, options = {}, engine = null) {\n    engine = _GetAudioEngine(engine);\n    return await engine.createSoundBufferAsync(source, options);\n}\n/**\n * Creates a new sound source.\n * @param name - The name of the sound.\n * @param source - The source of the sound.\n * @param options - The options for the sound source.\n * @param engine - The audio engine.\n * @returns A promise that resolves to the created sound source.\n */\n// eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\nexport function CreateSoundSourceAsync(name, source, options = {}, engine = null) {\n    engine = _GetAudioEngine(engine);\n    return engine.createSoundSourceAsync(name, source, options);\n}\n/**\n * Creates a new streaming sound.\n * @param name - The name of the sound.\n * @param source - The source of the sound.\n * @param options - The options for the streaming sound.\n * @param engine - The audio engine.\n * @returns A promise that resolves to the created streaming sound.\n */\n// eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\nexport function CreateStreamingSoundAsync(name, source, options = {}, engine = null) {\n    engine = _GetAudioEngine(engine);\n    return engine.createStreamingSoundAsync(name, source, options);\n}\n//# sourceMappingURL=audioEngineV2.js.map","import { Quaternion, Vector3 } from \"../../../Maths/math.vector\";\nexport const _SpatialAudioListenerDefaults = {\n    position: Vector3.Zero(),\n    rotation: Vector3.Zero(),\n    rotationQuaternion: new Quaternion(),\n};\n/**\n * @param options The spatial audio listener options to check.\n * @returns `true` if spatial audio listener options are defined, otherwise `false`.\n */\nexport function _HasSpatialAudioListenerOptions(options) {\n    return (options.listenerEnabled ||\n        options.listenerMinUpdateTime !== undefined ||\n        options.listenerPosition !== undefined ||\n        options.listenerRotation !== undefined ||\n        options.listenerRotationQuaternion !== undefined);\n}\n/**\n * Abstract class representing the spatial audio `listener` property on an audio engine.\n *\n * @see {@link AudioEngineV2.listener}\n */\nexport class AbstractSpatialAudioListener {\n}\n//# sourceMappingURL=abstractSpatialAudioListener.js.map","import { Quaternion, Vector3 } from \"../../../Maths/math.vector\";\n/**\n * Provides a common interface for attaching an audio listener or source to a specific entity, ensuring only one entity\n * is attached at a time.\n * @internal\n */\nexport class _SpatialAudioAttacherComponent {\n    /** @internal */\n    constructor(spatialAudioNode) {\n        /** @internal */\n        this._attachmentType = 3 /* SpatialAudioAttachmentType.PositionAndRotation */;\n        this._position = new Vector3();\n        this._rotationQuaternion = new Quaternion();\n        this._sceneNode = null;\n        this._useBoundingBox = false;\n        /**\n         * Releases associated resources.\n         */\n        this.dispose = () => {\n            this.detach();\n        };\n        this._spatialAudioNode = spatialAudioNode;\n    }\n    /**\n     * Returns `true` if attached to a scene node; otherwise returns `false`.\n     */\n    get isAttached() {\n        return this._sceneNode !== null;\n    }\n    /**\n     * Attaches to a scene node.\n     *\n     * Detaches automatically before attaching to the given scene node.\n     * If `sceneNode` is `null` it is the same as calling `detach()`.\n     *\n     * @param sceneNode The scene node to attach to, or `null` to detach.\n     * @param useBoundingBox Whether to use the scene node's bounding box for positioning. Defaults to `false`.\n     * @param attachmentType Whether to attach to the scene node's position and/or rotation. Defaults to `PositionAndRotation`.\n     */\n    attach(sceneNode, useBoundingBox, attachmentType) {\n        if (this._sceneNode === sceneNode) {\n            return;\n        }\n        this.detach();\n        if (!sceneNode) {\n            return;\n        }\n        this._attachmentType = attachmentType;\n        this._sceneNode = sceneNode;\n        this._sceneNode.onDisposeObservable.add(this.dispose);\n        this._useBoundingBox = useBoundingBox;\n    }\n    /**\n     * Detaches from the scene node if attached.\n     */\n    detach() {\n        this._sceneNode?.onDisposeObservable.removeCallback(this.dispose);\n        this._sceneNode = null;\n    }\n    /**\n     * Updates the position and rotation of the associated audio engine object in the audio rendering graph.\n     *\n     * This is called automatically by default and only needs to be called manually if automatic updates are disabled.\n     */\n    update() {\n        if (this._attachmentType & 1 /* SpatialAudioAttachmentType.Position */) {\n            if (this._useBoundingBox && this._sceneNode.getBoundingInfo) {\n                this._position.copyFrom(this._sceneNode.getBoundingInfo().boundingBox.centerWorld);\n            }\n            else {\n                this._sceneNode?.getWorldMatrix().getTranslationToRef(this._position);\n            }\n            this._spatialAudioNode.position.copyFrom(this._position);\n            this._spatialAudioNode._updatePosition();\n        }\n        if (this._attachmentType & 2 /* SpatialAudioAttachmentType.Rotation */) {\n            this._sceneNode?.getWorldMatrix().decompose(undefined, this._rotationQuaternion);\n            this._spatialAudioNode.rotationQuaternion.copyFrom(this._rotationQuaternion);\n            this._spatialAudioNode._updateRotation();\n        }\n    }\n}\n//# sourceMappingURL=spatialAudioAttacherComponent.js.map","import { _SpatialAudioAttacherComponent } from \"../components/spatialAudioAttacherComponent\";\nimport { _SpatialAudioListenerDefaults, AbstractSpatialAudioListener } from \"./abstractSpatialAudioListener\";\n/** @internal */\nexport class _SpatialAudioListener extends AbstractSpatialAudioListener {\n    constructor() {\n        super();\n        this._attacherComponent = null;\n        this._attacherComponent = new _SpatialAudioAttacherComponent(this);\n    }\n    /** @internal */\n    get isAttached() {\n        return this._attacherComponent !== null && this._attacherComponent.isAttached;\n    }\n    /**\n     * Attaches to a scene node.\n     *\n     * Detaches automatically before attaching to the given scene node.\n     * If `sceneNode` is `null` it is the same as calling `detach()`.\n     *\n     * @param sceneNode The scene node to attach to, or `null` to detach.\n     * @param useBoundingBox Whether to use the bounding box of the node for positioning. Defaults to `false`.\n     * @param attachmentType Whether to attach to the node's position and/or rotation. Defaults to `PositionAndRotation`.\n     */\n    attach(sceneNode, useBoundingBox = false, attachmentType = 3 /* SpatialAudioAttachmentType.PositionAndRotation */) {\n        if (!this._attacherComponent) {\n            this._attacherComponent = new _SpatialAudioAttacherComponent(this);\n        }\n        this._attacherComponent.attach(sceneNode, useBoundingBox, attachmentType);\n    }\n    /**\n     * Detaches from the scene node if attached.\n     */\n    detach() {\n        this._attacherComponent?.detach();\n    }\n    /** @internal */\n    dispose() {\n        this._attacherComponent?.dispose();\n        this._attacherComponent = null;\n    }\n    /** @internal */\n    setOptions(options) {\n        if (options.listenerMinUpdateTime !== undefined) {\n            this.minUpdateTime = options.listenerMinUpdateTime;\n        }\n        if (options.listenerPosition) {\n            this.position = options.listenerPosition.clone();\n        }\n        if (options.listenerRotationQuaternion) {\n            this.rotationQuaternion = options.listenerRotationQuaternion.clone();\n        }\n        else if (options.listenerRotation) {\n            this.rotation = options.listenerRotation.clone();\n        }\n        else {\n            this.rotationQuaternion = _SpatialAudioListenerDefaults.rotationQuaternion.clone();\n        }\n        this.update();\n    }\n}\n//# sourceMappingURL=spatialAudioListener.js.map","import { PrecisionDate } from \"../../../Misc/precisionDate\";\n/** @internal */\nexport class _SpatialWebAudioUpdaterComponent {\n    /** @internal */\n    constructor(parent, autoUpdate, minUpdateTime) {\n        this._autoUpdate = true;\n        this._lastUpdateTime = 0;\n        /** @internal */\n        this.minUpdateTime = 0;\n        if (!autoUpdate) {\n            return;\n        }\n        this.minUpdateTime = minUpdateTime;\n        const update = () => {\n            if (!this._autoUpdate) {\n                return;\n            }\n            let skipUpdate = false;\n            if (0 < this.minUpdateTime) {\n                const now = PrecisionDate.Now;\n                if (this._lastUpdateTime && now - this._lastUpdateTime < this.minUpdateTime) {\n                    skipUpdate = true;\n                }\n                this._lastUpdateTime = now;\n            }\n            if (!skipUpdate) {\n                parent.update();\n            }\n            requestAnimationFrame(update);\n        };\n        requestAnimationFrame(update);\n    }\n    /** @internal */\n    dispose() {\n        this._autoUpdate = false;\n    }\n}\n//# sourceMappingURL=spatialWebAudioUpdaterComponent.js.map","export const _FileExtensionRegex = new RegExp(\"\\\\.(\\\\w{3,4})($|\\\\?)\");\nconst CurveLength = 100;\nconst TmpLineValues = new Float32Array([0, 0]);\nlet TmpCurveValues = null;\nlet ExpCurve = null;\nlet LogCurve = null;\n/**\n * @returns A Float32Array representing an exponential ramp from (0, 0) to (1, 1).\n */\nfunction GetExpCurve() {\n    if (!ExpCurve) {\n        ExpCurve = new Float32Array(CurveLength);\n        const increment = 1 / (CurveLength - 1);\n        let x = increment;\n        for (let i = 1; i < CurveLength; i++) {\n            ExpCurve[i] = Math.exp(-11.512925464970227 * (1 - x));\n            x += increment;\n        }\n    }\n    return ExpCurve;\n}\n/**\n * @returns A Float32Array representing a logarithmic ramp from (0, 0) to (1, 1).\n */\nfunction GetLogCurve() {\n    if (!LogCurve) {\n        LogCurve = new Float32Array(CurveLength);\n        const increment = 1 / CurveLength;\n        let x = increment;\n        for (let i = 0; i < CurveLength; i++) {\n            LogCurve[i] = 1 + Math.log10(x) / Math.log10(CurveLength);\n            x += increment;\n        }\n    }\n    return LogCurve;\n}\n/** @internal */\nexport function _GetAudioParamCurveValues(shape, from, to) {\n    if (!TmpCurveValues) {\n        TmpCurveValues = new Float32Array(CurveLength);\n    }\n    let normalizedCurve;\n    if (shape === \"linear\" /* AudioParameterRampShape.Linear */) {\n        TmpLineValues[0] = from;\n        TmpLineValues[1] = to;\n        return TmpLineValues;\n    }\n    else if (shape === \"exponential\" /* AudioParameterRampShape.Exponential */) {\n        normalizedCurve = GetExpCurve();\n    }\n    else if (shape === \"logarithmic\" /* AudioParameterRampShape.Logarithmic */) {\n        normalizedCurve = GetLogCurve();\n    }\n    else {\n        throw new Error(`Unknown ramp shape: ${shape}`);\n    }\n    const direction = Math.sign(to - from);\n    const range = Math.abs(to - from);\n    if (direction === 1) {\n        for (let i = 0; i < normalizedCurve.length; i++) {\n            TmpCurveValues[i] = from + range * normalizedCurve[i];\n        }\n    }\n    else {\n        let j = CurveLength - 1;\n        for (let i = 0; i < normalizedCurve.length; i++, j--) {\n            TmpCurveValues[i] = from - range * (1 - normalizedCurve[j]);\n        }\n    }\n    return TmpCurveValues;\n}\n/** @internal */\nexport function _CleanUrl(url) {\n    return url.replace(/#/gm, \"%23\");\n}\n//# sourceMappingURL=audioUtils.js.map","import { _GetAudioParamCurveValues } from \"../../audioUtils\";\n/**\n * Maximum time in seconds to wait for an active ramp to finish before starting a new ramp.\n *\n * New ramps will throw an error if the active ramp has more than this amount of time remaining.\n *\n * This is needed because short ramps are used to avoid pops and clicks when setting audio parameters, and we\n * don't want to throw an error if a short ramp is active.\n *\n * This constant is set to 11 milliseconds, which is short enough to avoid perceptual differences in most cases, but\n * long enough to allow for short ramps to be completed in a reasonable time frame.\n */\nconst MaxWaitTime = 0.011;\n/**\n * Minimum duration in seconds for a ramp to be considered valid.\n *\n * If the duration is less than this value, the value will be set immediately instead of being ramped smoothly since\n * there is no perceptual difference for such short durations, so a ramp is not needed.\n */\nconst MinRampDuration = 0.000001;\n/** @internal */\nexport class _WebAudioParameterComponent {\n    /** @internal */\n    constructor(engine, param) {\n        this._deferredRampOptions = {\n            duration: 0,\n            shape: \"linear\" /* AudioParameterRampShape.Linear */,\n        };\n        this._deferredTargetValue = -1;\n        this._isObservingUpdates = false;\n        this._rampEndTime = 0;\n        this._applyDeferredRamp = () => {\n            if (0 < this._deferredRampOptions.duration && this._rampEndTime < this._engine.currentTime) {\n                this.setTargetValue(this._deferredTargetValue, this._deferredRampOptions);\n            }\n        };\n        this._engine = engine;\n        this._param = param;\n        this._targetValue = param.value;\n    }\n    /** @internal */\n    get isRamping() {\n        return this._engine.currentTime < this._rampEndTime;\n    }\n    /** @internal */\n    get targetValue() {\n        return this._targetValue;\n    }\n    set targetValue(value) {\n        this.setTargetValue(value);\n    }\n    /** @internal */\n    get value() {\n        return this._param.value;\n    }\n    /** @internal */\n    dispose() {\n        this._clearDeferredRamp();\n        this._param = null;\n        this._engine = null;\n    }\n    /**\n     * Sets the target value of the audio parameter with an optional ramping duration and shape.\n     *\n     * If a ramp is close to finishing, it will wait for the ramp to finish before setting the new value; otherwise it\n     * will throw an error because of a bug in Firefox that prevents active ramps from being cancelled with\n     * `cancelScheduledValues`. See https://bugzilla.mozilla.org/show_bug.cgi?id=1752775. Other browsers do not have\n     * this issue, but we throw an error in all browsers to ensure consistent behavior.\n     *\n     * There are other similar WebAudio APIs for ramping parameters, (e.g. `linearRampToValueAtTime` and\n     * `exponentialRampToValueAtTime`) but they don't work in Firefox and Meta Quest Chrome.\n     *\n     * It may be better in the long run to implement our own ramping logic with a WASM audio worklet instead of using\n     * `setValueCurveAtTime`. Another alternative is to use `setValueAtTime` wtih a custom shape, but that will\n     * probably be a performance hit to maintain quality at audio rates.\n     *\n     * @internal\n     */\n    setTargetValue(value, options = null) {\n        if (this._targetValue === value) {\n            return;\n        }\n        const shape = typeof options?.shape === \"string\" ? options.shape : \"linear\" /* AudioParameterRampShape.Linear */;\n        let duration = typeof options?.duration === \"number\" ? Math.max(options.duration, this._engine.parameterRampDuration) : this._engine.parameterRampDuration;\n        const startTime = this._engine.currentTime;\n        if (startTime < this._rampEndTime) {\n            const timeLeft = this._rampEndTime - startTime;\n            if (MaxWaitTime < timeLeft) {\n                throw new Error(\"Audio parameter not set. Wait for current ramp to finish.\");\n            }\n            else {\n                this._deferRamp(value, duration, shape);\n                return;\n            }\n        }\n        if ((duration = Math.max(this._engine.parameterRampDuration, duration)) < MinRampDuration) {\n            this._param.setValueAtTime((this._targetValue = value), startTime);\n            return;\n        }\n        this._param.cancelScheduledValues(startTime);\n        this._param.setValueCurveAtTime(_GetAudioParamCurveValues(shape, this._targetValue, (this._targetValue = value)), startTime, duration);\n        this._clearDeferredRamp();\n        this._rampEndTime = startTime + duration;\n    }\n    _deferRamp(value, duration, shape) {\n        this._deferredRampOptions.duration = duration;\n        this._deferredRampOptions.shape = shape;\n        this._deferredTargetValue = value;\n        if (!this._isObservingUpdates) {\n            this._engine._addUpdateObserver(this._applyDeferredRamp);\n            this._isObservingUpdates = true;\n        }\n    }\n    _clearDeferredRamp() {\n        this._deferredRampOptions.duration = 0;\n        if (this._isObservingUpdates) {\n            this._engine._removeUpdateObserver(this._applyDeferredRamp);\n            this._isObservingUpdates = false;\n        }\n    }\n}\n//# sourceMappingURL=webAudioParameterComponent.js.map","import { Matrix, Quaternion, Vector3 } from \"../../../Maths/math.vector\";\nimport { _SpatialAudioListener } from \"../../abstractAudio/subProperties/spatialAudioListener\";\nimport { _SpatialWebAudioUpdaterComponent } from \"../components/spatialWebAudioUpdaterComponent\";\nimport { _WebAudioParameterComponent } from \"../components/webAudioParameterComponent\";\nconst TmpMatrix = Matrix.Zero();\nconst TmpQuaternion = new Quaternion();\nconst TmpVector1 = Vector3.Zero();\nconst TmpVector2 = Vector3.Zero();\n/** @internal */\nexport function _CreateSpatialAudioListener(engine, autoUpdate, minUpdateTime) {\n    const listener = engine._audioContext.listener;\n    if (listener.forwardX &&\n        listener.forwardY &&\n        listener.forwardZ &&\n        listener.positionX &&\n        listener.positionY &&\n        listener.positionZ &&\n        listener.upX &&\n        listener.upY &&\n        listener.upZ) {\n        return new _SpatialWebAudioListener(engine, autoUpdate, minUpdateTime);\n    }\n    else {\n        return new _SpatialWebAudioListenerFallback(engine, autoUpdate, minUpdateTime);\n    }\n}\nclass _AbstractSpatialWebAudioListener extends _SpatialAudioListener {\n    /** @internal */\n    constructor(engine, autoUpdate, minUpdateTime) {\n        super();\n        this._lastPosition = Vector3.Zero();\n        this._lastRotation = Vector3.Zero();\n        this._lastRotationQuaternion = new Quaternion();\n        /** @internal */\n        this.position = Vector3.Zero();\n        /** @internal */\n        this.rotation = Vector3.Zero();\n        /** @internal */\n        this.rotationQuaternion = new Quaternion();\n        this._listener = engine._audioContext.listener;\n        this.engine = engine;\n        this._updaterComponent = new _SpatialWebAudioUpdaterComponent(this, autoUpdate, minUpdateTime);\n    }\n    /** @internal */\n    dispose() {\n        super.dispose();\n        this._updaterComponent.dispose();\n        this._updaterComponent = null;\n    }\n    /** @internal */\n    get minUpdateTime() {\n        return this._updaterComponent.minUpdateTime;\n    }\n    /** @internal */\n    set minUpdateTime(value) {\n        this._updaterComponent.minUpdateTime = value;\n    }\n    /** @internal */\n    update() {\n        if (this.isAttached) {\n            this._attacherComponent?.update();\n        }\n        else {\n            this._updatePosition();\n            this._updateRotation();\n        }\n    }\n    _updatePosition() {\n        if (this._lastPosition.equalsWithEpsilon(this.position)) {\n            return;\n        }\n        this._setWebAudioPosition(this.position);\n        this._lastPosition.copyFrom(this.position);\n    }\n    _updateRotation() {\n        if (!this._lastRotationQuaternion.equalsWithEpsilon(this.rotationQuaternion)) {\n            TmpQuaternion.copyFrom(this.rotationQuaternion);\n            this._lastRotationQuaternion.copyFrom(this.rotationQuaternion);\n        }\n        else if (!this._lastRotation.equalsWithEpsilon(this.rotation)) {\n            Quaternion.FromEulerAnglesToRef(this.rotation.x, this.rotation.y, this.rotation.z, TmpQuaternion);\n            this._lastRotation.copyFrom(this.rotation);\n        }\n        else {\n            return;\n        }\n        Matrix.FromQuaternionToRef(TmpQuaternion, TmpMatrix);\n        // NB: The WebAudio API is right-handed.\n        Vector3.TransformNormalToRef(Vector3.RightHandedForwardReadOnly, TmpMatrix, TmpVector1);\n        Vector3.TransformNormalToRef(Vector3.Up(), TmpMatrix, TmpVector2);\n        this._setWebAudioOrientation(TmpVector1, TmpVector2);\n    }\n}\n/**\n * Full-featured spatial audio listener for the Web Audio API.\n *\n * Used in browsers that support the `forwardX/Y/Z`, `positionX/Y/Z`, and `upX/Y/Z` properties on the AudioContext listener.\n *\n * NB: Firefox falls back to using this implementation.\n *\n * @see _SpatialWebAudioListenerFallback for the implementation used if only `setPosition` and `setOrientation` are available.\n *\n * NB: This sub property is not backed by a sub node and all properties are set directly on the audio context listener.\n *\n * @internal\n */\nclass _SpatialWebAudioListener extends _AbstractSpatialWebAudioListener {\n    constructor(engine, autoUpdate, minUpdateTime) {\n        super(engine, autoUpdate, minUpdateTime);\n        const listener = engine._audioContext.listener;\n        this._forwardX = new _WebAudioParameterComponent(engine, listener.forwardX);\n        this._forwardY = new _WebAudioParameterComponent(engine, listener.forwardY);\n        this._forwardZ = new _WebAudioParameterComponent(engine, listener.forwardZ);\n        this._positionX = new _WebAudioParameterComponent(engine, listener.positionX);\n        this._positionY = new _WebAudioParameterComponent(engine, listener.positionY);\n        this._positionZ = new _WebAudioParameterComponent(engine, listener.positionZ);\n        this._upX = new _WebAudioParameterComponent(engine, listener.upX);\n        this._upY = new _WebAudioParameterComponent(engine, listener.upY);\n        this._upZ = new _WebAudioParameterComponent(engine, listener.upZ);\n    }\n    _setWebAudioPosition(position) {\n        // If attached and there is a ramp in progress, we assume another update is coming soon that we can wait for.\n        // We don't do this for unattached nodes because there may not be another update coming.\n        if (this.isAttached && (this._positionX.isRamping || this._positionY.isRamping || this._positionZ.isRamping)) {\n            return;\n        }\n        this._positionX.targetValue = position.x;\n        this._positionY.targetValue = position.y;\n        this._positionZ.targetValue = position.z;\n    }\n    _setWebAudioOrientation(forward, up) {\n        // If attached and there is a ramp in progress, we assume another update is coming soon that we can wait for.\n        // We don't do this for unattached nodes because there may not be another update coming.\n        if (this.isAttached &&\n            (this._forwardX.isRamping || this._forwardY.isRamping || this._forwardZ.isRamping || this._upX.isRamping || this._upY.isRamping || this._upZ.isRamping)) {\n            return;\n        }\n        this._forwardX.targetValue = forward.x;\n        this._forwardY.targetValue = forward.y;\n        this._forwardZ.targetValue = forward.z;\n        this._upX.targetValue = up.x;\n        this._upY.targetValue = up.y;\n        this._upZ.targetValue = up.z;\n    }\n}\n/**\n * Fallback spatial audio listener for the Web Audio API.\n *\n * Used in browsers that do not support the `forwardX/Y/Z`, `positionX/Y/Z`, and `upX/Y/Z` properties on the\n * AudioContext listener.\n *\n * @see _SpatialWebAudioListener for the implementation used if the `forwardX/Y/Z`, `positionX/Y/Z`, and `upX/Y/Z`\n * properties are available.\n *\n * NB: This sub property is not backed by a sub node and all properties are set directly on the audio context listener.\n *\n * @internal\n */\nclass _SpatialWebAudioListenerFallback extends _AbstractSpatialWebAudioListener {\n    _setWebAudioPosition(position) {\n        this._listener.setPosition(position.x, position.y, position.z);\n    }\n    _setWebAudioOrientation(forward, up) {\n        this._listener.setOrientation(forward.x, forward.y, forward.z, up.x, up.y, up.z);\n    }\n}\n//# sourceMappingURL=spatialWebAudioListener.js.map","import { Observable } from \"../../Misc/observable\";\nexport var AudioNodeType;\n(function (AudioNodeType) {\n    AudioNodeType[AudioNodeType[\"HAS_INPUTS\"] = 1] = \"HAS_INPUTS\";\n    AudioNodeType[AudioNodeType[\"HAS_OUTPUTS\"] = 2] = \"HAS_OUTPUTS\";\n    AudioNodeType[AudioNodeType[\"HAS_INPUTS_AND_OUTPUTS\"] = 3] = \"HAS_INPUTS_AND_OUTPUTS\";\n})(AudioNodeType || (AudioNodeType = {}));\n/**\n * Abstract class for an audio node.\n *\n * An audio node is a processing unit that can receive audio data from an upstream node and/or send audio data to a\n * downstream node.\n *\n * Nodes can be connected to other nodes to create an audio graph. The audio graph represents the flow of audio data.\n *\n * There are 3 types of audio nodes:\n * 1. Input: Receives audio data from upstream nodes.\n * 2. Output: Sends audio data to downstream nodes.\n * 3. Input/Output: Receives audio data from upstream nodes and sends audio data to downstream nodes.\n */\nexport class AbstractAudioNode {\n    constructor(engine, nodeType) {\n        /**\n         * Observable for when the audio node is disposed.\n         */\n        this.onDisposeObservable = new Observable();\n        this.engine = engine;\n        if (nodeType & 1 /* AudioNodeType.HAS_INPUTS */) {\n            this._upstreamNodes = new Set();\n        }\n        if (nodeType & 2 /* AudioNodeType.HAS_OUTPUTS */) {\n            this._downstreamNodes = new Set();\n        }\n    }\n    /**\n     * Releases associated resources.\n     * - Triggers `onDisposeObservable`.\n     * @see {@link onDisposeObservable}\n     */\n    dispose() {\n        if (this._downstreamNodes) {\n            for (const node of Array.from(this._downstreamNodes)) {\n                if (!this._disconnect(node)) {\n                    throw new Error(\"Disconnect failed\");\n                }\n            }\n            this._downstreamNodes.clear();\n        }\n        if (this._upstreamNodes) {\n            for (const node of Array.from(this._upstreamNodes)) {\n                if (!node._disconnect(this)) {\n                    throw new Error(\"Disconnect failed\");\n                }\n            }\n            this._upstreamNodes.clear();\n        }\n        this.onDisposeObservable.notifyObservers(this);\n        this.onDisposeObservable.clear();\n    }\n    /**\n     * Connect to a downstream audio input node.\n     * @param node - The downstream audio input node to connect\n     * @returns `true` if the node is successfully connected; otherwise `false`\n     */\n    _connect(node) {\n        if (!this._downstreamNodes) {\n            return false;\n        }\n        if (this._downstreamNodes.has(node)) {\n            return false;\n        }\n        if (!node._onConnect(this)) {\n            return false;\n        }\n        this._downstreamNodes.add(node);\n        return true;\n    }\n    /**\n     * Disconnects a downstream audio input node.\n     * @param node - The downstream audio input node to disconnect\n     * @returns `true` if the node is successfully disconnected; otherwise `false`\n     */\n    _disconnect(node) {\n        if (!this._downstreamNodes) {\n            return false;\n        }\n        if (!this._downstreamNodes.delete(node)) {\n            return false;\n        }\n        return node._onDisconnect(this);\n    }\n    /**\n     * Called when an upstream audio output node is connecting.\n     * @param node - The connecting upstream audio node\n     * @returns `true` if the node is successfully connected; otherwise `false`\n     */\n    _onConnect(node) {\n        if (!this._upstreamNodes) {\n            return false;\n        }\n        if (this._upstreamNodes.has(node)) {\n            return false;\n        }\n        this._upstreamNodes.add(node);\n        return true;\n    }\n    /**\n     * Called when an upstream audio output node disconnects.\n     * @param node - The disconnecting upstream audio node\n     * @returns `true` if node is sucessfully disconnected; otherwise `false`\n     */\n    _onDisconnect(node) {\n        return this._upstreamNodes?.delete(node) ?? false;\n    }\n}\n/**\n * Abstract class for a named audio node.\n */\nexport class AbstractNamedAudioNode extends AbstractAudioNode {\n    constructor(name, engine, nodeType) {\n        super(engine, nodeType);\n        /**\n         * Observable for when the audio node is renamed.\n         */\n        this.onNameChangedObservable = new Observable();\n        this._name = name;\n    }\n    /**\n     * The name of the audio node.\n     * - Triggers `onNameChangedObservable` when changed.\n     * @see {@link onNameChangedObservable}\n     */\n    get name() {\n        return this._name;\n    }\n    set name(newName) {\n        if (this._name === newName) {\n            return;\n        }\n        const oldName = this._name;\n        this._name = newName;\n        this.onNameChangedObservable.notifyObservers({ newName, oldName, node: this });\n    }\n    dispose() {\n        super.dispose();\n        this.onNameChangedObservable.clear();\n    }\n}\n//# sourceMappingURL=abstractAudioNode.js.map","import { AbstractAudioNode } from \"./abstractAudioNode\";\n/**\n * Abstract class for the main audio output node.\n *\n * A main audio output is the last audio node in the audio graph before the audio is sent to the speakers.\n *\n * @see {@link AudioEngineV2.mainOut}\n * @internal\n */\nexport class _MainAudioOut extends AbstractAudioNode {\n    constructor(engine) {\n        super(engine, 1 /* AudioNodeType.HAS_INPUTS */);\n    }\n}\n//# sourceMappingURL=mainAudioOut.js.map","import { _MainAudioOut } from \"../abstractAudio/mainAudioOut\";\nimport { _WebAudioParameterComponent } from \"./components/webAudioParameterComponent\";\n/** @internal */\nexport class _WebAudioMainOut extends _MainAudioOut {\n    /** @internal */\n    constructor(engine) {\n        super(engine);\n        this._setGainNode(new GainNode(engine._audioContext));\n    }\n    /** @internal */\n    dispose() {\n        super.dispose();\n        this._volume.dispose();\n        this._gainNode.disconnect();\n        this._destinationNode.disconnect();\n    }\n    /** @internal */\n    get _inNode() {\n        return this._gainNode;\n    }\n    set _inNode(value) {\n        if (this._gainNode === value) {\n            return;\n        }\n        this._setGainNode(value);\n    }\n    /** @internal */\n    get volume() {\n        return this._volume.targetValue;\n    }\n    /** @internal */\n    set volume(value) {\n        this._volume.targetValue = value;\n    }\n    get _destinationNode() {\n        return this.engine._audioDestination;\n    }\n    /** @internal */\n    getClassName() {\n        return \"_WebAudioMainOut\";\n    }\n    /** @internal */\n    setVolume(value, options = null) {\n        this._volume.setTargetValue(value, options);\n    }\n    _setGainNode(gainNode) {\n        if (this._gainNode === gainNode) {\n            return;\n        }\n        this._gainNode?.disconnect();\n        gainNode.connect(this._destinationNode);\n        this._volume = new _WebAudioParameterComponent(this.engine, gainNode.gain);\n        this._gainNode = gainNode;\n    }\n}\n//# sourceMappingURL=webAudioMainOut.js.map","import { EngineStore } from \"../../Engines/engineStore\";\n/**\n * Adds a UI button that starts the audio engine's underlying audio context when the user presses it.\n * @internal\n */\nexport class _WebAudioUnmuteUI {\n    /** @internal */\n    constructor(engine, parentElement) {\n        this._button = null;\n        this._enabled = true;\n        this._style = null;\n        this._onStateChanged = () => {\n            if (!this._button) {\n                return;\n            }\n            if (this._engine.state === \"running\") {\n                this._hide();\n            }\n            else {\n                this._show();\n            }\n        };\n        this._engine = engine;\n        const parent = parentElement || EngineStore.LastCreatedEngine?.getInputElement()?.parentElement || document.body;\n        const top = (parent?.offsetTop || 0) + 20;\n        this._style = document.createElement(\"style\");\n        this._style.appendChild(document.createTextNode(`.babylonUnmute{position:absolute;top:${top}px;margin-left:20px;height:40px;width:60px;background-color:rgba(51,51,51,0.7);background-image:url(\"data:image/svg+xml;charset=UTF-8,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2239%22%20height%3D%2232%22%20viewBox%3D%220%200%2039%2032%22%3E%3Cpath%20fill%3D%22white%22%20d%3D%22M9.625%2018.938l-0.031%200.016h-4.953q-0.016%200-0.031-0.016v-12.453q0-0.016%200.031-0.016h4.953q0.031%200%200.031%200.016v12.453zM12.125%207.688l8.719-8.703v27.453l-8.719-8.719-0.016-0.047v-9.938zM23.359%207.875l1.406-1.406%204.219%204.203%204.203-4.203%201.422%201.406-4.219%204.219%204.219%204.203-1.484%201.359-4.141-4.156-4.219%204.219-1.406-1.422%204.219-4.203z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");background-size:80%;background-repeat:no-repeat;background-position:center;background-position-y:4px;border:none;outline:none;transition:transform 0.125s ease-out;cursor:pointer;z-index:9999;}.babylonUnmute:hover{transform:scale(1.05)}`));\n        document.head.appendChild(this._style);\n        this._button = document.createElement(\"button\");\n        this._button.className = \"babylonUnmute\";\n        this._button.id = \"babylonUnmuteButton\";\n        this._button.addEventListener(\"click\", () => {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this._engine.unlockAsync();\n        });\n        parent.appendChild(this._button);\n        this._engine.stateChangedObservable.add(this._onStateChanged);\n    }\n    /** @internal */\n    dispose() {\n        this._button?.remove();\n        this._button = null;\n        this._style?.remove();\n        this._style = null;\n        this._engine.stateChangedObservable.removeCallback(this._onStateChanged);\n    }\n    /** @internal */\n    get enabled() {\n        return this._enabled;\n    }\n    set enabled(value) {\n        this._enabled = value;\n        if (value) {\n            if (this._engine.state !== \"running\") {\n                this._show();\n            }\n        }\n        else {\n            this._hide();\n        }\n    }\n    _show() {\n        if (!this._button) {\n            return;\n        }\n        this._button.style.display = \"block\";\n    }\n    _hide() {\n        if (!this._button) {\n            return;\n        }\n        this._button.style.display = \"none\";\n    }\n}\n//# sourceMappingURL=webAudioUnmuteUI.js.map","import { Observable } from \"../../Misc/observable\";\nimport { AudioEngineV2 } from \"../abstractAudio/audioEngineV2\";\nimport { _HasSpatialAudioListenerOptions } from \"../abstractAudio/subProperties/abstractSpatialAudioListener\";\nimport { _CreateSpatialAudioListener } from \"./subProperties/spatialWebAudioListener\";\nimport { _WebAudioMainOut } from \"./webAudioMainOut\";\nimport { _WebAudioUnmuteUI } from \"./webAudioUnmuteUI\";\n/**\n * Creates a new v2 audio engine that uses the WebAudio API.\n * @param options - The options for creating the audio engine.\n * @returns A promise that resolves with the created audio engine.\n */\nexport async function CreateAudioEngineAsync(options = {}) {\n    const engine = new _WebAudioEngine(options);\n    await engine._initAsync(options);\n    return engine;\n}\nconst FormatMimeTypes = {\n    aac: \"audio/aac\",\n    ac3: \"audio/ac3\",\n    flac: \"audio/flac\",\n    m4a: \"audio/mp4\",\n    mp3: 'audio/mpeg; codecs=\"mp3\"',\n    mp4: \"audio/mp4\",\n    ogg: 'audio/ogg; codecs=\"vorbis\"',\n    wav: \"audio/wav\",\n    webm: 'audio/webm; codecs=\"vorbis\"',\n};\n/** @internal */\nexport class _WebAudioEngine extends AudioEngineV2 {\n    /** @internal */\n    constructor(options = {}) {\n        super(options);\n        this._audioContextStarted = false;\n        this._destinationNode = null;\n        this._invalidFormats = new Set();\n        this._isUpdating = false;\n        this._listener = null;\n        this._listenerAutoUpdate = true;\n        this._listenerMinUpdateTime = 0;\n        this._pauseCalled = false;\n        this._resumeOnInteraction = true;\n        this._resumeOnPause = true;\n        this._resumeOnPauseRetryInterval = 1000;\n        this._resumeOnPauseTimerId = null;\n        this._resumePromise = null;\n        this._silentHtmlAudio = null;\n        this._unmuteUI = null;\n        this._updateObservable = null;\n        this._validFormats = new Set();\n        this._volume = 1;\n        /** @internal */\n        this._isUsingOfflineAudioContext = false;\n        /** @internal */\n        this.isReadyPromise = new Promise((resolve) => {\n            this._resolveIsReadyPromise = resolve;\n        });\n        /** @internal */\n        this.stateChangedObservable = new Observable();\n        /** @internal */\n        this.userGestureObservable = new Observable();\n        this._initAudioContextAsync = async () => {\n            this._audioContext.addEventListener(\"statechange\", this._onAudioContextStateChange);\n            this._mainOut = new _WebAudioMainOut(this);\n            this._mainOut.volume = this._volume;\n            await this.createMainBusAsync(\"default\");\n        };\n        this._onAudioContextStateChange = () => {\n            if (this.state === \"running\") {\n                clearInterval(this._resumeOnPauseTimerId);\n                this._audioContextStarted = true;\n                this._resumePromise = null;\n            }\n            if (this.state === \"suspended\" || this.state === \"interrupted\") {\n                if (this._audioContextStarted && this._resumeOnPause && !this._pauseCalled) {\n                    clearInterval(this._resumeOnPauseTimerId);\n                    this._resumeOnPauseTimerId = setInterval(() => {\n                        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                        this.resumeAsync();\n                    }, this._resumeOnPauseRetryInterval);\n                }\n            }\n            this.stateChangedObservable.notifyObservers(this.state);\n        };\n        this._onUserGestureAsync = async () => {\n            if (this._resumeOnInteraction) {\n                await this._audioContext.resume();\n            }\n            // On iOS the ringer switch must be turned on for WebAudio to play.\n            // This gets WebAudio to play with the ringer switch turned off by playing an HTMLAudioElement.\n            if (!this._silentHtmlAudio) {\n                this._silentHtmlAudio = document.createElement(\"audio\");\n                const audio = this._silentHtmlAudio;\n                audio.controls = false;\n                audio.preload = \"auto\";\n                audio.loop = true;\n                // Wave data for 0.0001 seconds of silence.\n                audio.src = \"data:audio/wav;base64,UklGRjAAAABXQVZFZm10IBAAAAABAAEAgLsAAAB3AQACABAAZGF0YQwAAAAAAAEA/v8CAP//AQA=\";\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                audio.play();\n            }\n            this.userGestureObservable.notifyObservers();\n        };\n        this._startUpdating = () => {\n            if (this._isUpdating) {\n                return;\n            }\n            this._isUpdating = true;\n            if (this.state === \"running\") {\n                this._update();\n            }\n            else {\n                const callback = () => {\n                    if (this.state === \"running\") {\n                        this._update();\n                        this.stateChangedObservable.removeCallback(callback);\n                    }\n                };\n                this.stateChangedObservable.add(callback);\n            }\n        };\n        this._update = () => {\n            if (this._updateObservable?.hasObservers()) {\n                this._updateObservable.notifyObservers();\n                requestAnimationFrame(this._update);\n            }\n            else {\n                this._isUpdating = false;\n            }\n        };\n        if (typeof options.listenerAutoUpdate === \"boolean\") {\n            this._listenerAutoUpdate = options.listenerAutoUpdate;\n        }\n        if (typeof options.listenerMinUpdateTime === \"number\") {\n            this._listenerMinUpdateTime = options.listenerMinUpdateTime;\n        }\n        this._volume = options.volume ?? 1;\n        if (options.audioContext) {\n            this._isUsingOfflineAudioContext = options.audioContext instanceof OfflineAudioContext;\n            this._audioContext = options.audioContext;\n        }\n        else {\n            this._audioContext = new AudioContext();\n        }\n        if (!options.disableDefaultUI) {\n            this._unmuteUI = new _WebAudioUnmuteUI(this, options.defaultUIParentElement);\n        }\n    }\n    /** @internal */\n    async _initAsync(options) {\n        this._resumeOnInteraction = typeof options.resumeOnInteraction === \"boolean\" ? options.resumeOnInteraction : true;\n        this._resumeOnPause = typeof options.resumeOnPause === \"boolean\" ? options.resumeOnPause : true;\n        this._resumeOnPauseRetryInterval = options.resumeOnPauseRetryInterval ?? 1000;\n        document.addEventListener(\"click\", this._onUserGestureAsync);\n        await this._initAudioContextAsync();\n        if (_HasSpatialAudioListenerOptions(options)) {\n            this._listener = _CreateSpatialAudioListener(this, this._listenerAutoUpdate, this._listenerMinUpdateTime);\n            this._listener.setOptions(options);\n        }\n        this._resolveIsReadyPromise();\n    }\n    /** @internal */\n    get currentTime() {\n        return this._audioContext.currentTime ?? 0;\n    }\n    /** @internal */\n    get _inNode() {\n        return this._audioContext.destination;\n    }\n    /** @internal */\n    get mainOut() {\n        return this._mainOut;\n    }\n    /** @internal */\n    get listener() {\n        return this._listener ?? (this._listener = _CreateSpatialAudioListener(this, this._listenerAutoUpdate, this._listenerMinUpdateTime));\n    }\n    /** @internal */\n    get state() {\n        // Always return \"running\" for OfflineAudioContext so sound `play` calls work while the context is suspended.\n        return this._isUsingOfflineAudioContext ? \"running\" : this._audioContext.state;\n    }\n    /** @internal */\n    get volume() {\n        return this._volume;\n    }\n    /** @internal */\n    set volume(value) {\n        if (this._volume === value) {\n            return;\n        }\n        this._volume = value;\n        if (this._mainOut) {\n            this._mainOut.volume = value;\n        }\n    }\n    /**\n     * This property should only be used by the legacy audio engine.\n     * @internal\n     * */\n    get _audioDestination() {\n        return this._destinationNode ? this._destinationNode : (this._destinationNode = this._audioContext.destination);\n    }\n    set _audioDestination(value) {\n        this._destinationNode = value;\n    }\n    /**\n     * This property should only be used by the legacy audio engine.\n     * @internal\n     */\n    get _unmuteUIEnabled() {\n        return this._unmuteUI ? this._unmuteUI.enabled : false;\n    }\n    set _unmuteUIEnabled(value) {\n        if (this._unmuteUI) {\n            this._unmuteUI.enabled = value;\n        }\n    }\n    /** @internal */\n    async createBusAsync(name, options = {}) {\n        const module = await import(\"./webAudioBus\");\n        const bus = new module._WebAudioBus(name, this, options);\n        await bus._initAsync(options);\n        return bus;\n    }\n    /** @internal */\n    async createMainBusAsync(name, options = {}) {\n        const module = await import(\"./webAudioMainBus\");\n        const bus = new module._WebAudioMainBus(name, this);\n        await bus._initAsync(options);\n        return bus;\n    }\n    /** @internal */\n    async createMicrophoneSoundSourceAsync(name, options) {\n        let mediaStream;\n        try {\n            mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });\n        }\n        catch (e) {\n            throw new Error(\"Unable to access microphone: \" + e);\n        }\n        return await this.createSoundSourceAsync(name, new MediaStreamAudioSourceNode(this._audioContext, { mediaStream }), {\n            outBusAutoDefault: false,\n            ...options,\n        });\n    }\n    /** @internal */\n    async createSoundAsync(name, source, options = {}) {\n        const module = await import(\"./webAudioStaticSound\");\n        const sound = new module._WebAudioStaticSound(name, this, options);\n        await sound._initAsync(source, options);\n        return sound;\n    }\n    /** @internal */\n    async createSoundBufferAsync(source, options = {}) {\n        const module = await import(\"./webAudioStaticSound\");\n        const soundBuffer = new module._WebAudioStaticSoundBuffer(this);\n        await soundBuffer._initAsync(source, options);\n        return soundBuffer;\n    }\n    /** @internal */\n    async createSoundSourceAsync(name, source, options = {}) {\n        const module = await import(\"./webAudioSoundSource\");\n        const soundSource = new module._WebAudioSoundSource(name, source, this, options);\n        await soundSource._initAsync(options);\n        return soundSource;\n    }\n    /** @internal */\n    async createStreamingSoundAsync(name, source, options = {}) {\n        const module = await import(\"./webAudioStreamingSound\");\n        const sound = new module._WebAudioStreamingSound(name, this, options);\n        await sound._initAsync(source, options);\n        return sound;\n    }\n    /** @internal */\n    dispose() {\n        super.dispose();\n        this._listener?.dispose();\n        this._listener = null;\n        // Note that OfflineAudioContext does not have a `close` method.\n        if (this._audioContext.state !== \"closed\" && !this._isUsingOfflineAudioContext) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this._audioContext.close();\n        }\n        document.removeEventListener(\"click\", this._onUserGestureAsync);\n        this._audioContext.removeEventListener(\"statechange\", this._onAudioContextStateChange);\n        this._silentHtmlAudio?.remove();\n        this._updateObservable?.clear();\n        this._updateObservable = null;\n        this._unmuteUI?.dispose();\n        this._unmuteUI = null;\n        this.stateChangedObservable.clear();\n    }\n    /** @internal */\n    flagInvalidFormat(format) {\n        this._invalidFormats.add(format);\n    }\n    /** @internal */\n    isFormatValid(format) {\n        if (this._validFormats.has(format)) {\n            return true;\n        }\n        if (this._invalidFormats.has(format)) {\n            return false;\n        }\n        const mimeType = FormatMimeTypes[format];\n        if (mimeType === undefined) {\n            return false;\n        }\n        const audio = new Audio();\n        if (audio.canPlayType(mimeType) === \"\") {\n            this._invalidFormats.add(format);\n            return false;\n        }\n        this._validFormats.add(format);\n        return true;\n    }\n    /** @internal */\n    async pauseAsync() {\n        await this._audioContext.suspend();\n        this._pauseCalled = true;\n    }\n    /** @internal */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    resumeAsync() {\n        this._pauseCalled = false;\n        if (this._resumePromise) {\n            return this._resumePromise;\n        }\n        this._resumePromise = this._audioContext.resume();\n        return this._resumePromise;\n    }\n    /** @internal */\n    setVolume(value, options = null) {\n        if (this._mainOut) {\n            this._mainOut.setVolume(value, options);\n        }\n        else {\n            throw new Error(\"Main output not initialized yet.\");\n        }\n    }\n    /** @internal */\n    _addMainBus(mainBus) {\n        super._addMainBus(mainBus);\n    }\n    /** @internal */\n    _removeMainBus(mainBus) {\n        super._removeMainBus(mainBus);\n    }\n    /** @internal */\n    _addNode(node) {\n        super._addNode(node);\n    }\n    /** @internal */\n    _removeNode(node) {\n        super._removeNode(node);\n    }\n    /** @internal */\n    _addUpdateObserver(callback) {\n        if (!this._updateObservable) {\n            this._updateObservable = new Observable();\n        }\n        this._updateObservable.add(callback);\n        this._startUpdating();\n    }\n    _removeUpdateObserver(callback) {\n        if (this._updateObservable) {\n            this._updateObservable.removeCallback(callback);\n        }\n    }\n}\n//# sourceMappingURL=webAudioEngine.js.map","import { Observable } from \"../Misc/observable\";\nimport { AbstractEngine } from \"../Engines/abstractEngine\";\nimport { _WebAudioEngine } from \"../AudioV2/webAudio/webAudioEngine\";\n// Sets the default audio engine to Babylon.js\nAbstractEngine.AudioEngineFactory = (hostElement, audioContext, audioDestination) => {\n    return new AudioEngine(hostElement, audioContext, audioDestination);\n};\n/**\n * This represents the default audio engine used in babylon.\n * It is responsible to play, synchronize and analyse sounds throughout the  application.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\n */\nexport class AudioEngine {\n    /**\n     * The master gain node defines the global audio volume of your audio engine.\n     */\n    get masterGain() {\n        return this._masterGain;\n    }\n    set masterGain(value) {\n        this._masterGain = this._v2.mainOut._inNode = value;\n    }\n    /**\n     * Defines if the audio engine relies on a custom unlocked button.\n     * In this case, the embedded button will not be displayed.\n     */\n    get useCustomUnlockedButton() {\n        return this._useCustomUnlockedButton;\n    }\n    set useCustomUnlockedButton(value) {\n        this._useCustomUnlockedButton = value;\n        this._v2._unmuteUIEnabled = !value;\n    }\n    /**\n     * Gets the current AudioContext if available.\n     */\n    get audioContext() {\n        if (this._v2.state === \"running\") {\n            // Do not wait for the promise to unlock.\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this._triggerRunningStateAsync();\n        }\n        return this._v2._audioContext;\n    }\n    /**\n     * Instantiates a new audio engine.\n     *\n     * @param hostElement defines the host element where to display the mute icon if necessary\n     * @param audioContext defines the audio context to be used by the audio engine\n     * @param audioDestination defines the audio destination node to be used by audio engine\n     */\n    constructor(hostElement = null, audioContext = null, audioDestination = null) {\n        this._audioContext = null;\n        this._tryToRun = false;\n        this._useCustomUnlockedButton = false;\n        /**\n         * Gets whether the current host supports Web Audio and thus could create AudioContexts.\n         */\n        this.canUseWebAudio = true;\n        /**\n         * Defines if Babylon should emit a warning if WebAudio is not supported.\n         */\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        this.WarnedWebAudioUnsupported = false;\n        /**\n         * Gets whether or not mp3 are supported by your browser.\n         */\n        this.isMP3supported = false;\n        /**\n         * Gets whether or not ogg are supported by your browser.\n         */\n        this.isOGGsupported = false;\n        /**\n         * Gets whether audio has been unlocked on the device.\n         * Some Browsers have strong restrictions about Audio and won't autoplay unless\n         * a user interaction has happened.\n         */\n        this.unlocked = false;\n        /**\n         * Event raised when audio has been unlocked on the browser.\n         */\n        this.onAudioUnlockedObservable = new Observable();\n        /**\n         * Event raised when audio has been locked on the browser.\n         */\n        this.onAudioLockedObservable = new Observable();\n        const v2 = new _WebAudioEngine({\n            audioContext: audioContext ? audioContext : undefined,\n            defaultUIParentElement: hostElement?.parentElement ? hostElement.parentElement : undefined,\n        });\n        // Historically the unmute button is disabled until a sound tries to play and can't, which results in a call\n        // to `AudioEngine.lock()`, which is where the unmute button is enabled if no custom UI is requested.\n        v2._unmuteUIEnabled = false;\n        this._masterGain = new GainNode(v2._audioContext);\n        v2._audioDestination = audioDestination;\n        v2.stateChangedObservable.add((state) => {\n            if (state === \"running\") {\n                this.unlocked = true;\n                this.onAudioUnlockedObservable.notifyObservers(this);\n            }\n            else {\n                this.unlocked = false;\n                this.onAudioLockedObservable.notifyObservers(this);\n            }\n        });\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n        v2._initAsync({ resumeOnInteraction: false }).then(() => {\n            const mainBusOutNode = v2.defaultMainBus._outNode;\n            if (mainBusOutNode) {\n                mainBusOutNode.disconnect(v2.mainOut._inNode);\n                mainBusOutNode.connect(this._masterGain);\n            }\n            v2.mainOut._inNode = this._masterGain;\n            v2.stateChangedObservable.notifyObservers(v2.state);\n        });\n        this.isMP3supported = v2.isFormatValid(\"mp3\");\n        this.isOGGsupported = v2.isFormatValid(\"ogg\");\n        this._v2 = v2;\n    }\n    /**\n     * Flags the audio engine in Locked state.\n     * This happens due to new browser policies preventing audio to autoplay.\n     */\n    lock() {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this._v2._audioContext.suspend();\n        if (!this._useCustomUnlockedButton) {\n            this._v2._unmuteUIEnabled = true;\n        }\n    }\n    /**\n     * Unlocks the audio engine once a user action has been done on the dom.\n     * This is helpful to resume play once browser policies have been satisfied.\n     */\n    unlock() {\n        if (this._audioContext?.state === \"running\") {\n            if (!this.unlocked) {\n                // Notify users that the audio stack is unlocked/unmuted\n                this.unlocked = true;\n                this.onAudioUnlockedObservable.notifyObservers(this);\n            }\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this._triggerRunningStateAsync();\n    }\n    /** @internal */\n    _resumeAudioContextOnStateChange() {\n        this._audioContext?.addEventListener(\"statechange\", () => {\n            if (this.unlocked && this._audioContext?.state !== \"running\") {\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                this._resumeAudioContextAsync();\n            }\n        }, {\n            once: true,\n            passive: true,\n            signal: AbortSignal.timeout(3000),\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    _resumeAudioContextAsync() {\n        if (this._v2._isUsingOfflineAudioContext) {\n            return Promise.resolve();\n        }\n        return this._v2._audioContext.resume();\n    }\n    /**\n     * Destroy and release the resources associated with the audio context.\n     */\n    dispose() {\n        this._v2.dispose();\n        this.onAudioUnlockedObservable.clear();\n        this.onAudioLockedObservable.clear();\n    }\n    /**\n     * Gets the global volume sets on the master gain.\n     * @returns the global volume if set or -1 otherwise\n     */\n    getGlobalVolume() {\n        return this.masterGain.gain.value;\n    }\n    /**\n     * Sets the global volume of your experience (sets on the master gain).\n     * @param newVolume Defines the new global volume of the application\n     */\n    setGlobalVolume(newVolume) {\n        this.masterGain.gain.value = newVolume;\n    }\n    /**\n     * Connect the audio engine to an audio analyser allowing some amazing\n     * synchronization between the sounds/music and your visualization (VuMeter for instance).\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-the-analyser\n     * @param analyser The analyser to connect to the engine\n     */\n    connectToAnalyser(analyser) {\n        if (this._connectedAnalyser) {\n            this._connectedAnalyser.stopDebugCanvas();\n        }\n        this._connectedAnalyser = analyser;\n        this.masterGain.disconnect();\n        this._connectedAnalyser.connectAudioNodes(this.masterGain, this._v2._audioContext.destination);\n    }\n    async _triggerRunningStateAsync() {\n        if (this._tryToRun) {\n            return;\n        }\n        this._tryToRun = true;\n        await this._resumeAudioContextAsync();\n        this._tryToRun = false;\n        this.unlocked = true;\n        this.onAudioUnlockedObservable.notifyObservers(this);\n    }\n}\n//# sourceMappingURL=audioEngine.js.map"],"names":["AudioEngineV2","constructor","options","this","_mainBuses","Set","_nodes","_defaultMainBus","_parameterRampDuration","parameterRampDuration","defaultMainBus","size","Array","from","value","Math","max","dispose","nodeIt","values","next","done","clear","unlockAsync","resumeAsync","_addMainBus","mainBus","add","_addNode","_removeMainBus","delete","_removeNode","node","_SpatialAudioListenerDefaults","position","Vector3","Zero","rotation","rotationQuaternion","Quaternion","AbstractSpatialAudioListener","_SpatialAudioAttacherComponent","spatialAudioNode","_attachmentType","_position","_rotationQuaternion","_sceneNode","_useBoundingBox","detach","_spatialAudioNode","isAttached","attach","sceneNode","useBoundingBox","attachmentType","onDisposeObservable","removeCallback","update","getBoundingInfo","copyFrom","boundingBox","centerWorld","getWorldMatrix","getTranslationToRef","_updatePosition","decompose","undefined","_updateRotation","_SpatialAudioListener","super","_attacherComponent","setOptions","listenerMinUpdateTime","minUpdateTime","listenerPosition","clone","listenerRotationQuaternion","listenerRotation","_SpatialWebAudioUpdaterComponent","parent","autoUpdate","_autoUpdate","_lastUpdateTime","skipUpdate","now","PrecisionDate","Now","requestAnimationFrame","_FileExtensionRegex","RegExp","CurveLength","TmpLineValues","Float32Array","TmpCurveValues","ExpCurve","LogCurve","_GetAudioParamCurveValues","shape","to","normalizedCurve","increment","x","i","exp","GetExpCurve","Error","log10","GetLogCurve","direction","sign","range","abs","length","j","_CleanUrl","url","replace","_WebAudioParameterComponent","engine","param","_deferredRampOptions","duration","_deferredTargetValue","_isObservingUpdates","_rampEndTime","_applyDeferredRamp","_engine","currentTime","setTargetValue","_param","_targetValue","isRamping","targetValue","_clearDeferredRamp","startTime","_deferRamp","setValueAtTime","cancelScheduledValues","setValueCurveAtTime","_addUpdateObserver","_removeUpdateObserver","TmpMatrix","Matrix","TmpQuaternion","TmpVector1","TmpVector2","_CreateSpatialAudioListener","listener","_audioContext","forwardX","forwardY","forwardZ","positionX","positionY","positionZ","upX","upY","upZ","_SpatialWebAudioListener","_SpatialWebAudioListenerFallback","_AbstractSpatialWebAudioListener","_lastPosition","_lastRotation","_lastRotationQuaternion","_listener","_updaterComponent","equalsWithEpsilon","_setWebAudioPosition","FromEulerAnglesToRef","y","z","FromQuaternionToRef","TransformNormalToRef","RightHandedForwardReadOnly","Up","_setWebAudioOrientation","_forwardX","_forwardY","_forwardZ","_positionX","_positionY","_positionZ","_upX","_upY","_upZ","forward","up","setPosition","setOrientation","AudioNodeType","AbstractAudioNode","nodeType","Observable","_upstreamNodes","_downstreamNodes","_disconnect","notifyObservers","_connect","has","_onConnect","_onDisconnect","AbstractNamedAudioNode","name","onNameChangedObservable","_name","newName","oldName","_MainAudioOut","_WebAudioMainOut","_setGainNode","GainNode","_volume","_gainNode","disconnect","_destinationNode","_inNode","volume","_audioDestination","getClassName","setVolume","gainNode","connect","gain","_WebAudioUnmuteUI","parentElement","_button","_enabled","_style","_onStateChanged","state","_hide","_show","EngineStore","LastCreatedEngine","getInputElement","document","body","top","offsetTop","createElement","appendChild","createTextNode","head","className","id","addEventListener","stateChangedObservable","remove","enabled","style","display","FormatMimeTypes","aac","ac3","flac","m4a","mp3","mp4","ogg","wav","webm","_WebAudioEngine","_audioContextStarted","_invalidFormats","_isUpdating","_listenerAutoUpdate","_listenerMinUpdateTime","_pauseCalled","_resumeOnInteraction","_resumeOnPause","_resumeOnPauseRetryInterval","_resumeOnPauseTimerId","_resumePromise","_silentHtmlAudio","_unmuteUI","_updateObservable","_validFormats","_isUsingOfflineAudioContext","isReadyPromise","Promise","resolve","_resolveIsReadyPromise","userGestureObservable","_initAudioContextAsync","async","_onAudioContextStateChange","_mainOut","createMainBusAsync","clearInterval","setInterval","_onUserGestureAsync","resume","audio","controls","preload","loop","src","play","_startUpdating","_update","callback","hasObservers","listenerAutoUpdate","audioContext","OfflineAudioContext","AudioContext","disableDefaultUI","defaultUIParentElement","_initAsync","resumeOnInteraction","resumeOnPause","resumeOnPauseRetryInterval","listenerEnabled","_HasSpatialAudioListenerOptions","destination","mainOut","_unmuteUIEnabled","createBusAsync","bus","import","_WebAudioBus","_WebAudioMainBus","createMicrophoneSoundSourceAsync","mediaStream","navigator","mediaDevices","getUserMedia","e","createSoundSourceAsync","MediaStreamAudioSourceNode","outBusAutoDefault","createSoundAsync","source","sound","_WebAudioStaticSound","createSoundBufferAsync","soundBuffer","_WebAudioStaticSoundBuffer","soundSource","_WebAudioSoundSource","createStreamingSoundAsync","_WebAudioStreamingSound","close","removeEventListener","flagInvalidFormat","format","isFormatValid","mimeType","Audio","canPlayType","pauseAsync","suspend","AbstractEngine","AudioEngineFactory","hostElement","audioDestination","AudioEngine","masterGain","_masterGain","_v2","useCustomUnlockedButton","_useCustomUnlockedButton","_triggerRunningStateAsync","_tryToRun","canUseWebAudio","WarnedWebAudioUnsupported","isMP3supported","isOGGsupported","unlocked","onAudioUnlockedObservable","onAudioLockedObservable","v2","then","mainBusOutNode","_outNode","lock","unlock","_resumeAudioContextOnStateChange","_resumeAudioContextAsync","once","passive","signal","AbortSignal","timeout","getGlobalVolume","setGlobalVolume","newVolume","connectToAnalyser","analyser","_connectedAnalyser","stopDebugCanvas","connectAudioNodes"],"mappings":"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"}