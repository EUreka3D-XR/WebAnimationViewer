{"version":3,"file":"abstractSoundInstance-CktoICHN.esm.min.js","sources":["../../../../../dev/core/dist/AudioV2/abstractAudio/abstractSound.js","../../../../../dev/core/dist/AudioV2/abstractAudio/abstractSoundInstance.js"],"sourcesContent":["import { Observable } from \"../../Misc/observable\";\nimport { AbstractSoundSource } from \"./abstractSoundSource\";\n/**\n * Abstract class representing a sound in the audio engine.\n */\nexport class AbstractSound extends AbstractSoundSource {\n    constructor(name, engine) {\n        super(name, engine, 3 /* AudioNodeType.HAS_INPUTS_AND_OUTPUTS */); // Inputs are for instances.\n        this._newestInstance = null;\n        this._privateInstances = new Set();\n        this._state = 1 /* SoundState.Stopped */;\n        this._instances = this._privateInstances;\n        /**\n         * Observable for when the sound stops playing.\n         */\n        this.onEndedObservable = new Observable();\n        this._onInstanceEnded = (instance) => {\n            if (this._newestInstance === instance) {\n                this._newestInstance = null;\n            }\n            this._privateInstances.delete(instance);\n            if (this._instances.size === 0) {\n                this._state = 1 /* SoundState.Stopped */;\n                this.onEndedObservable.notifyObservers(this);\n            }\n        };\n    }\n    /**\n     * Whether the sound should start playing automatically. Defaults to `false`.\n     */\n    get autoplay() {\n        return this._options.autoplay;\n    }\n    /**\n     * The current playback time of the sound, in seconds.\n     */\n    get currentTime() {\n        const instance = this._getNewestInstance();\n        return instance ? instance.currentTime : 0;\n    }\n    set currentTime(value) {\n        this.startOffset = value;\n        const instance = this._getNewestInstance();\n        if (instance) {\n            instance.currentTime = value;\n        }\n    }\n    /**\n     * Whether the sound should loop. Defaults to `false`.\n     */\n    get loop() {\n        return this._options.loop;\n    }\n    set loop(value) {\n        this._options.loop = value;\n    }\n    /**\n     * The maximum number of instances that can play at the same time. Defaults to `Infinity`.\n     */\n    get maxInstances() {\n        return this._options.maxInstances;\n    }\n    set maxInstances(value) {\n        this._options.maxInstances = value;\n    }\n    /**\n     * The time within the sound buffer to start playing at, in seconds. Defaults to `0`.\n     */\n    get startOffset() {\n        return this._options.startOffset;\n    }\n    set startOffset(value) {\n        this._options.startOffset = value;\n    }\n    /**\n     * The state of the sound.\n     */\n    get state() {\n        return this._state;\n    }\n    /**\n     * Releases associated resources.\n     */\n    dispose() {\n        super.dispose();\n        this.stop();\n        this._newestInstance = null;\n        this._privateInstances.clear();\n        this.onEndedObservable.clear();\n    }\n    /**\n     * Pauses the sound.\n     */\n    pause() {\n        const it = this._instances.values();\n        for (let next = it.next(); !next.done; next = it.next()) {\n            next.value.pause();\n        }\n        this._state = 5 /* SoundState.Paused */;\n    }\n    /**\n     * Resumes the sound.\n     */\n    resume() {\n        if (this._state !== 5 /* SoundState.Paused */) {\n            return;\n        }\n        const it = this._instances.values();\n        for (let next = it.next(); !next.done; next = it.next()) {\n            next.value.resume();\n        }\n        this._state = 3 /* SoundState.Started */;\n    }\n    _beforePlay(instance) {\n        if (this.state === 5 /* SoundState.Paused */ && this._instances.size > 0) {\n            this.resume();\n            return;\n        }\n        instance.onEndedObservable.addOnce(this._onInstanceEnded);\n        this._privateInstances.add(instance);\n        this._newestInstance = instance;\n    }\n    _afterPlay(instance) {\n        this._state = instance.state;\n    }\n    _getNewestInstance() {\n        if (this._instances.size === 0) {\n            return null;\n        }\n        if (!this._newestInstance) {\n            const it = this._instances.values();\n            for (let next = it.next(); !next.done; next = it.next()) {\n                this._newestInstance = next.value;\n            }\n        }\n        return this._newestInstance;\n    }\n    _setState(state) {\n        this._state = state;\n    }\n    _stopExcessInstances() {\n        if (this.maxInstances < Infinity) {\n            const numberOfInstancesToStop = Array.from(this._instances).filter((instance) => instance.state === 3 /* SoundState.Started */).length - this.maxInstances;\n            const it = this._instances.values();\n            for (let i = 0; i < numberOfInstancesToStop; i++) {\n                const instance = it.next().value;\n                instance.stop();\n            }\n        }\n    }\n}\n//# sourceMappingURL=abstractSound.js.map","import { Observable } from \"../../Misc/observable\";\nimport { AbstractAudioNode } from \"./abstractAudioNode\";\n/** @internal */\nexport class _AbstractSoundInstance extends AbstractAudioNode {\n    constructor(sound) {\n        super(sound.engine, 2 /* AudioNodeType.HAS_OUTPUTS */);\n        this._state = 1 /* SoundState.Stopped */;\n        /** Observable triggered when the sound instance's playback ends */\n        this.onEndedObservable = new Observable();\n        /** Observable triggered if the sound instance encounters an error and can not be played */\n        this.onErrorObservable = new Observable();\n        /** Observable triggered when the sound instance's state changes */\n        this.onStateChangedObservable = new Observable();\n        this._sound = sound;\n    }\n    /** The playback state of the sound instance */\n    get state() {\n        return this._state;\n    }\n    /** @internal */\n    dispose() {\n        super.dispose();\n        this.stop();\n        this.onEndedObservable.clear();\n        this.onStateChangedObservable.clear();\n    }\n    _setState(value) {\n        if (this._state === value) {\n            return;\n        }\n        this._state = value;\n        this.onStateChangedObservable.notifyObservers(this);\n    }\n}\n//# sourceMappingURL=abstractSoundInstance.js.map"],"names":["AbstractSound","AbstractSoundSource","constructor","name","engine","super","this","_newestInstance","_privateInstances","Set","_state","_instances","onEndedObservable","Observable","_onInstanceEnded","instance","delete","size","notifyObservers","autoplay","_options","currentTime","_getNewestInstance","value","startOffset","loop","maxInstances","state","dispose","stop","clear","pause","it","values","next","done","resume","_beforePlay","addOnce","add","_afterPlay","_setState","_stopExcessInstances","Infinity","numberOfInstancesToStop","Array","from","filter","length","i","_AbstractSoundInstance","AbstractAudioNode","sound","onErrorObservable","onStateChangedObservable","_sound"],"mappings":"+JAKO,MAAMA,UAAsBC,EAC/B,WAAAC,CAAYC,EAAMC,GACdC,MAAMF,EAAMC,EAAQ,GACpBE,KAAKC,gBAAkB,KACvBD,KAAKE,kBAAoB,IAAIC,IAC7BH,KAAKI,OAAS,EACdJ,KAAKK,WAAaL,KAAKE,kBAIvBF,KAAKM,kBAAoB,IAAIC,EAC7BP,KAAKQ,iBAAoBC,IACjBT,KAAKC,kBAAoBQ,IACzBT,KAAKC,gBAAkB,MAE3BD,KAAKE,kBAAkBQ,OAAOD,GACD,IAAzBT,KAAKK,WAAWM,OAChBX,KAAKI,OAAS,EACdJ,KAAKM,kBAAkBM,gBAAgBZ,OAGvD,CAII,YAAIa,GACA,OAAOb,KAAKc,SAASD,QAC7B,CAII,eAAIE,GACA,MAAMN,EAAWT,KAAKgB,qBACtB,OAAOP,EAAWA,EAASM,YAAc,CACjD,CACI,eAAIA,CAAYE,GACZjB,KAAKkB,YAAcD,EACnB,MAAMR,EAAWT,KAAKgB,qBAClBP,IACAA,EAASM,YAAcE,EAEnC,CAII,QAAIE,GACA,OAAOnB,KAAKc,SAASK,IAC7B,CACI,QAAIA,CAAKF,GACLjB,KAAKc,SAASK,KAAOF,CAC7B,CAII,gBAAIG,GACA,OAAOpB,KAAKc,SAASM,YAC7B,CACI,gBAAIA,CAAaH,GACbjB,KAAKc,SAASM,aAAeH,CACrC,CAII,eAAIC,GACA,OAAOlB,KAAKc,SAASI,WAC7B,CACI,eAAIA,CAAYD,GACZjB,KAAKc,SAASI,YAAcD,CACpC,CAII,SAAII,GACA,OAAOrB,KAAKI,MACpB,CAII,OAAAkB,GACIvB,MAAMuB,UACNtB,KAAKuB,OACLvB,KAAKC,gBAAkB,KACvBD,KAAKE,kBAAkBsB,QACvBxB,KAAKM,kBAAkBkB,OAC/B,CAII,KAAAC,GACI,MAAMC,EAAK1B,KAAKK,WAAWsB,SAC3B,IAAK,IAAIC,EAAOF,EAAGE,QAASA,EAAKC,KAAMD,EAAOF,EAAGE,OAC7CA,EAAKX,MAAMQ,QAEfzB,KAAKI,OAAS,CACtB,CAII,MAAA0B,GACI,GAAoB,IAAhB9B,KAAKI,OACL,OAEJ,MAAMsB,EAAK1B,KAAKK,WAAWsB,SAC3B,IAAK,IAAIC,EAAOF,EAAGE,QAASA,EAAKC,KAAMD,EAAOF,EAAGE,OAC7CA,EAAKX,MAAMa,SAEf9B,KAAKI,OAAS,CACtB,CACI,WAAA2B,CAAYtB,GACW,IAAfT,KAAKqB,OAAuCrB,KAAKK,WAAWM,KAAO,EACnEX,KAAK8B,UAGTrB,EAASH,kBAAkB0B,QAAQhC,KAAKQ,kBACxCR,KAAKE,kBAAkB+B,IAAIxB,GAC3BT,KAAKC,gBAAkBQ,EAC/B,CACI,UAAAyB,CAAWzB,GACPT,KAAKI,OAASK,EAASY,KAC/B,CACI,kBAAAL,GACI,GAA6B,IAAzBhB,KAAKK,WAAWM,KAChB,OAAO,KAEX,IAAKX,KAAKC,gBAAiB,CACvB,MAAMyB,EAAK1B,KAAKK,WAAWsB,SAC3B,IAAK,IAAIC,EAAOF,EAAGE,QAASA,EAAKC,KAAMD,EAAOF,EAAGE,OAC7C5B,KAAKC,gBAAkB2B,EAAKX,KAE5C,CACQ,OAAOjB,KAAKC,eACpB,CACI,SAAAkC,CAAUd,GACNrB,KAAKI,OAASiB,CACtB,CACI,oBAAAe,GACI,GAAIpC,KAAKoB,aAAeiB,IAAU,CAC9B,MAAMC,EAA0BC,MAAMC,KAAKxC,KAAKK,YAAYoC,QAAQhC,GAAgC,IAAnBA,EAASY,QAAsCqB,OAAS1C,KAAKoB,aACxIM,EAAK1B,KAAKK,WAAWsB,SAC3B,IAAK,IAAIgB,EAAI,EAAGA,EAAIL,EAAyBK,IAAK,CAC7BjB,EAAGE,OAAOX,MAClBM,MACzB,CACA,CACA,EClJO,MAAMqB,UAA+BC,EACxC,WAAAjD,CAAYkD,GACR/C,MAAM+C,EAAMhD,OAAQ,GACpBE,KAAKI,OAAS,EAEdJ,KAAKM,kBAAoB,IAAIC,EAE7BP,KAAK+C,kBAAoB,IAAIxC,EAE7BP,KAAKgD,yBAA2B,IAAIzC,EACpCP,KAAKiD,OAASH,CACtB,CAEI,SAAIzB,GACA,OAAOrB,KAAKI,MACpB,CAEI,OAAAkB,GACIvB,MAAMuB,UACNtB,KAAKuB,OACLvB,KAAKM,kBAAkBkB,QACvBxB,KAAKgD,yBAAyBxB,OACtC,CACI,SAAAW,CAAUlB,GACFjB,KAAKI,SAAWa,IAGpBjB,KAAKI,OAASa,EACdjB,KAAKgD,yBAAyBpC,gBAAgBZ,MACtD"}