import{c as e,V as s,Q as o,o as t,bK as r,bJ as n}from"./index-BeBPThKX.esm.min.js";import{GLTFLoader as a,ArrayItem as i}from"./glTFLoader-ASl42hNE.esm.min.js";import"./thinInstanceMesh-Dgva02_h.esm.min.js";import"./bone-4zSTwM2L.esm.min.js";import"./skeleton-BM6jc2S2.esm.min.js";import"./rawTexture-OHFtV4yv.esm.min.js";import"./assetContainer-C4iCgc7c.esm.min.js";import"./objectModelMapping-C_2yKgOV.esm.min.js";const c="EXT_mesh_gpu_instancing";class m{constructor(e){this.name=c,this._loader=e,this.enabled=this._loader.isExtensionUsed(c)}dispose(){this._loader=null}loadNodeAsync(r,n,c){return a.LoadExtensionAsync(r,n,this.name,(async(r,a)=>{this._loader._disableInstancedMesh++;const m=this._loader.loadNodeAsync(`/nodes/${n.index}`,n,c);if(this._loader._disableInstancedMesh--,!n._primitiveBabylonMeshes)return await m;const l=new Array;let d=0;const h=e=>{if(null==a.attributes[e])return void l.push(Promise.resolve(null));const s=i.Get(`${r}/attributes/${e}`,this._loader.gltf.accessors,a.attributes[e]);if(l.push(this._loader._loadFloatAccessorAsync(`/accessors/${s.bufferView}`,s)),0===d)d=s.count;else if(d!==s.count)throw new Error(`${r}/attributes: Instance buffer accessors do not have the same count.`)};return h("TRANSLATION"),h("ROTATION"),h("SCALE"),await m.then((async r=>{const[a,i,c]=await Promise.all(l),m=new Float32Array(16*d);e.Vector3[0].copyFromFloats(0,0,0),e.Quaternion[0].copyFromFloats(0,0,0,1),e.Vector3[1].copyFromFloats(1,1,1);for(let r=0;r<d;++r)a&&s.FromArrayToRef(a,3*r,e.Vector3[0]),i&&o.FromArrayToRef(i,4*r,e.Quaternion[0]),c&&s.FromArrayToRef(c,3*r,e.Vector3[1]),t.ComposeToRef(e.Vector3[1],e.Quaternion[0],e.Vector3[0],e.Matrix[0]),e.Matrix[0].copyToArray(m,16*r);for(const e of n._primitiveBabylonMeshes)e.thinInstanceSetBuffer("matrix",m,16,!0);return r}))}))}}r(c),n(c,!0,(e=>new m(e)));export{m as EXT_mesh_gpu_instancing};
//# sourceMappingURL=EXT_mesh_gpu_instancing-xhwGIE6C.esm.min.js.map
