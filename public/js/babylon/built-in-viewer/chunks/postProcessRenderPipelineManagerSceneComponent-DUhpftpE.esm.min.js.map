{"version":3,"file":"postProcessRenderPipelineManagerSceneComponent-DUhpftpE.esm.min.js","sources":["../../../../../dev/core/dist/PostProcesses/RenderPipeline/postProcessRenderPipelineManager.js","../../../../../dev/core/dist/PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent.js"],"sourcesContent":["import { Observable } from \"../../Misc/observable\";\n/**\n * PostProcessRenderPipelineManager class\n * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\n */\nexport class PostProcessRenderPipelineManager {\n    /**\n     * Initializes a PostProcessRenderPipelineManager\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\n     */\n    constructor() {\n        this._renderPipelines = {};\n        this._onNewPipelineAddedObservable = new Observable();\n        this._onPipelineRemovedObservable = new Observable();\n    }\n    /**\n     * An event triggered when a pipeline is added to the manager\n     */\n    get onNewPipelineAddedObservable() {\n        return this._onNewPipelineAddedObservable;\n    }\n    /**\n     * An event triggered when a pipeline is removed from the manager\n     */\n    get onPipelineRemovedObservable() {\n        return this._onPipelineRemovedObservable;\n    }\n    /**\n     * Gets the list of supported render pipelines\n     */\n    get supportedPipelines() {\n        const result = [];\n        for (const renderPipelineName in this._renderPipelines) {\n            if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\n                const pipeline = this._renderPipelines[renderPipelineName];\n                if (pipeline.isSupported) {\n                    result.push(pipeline);\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Adds a pipeline to the manager\n     * @param renderPipeline The pipeline to add\n     */\n    addPipeline(renderPipeline) {\n        this.removePipeline(renderPipeline._name);\n        this._renderPipelines[renderPipeline._name] = renderPipeline;\n        this._onNewPipelineAddedObservable.notifyObservers(renderPipeline);\n    }\n    /**\n     * Remove the pipeline from the manager\n     * @param renderPipelineName the name of the pipeline to remove\n     */\n    removePipeline(renderPipelineName) {\n        const pipeline = this._renderPipelines[renderPipelineName];\n        if (pipeline) {\n            this._onPipelineRemovedObservable.notifyObservers(pipeline);\n            delete this._renderPipelines[renderPipelineName];\n        }\n    }\n    /**\n     * Attaches a camera to the pipeline\n     * @param renderPipelineName The name of the pipeline to attach to\n     * @param cameras the camera to attach\n     * @param unique if the camera can be attached multiple times to the pipeline\n     */\n    attachCamerasToRenderPipeline(renderPipelineName, cameras, unique = false) {\n        const renderPipeline = this._renderPipelines[renderPipelineName];\n        if (!renderPipeline) {\n            return;\n        }\n        renderPipeline._attachCameras(cameras, unique);\n    }\n    /**\n     * Detaches a camera from the pipeline\n     * @param renderPipelineName The name of the pipeline to detach from\n     * @param cameras the camera to detach\n     */\n    detachCamerasFromRenderPipeline(renderPipelineName, cameras) {\n        const renderPipeline = this._renderPipelines[renderPipelineName];\n        if (!renderPipeline) {\n            return;\n        }\n        renderPipeline._detachCameras(cameras);\n    }\n    /**\n     * Enables an effect by name on a pipeline\n     * @param renderPipelineName the name of the pipeline to enable the effect in\n     * @param renderEffectName the name of the effect to enable\n     * @param cameras the cameras that the effect should be enabled on\n     */\n    enableEffectInPipeline(renderPipelineName, renderEffectName, cameras) {\n        const renderPipeline = this._renderPipelines[renderPipelineName];\n        if (!renderPipeline) {\n            return;\n        }\n        renderPipeline._enableEffect(renderEffectName, cameras);\n    }\n    /**\n     * Disables an effect by name on a pipeline\n     * @param renderPipelineName the name of the pipeline to disable the effect in\n     * @param renderEffectName the name of the effect to disable\n     * @param cameras the cameras that the effect should be disabled on\n     */\n    disableEffectInPipeline(renderPipelineName, renderEffectName, cameras) {\n        const renderPipeline = this._renderPipelines[renderPipelineName];\n        if (!renderPipeline) {\n            return;\n        }\n        renderPipeline._disableEffect(renderEffectName, cameras);\n    }\n    /**\n     * Updates the state of all contained render pipelines and disposes of any non supported pipelines\n     */\n    update() {\n        for (const renderPipelineName in this._renderPipelines) {\n            if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\n                const pipeline = this._renderPipelines[renderPipelineName];\n                if (!pipeline.isSupported) {\n                    pipeline.dispose();\n                    delete this._renderPipelines[renderPipelineName];\n                }\n                else {\n                    pipeline._update();\n                }\n            }\n        }\n    }\n    /** @internal */\n    _rebuild() {\n        for (const renderPipelineName in this._renderPipelines) {\n            if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\n                const pipeline = this._renderPipelines[renderPipelineName];\n                pipeline._rebuild();\n            }\n        }\n    }\n    /**\n     * Disposes of the manager and pipelines\n     */\n    dispose() {\n        for (const renderPipelineName in this._renderPipelines) {\n            if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\n                const pipeline = this._renderPipelines[renderPipelineName];\n                pipeline.dispose();\n            }\n        }\n    }\n}\n//# sourceMappingURL=postProcessRenderPipelineManager.js.map","import { SceneComponentConstants } from \"../../sceneComponent\";\nimport { PostProcessRenderPipelineManager } from \"./postProcessRenderPipelineManager\";\nimport { Scene } from \"../../scene\";\nObject.defineProperty(Scene.prototype, \"postProcessRenderPipelineManager\", {\n    get: function () {\n        if (!this._postProcessRenderPipelineManager) {\n            // Register the G Buffer component to the scene.\n            let component = this._getComponent(SceneComponentConstants.NAME_POSTPROCESSRENDERPIPELINEMANAGER);\n            if (!component) {\n                component = new PostProcessRenderPipelineManagerSceneComponent(this);\n                this._addComponent(component);\n            }\n            this._postProcessRenderPipelineManager = new PostProcessRenderPipelineManager();\n        }\n        return this._postProcessRenderPipelineManager;\n    },\n    enumerable: true,\n    configurable: true,\n});\n/**\n * Defines the Render Pipeline scene component responsible to rendering pipelines\n */\nexport class PostProcessRenderPipelineManagerSceneComponent {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    constructor(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_POSTPROCESSRENDERPIPELINEMANAGER;\n        this.scene = scene;\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    register() {\n        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER, this, this._gatherRenderTargets);\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    rebuild() {\n        if (this.scene._postProcessRenderPipelineManager) {\n            this.scene._postProcessRenderPipelineManager._rebuild();\n        }\n    }\n    /**\n     * Disposes the component and the associated resources\n     */\n    dispose() {\n        if (this.scene._postProcessRenderPipelineManager) {\n            this.scene._postProcessRenderPipelineManager.dispose();\n        }\n    }\n    _gatherRenderTargets() {\n        if (this.scene._postProcessRenderPipelineManager) {\n            this.scene._postProcessRenderPipelineManager.update();\n        }\n    }\n}\n//# sourceMappingURL=postProcessRenderPipelineManagerSceneComponent.js.map"],"names":["PostProcessRenderPipelineManager","constructor","this","_renderPipelines","_onNewPipelineAddedObservable","Observable","_onPipelineRemovedObservable","onNewPipelineAddedObservable","onPipelineRemovedObservable","supportedPipelines","result","renderPipelineName","Object","prototype","hasOwnProperty","call","pipeline","isSupported","push","addPipeline","renderPipeline","removePipeline","_name","notifyObservers","attachCamerasToRenderPipeline","cameras","unique","_attachCameras","detachCamerasFromRenderPipeline","_detachCameras","enableEffectInPipeline","renderEffectName","_enableEffect","disableEffectInPipeline","_disableEffect","update","_update","dispose","_rebuild","defineProperty","Scene","get","_postProcessRenderPipelineManager","component","_getComponent","SceneComponentConstants","NAME_POSTPROCESSRENDERPIPELINEMANAGER","PostProcessRenderPipelineManagerSceneComponent","_addComponent","enumerable","configurable","scene","name","register","_gatherRenderTargetsStage","registerStep","STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER","_gatherRenderTargets","rebuild"],"mappings":"8DAKO,MAAMA,EAKT,WAAAC,GACIC,KAAKC,iBAAmB,CAAE,EAC1BD,KAAKE,8BAAgC,IAAIC,EACzCH,KAAKI,6BAA+B,IAAID,CAChD,CAII,gCAAIE,GACA,OAAOL,KAAKE,6BACpB,CAII,+BAAII,GACA,OAAON,KAAKI,4BACpB,CAII,sBAAIG,GACA,MAAMC,EAAS,GACf,IAAK,MAAMC,KAAsBT,KAAKC,iBAClC,GAAIS,OAAOC,UAAUC,eAAeC,KAAKb,KAAKC,iBAAkBQ,GAAqB,CACjF,MAAMK,EAAWd,KAAKC,iBAAiBQ,GACnCK,EAASC,aACTP,EAAOQ,KAAKF,EAEhC,CAEQ,OAAON,CACf,CAKI,WAAAS,CAAYC,GACRlB,KAAKmB,eAAeD,EAAeE,OACnCpB,KAAKC,iBAAiBiB,EAAeE,OAASF,EAC9ClB,KAAKE,8BAA8BmB,gBAAgBH,EAC3D,CAKI,cAAAC,CAAeV,GACX,MAAMK,EAAWd,KAAKC,iBAAiBQ,GACnCK,IACAd,KAAKI,6BAA6BiB,gBAAgBP,UAC3Cd,KAAKC,iBAAiBQ,GAEzC,CAOI,6BAAAa,CAA8Bb,EAAoBc,EAASC,GAAS,GAChE,MAAMN,EAAiBlB,KAAKC,iBAAiBQ,GACxCS,GAGLA,EAAeO,eAAeF,EAASC,EAC/C,CAMI,+BAAAE,CAAgCjB,EAAoBc,GAChD,MAAML,EAAiBlB,KAAKC,iBAAiBQ,GACxCS,GAGLA,EAAeS,eAAeJ,EACtC,CAOI,sBAAAK,CAAuBnB,EAAoBoB,EAAkBN,GACzD,MAAML,EAAiBlB,KAAKC,iBAAiBQ,GACxCS,GAGLA,EAAeY,cAAcD,EAAkBN,EACvD,CAOI,uBAAAQ,CAAwBtB,EAAoBoB,EAAkBN,GAC1D,MAAML,EAAiBlB,KAAKC,iBAAiBQ,GACxCS,GAGLA,EAAec,eAAeH,EAAkBN,EACxD,CAII,MAAAU,GACI,IAAK,MAAMxB,KAAsBT,KAAKC,iBAClC,GAAIS,OAAOC,UAAUC,eAAeC,KAAKb,KAAKC,iBAAkBQ,GAAqB,CACjF,MAAMK,EAAWd,KAAKC,iBAAiBQ,GAClCK,EAASC,YAKVD,EAASoB,WAJTpB,EAASqB,iBACFnC,KAAKC,iBAAiBQ,GAKjD,CAEA,CAEI,QAAA2B,GACI,IAAK,MAAM3B,KAAsBT,KAAKC,iBAClC,GAAIS,OAAOC,UAAUC,eAAeC,KAAKb,KAAKC,iBAAkBQ,GAAqB,CAChET,KAAKC,iBAAiBQ,GAC9B2B,UACzB,CAEA,CAII,OAAAD,GACI,IAAK,MAAM1B,KAAsBT,KAAKC,iBAClC,GAAIS,OAAOC,UAAUC,eAAeC,KAAKb,KAAKC,iBAAkBQ,GAAqB,CAChET,KAAKC,iBAAiBQ,GAC9B0B,SACzB,CAEA,EClJAzB,OAAO2B,eAAeC,EAAM3B,UAAW,mCAAoC,CACvE4B,IAAK,WACD,IAAKvC,KAAKwC,kCAAmC,CAEzC,IAAIC,EAAYzC,KAAK0C,cAAcC,EAAwBC,uCACtDH,IACDA,EAAY,IAAII,EAA+C7C,MAC/DA,KAAK8C,cAAcL,IAEvBzC,KAAKwC,kCAAoC,IAAI1C,CACzD,CACQ,OAAOE,KAAKwC,iCACf,EACDO,YAAY,EACZC,cAAc,IAKX,MAAMH,EAKT,WAAA9C,CAAYkD,GAIRjD,KAAKkD,KAAOP,EAAwBC,sCACpC5C,KAAKiD,MAAQA,CACrB,CAII,QAAAE,GACInD,KAAKiD,MAAMG,0BAA0BC,aAAaV,EAAwBW,0DAA2DtD,KAAMA,KAAKuD,qBACxJ,CAKI,OAAAC,GACQxD,KAAKiD,MAAMT,mCACXxC,KAAKiD,MAAMT,kCAAkCJ,UAEzD,CAII,OAAAD,GACQnC,KAAKiD,MAAMT,mCACXxC,KAAKiD,MAAMT,kCAAkCL,SAEzD,CACI,oBAAAoB,GACQvD,KAAKiD,MAAMT,mCACXxC,KAAKiD,MAAMT,kCAAkCP,QAEzD"}