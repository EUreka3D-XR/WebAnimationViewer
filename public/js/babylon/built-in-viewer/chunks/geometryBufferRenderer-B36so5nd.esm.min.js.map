{"version":3,"file":"geometryBufferRenderer-B36so5nd.esm.min.js","sources":["../../../../../dev/core/dist/Materials/Textures/multiRenderTarget.js","../../../../../dev/core/dist/Shaders/ShadersInclude/mrtFragmentDeclaration.js","../../../../../dev/core/dist/Shaders/geometry.fragment.js","../../../../../dev/core/dist/Shaders/ShadersInclude/geometryVertexDeclaration.js","../../../../../dev/core/dist/Shaders/ShadersInclude/geometryUboDeclaration.js","../../../../../dev/core/dist/Shaders/geometry.vertex.js","../../../../../dev/core/dist/Rendering/geometryBufferRenderer.js"],"sourcesContent":["import { Texture } from \"../../Materials/Textures/texture\";\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\nimport { Constants } from \"../../Engines/constants\";\nimport \"../../Engines/Extensions/engine.multiRender\";\n/**\n * A multi render target, like a render target provides the ability to render to a texture.\n * Unlike the render target, it can render to several draw buffers (render textures) in one draw.\n * This is specially interesting in deferred rendering or for any effects requiring more than\n * just one color from a single pass.\n */\nexport class MultiRenderTarget extends RenderTargetTexture {\n    /**\n     * Get if draw buffers (render textures) are currently supported by the used hardware and browser.\n     */\n    get isSupported() {\n        return this._engine?.getCaps().drawBuffersExtension ?? false;\n    }\n    /**\n     * Get the list of textures generated by the multi render target.\n     */\n    get textures() {\n        return this._textures;\n    }\n    /**\n     * Gets the number of textures in this MRT. This number can be different from `_textures.length` in case a depth texture is generated.\n     */\n    get count() {\n        return this._count;\n    }\n    /**\n     * Get the depth texture generated by the multi render target if options.generateDepthTexture has been set\n     */\n    get depthTexture() {\n        return this._textures[this._textures.length - 1];\n    }\n    /**\n     * Set the wrapping mode on U of all the textures we are rendering to.\n     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\n     */\n    set wrapU(wrap) {\n        if (this._textures) {\n            for (let i = 0; i < this._textures.length; i++) {\n                this._textures[i].wrapU = wrap;\n            }\n        }\n    }\n    /**\n     * Set the wrapping mode on V of all the textures we are rendering to.\n     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\n     */\n    set wrapV(wrap) {\n        if (this._textures) {\n            for (let i = 0; i < this._textures.length; i++) {\n                this._textures[i].wrapV = wrap;\n            }\n        }\n    }\n    /**\n     * Instantiate a new multi render target texture.\n     * A multi render target, like a render target provides the ability to render to a texture.\n     * Unlike the render target, it can render to several draw buffers (render textures) in one draw.\n     * This is specially interesting in deferred rendering or for any effects requiring more than\n     * just one color from a single pass.\n     * @param name Define the name of the texture\n     * @param size Define the size of the buffers to render to\n     * @param count Define the number of target we are rendering into\n     * @param scene Define the scene the texture belongs to\n     * @param options Define the options used to create the multi render target\n     * @param textureNames Define the names to set to the textures (if count \\> 0 - optional)\n     */\n    constructor(name, size, count, scene, options, textureNames) {\n        const generateMipMaps = options && options.generateMipMaps ? options.generateMipMaps : false;\n        const generateDepthTexture = options && options.generateDepthTexture ? options.generateDepthTexture : false;\n        const depthTextureFormat = options && options.depthTextureFormat ? options.depthTextureFormat : Constants.TEXTUREFORMAT_DEPTH16;\n        const doNotChangeAspectRatio = !options || options.doNotChangeAspectRatio === undefined ? true : options.doNotChangeAspectRatio;\n        const drawOnlyOnFirstAttachmentByDefault = options && options.drawOnlyOnFirstAttachmentByDefault ? options.drawOnlyOnFirstAttachmentByDefault : false;\n        super(name, size, scene, generateMipMaps, doNotChangeAspectRatio, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true);\n        if (!this.isSupported) {\n            this.dispose();\n            return;\n        }\n        this._textureNames = textureNames;\n        const types = [];\n        const samplingModes = [];\n        const useSRGBBuffers = [];\n        const formats = [];\n        const targetTypes = [];\n        const faceIndex = [];\n        const layerIndex = [];\n        const layerCounts = [];\n        this._initTypes(count, types, samplingModes, useSRGBBuffers, formats, targetTypes, faceIndex, layerIndex, layerCounts, options);\n        const generateDepthBuffer = !options || options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n        const generateStencilBuffer = !options || options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\n        const samples = options && options.samples ? options.samples : 1;\n        this._multiRenderTargetOptions = {\n            samplingModes: samplingModes,\n            generateMipMaps: generateMipMaps,\n            generateDepthBuffer: generateDepthBuffer,\n            generateStencilBuffer: generateStencilBuffer,\n            generateDepthTexture: generateDepthTexture,\n            depthTextureFormat: depthTextureFormat,\n            types: types,\n            textureCount: count,\n            useSRGBBuffers: useSRGBBuffers,\n            samples,\n            formats: formats,\n            targetTypes: targetTypes,\n            faceIndex: faceIndex,\n            layerIndex: layerIndex,\n            layerCounts: layerCounts,\n            labels: textureNames,\n            label: name,\n        };\n        this._count = count;\n        this._drawOnlyOnFirstAttachmentByDefault = drawOnlyOnFirstAttachmentByDefault;\n        if (count > 0) {\n            this._createInternalTextures();\n            this._createTextures(textureNames);\n        }\n    }\n    _initTypes(count, types, samplingModes, useSRGBBuffers, formats, targets, faceIndex, layerIndex, layerCounts, options) {\n        for (let i = 0; i < count; i++) {\n            if (options && options.types && options.types[i] !== undefined) {\n                types.push(options.types[i]);\n            }\n            else {\n                types.push(options && options.defaultType ? options.defaultType : Constants.TEXTURETYPE_UNSIGNED_BYTE);\n            }\n            if (options && options.samplingModes && options.samplingModes[i] !== undefined) {\n                samplingModes.push(options.samplingModes[i]);\n            }\n            else {\n                samplingModes.push(Texture.BILINEAR_SAMPLINGMODE);\n            }\n            if (options && options.useSRGBBuffers && options.useSRGBBuffers[i] !== undefined) {\n                useSRGBBuffers.push(options.useSRGBBuffers[i]);\n            }\n            else {\n                useSRGBBuffers.push(false);\n            }\n            if (options && options.formats && options.formats[i] !== undefined) {\n                formats.push(options.formats[i]);\n            }\n            else {\n                formats.push(Constants.TEXTUREFORMAT_RGBA);\n            }\n            if (options && options.targetTypes && options.targetTypes[i] !== undefined) {\n                targets.push(options.targetTypes[i]);\n            }\n            else {\n                targets.push(Constants.TEXTURE_2D);\n            }\n            if (options && options.faceIndex && options.faceIndex[i] !== undefined) {\n                faceIndex.push(options.faceIndex[i]);\n            }\n            else {\n                faceIndex.push(0);\n            }\n            if (options && options.layerIndex && options.layerIndex[i] !== undefined) {\n                layerIndex.push(options.layerIndex[i]);\n            }\n            else {\n                layerIndex.push(0);\n            }\n            if (options && options.layerCounts && options.layerCounts[i] !== undefined) {\n                layerCounts.push(options.layerCounts[i]);\n            }\n            else {\n                layerCounts.push(1);\n            }\n        }\n    }\n    _createInternaTextureIndexMapping() {\n        const mapMainInternalTexture2Index = {};\n        const mapInternalTexture2MainIndex = [];\n        if (!this._renderTarget) {\n            return mapInternalTexture2MainIndex;\n        }\n        const internalTextures = this._renderTarget.textures;\n        for (let i = 0; i < internalTextures.length; i++) {\n            const texture = internalTextures[i];\n            if (!texture) {\n                continue;\n            }\n            const mainIndex = mapMainInternalTexture2Index[texture.uniqueId];\n            if (mainIndex !== undefined) {\n                mapInternalTexture2MainIndex[i] = mainIndex;\n            }\n            else {\n                mapMainInternalTexture2Index[texture.uniqueId] = i;\n            }\n        }\n        return mapInternalTexture2MainIndex;\n    }\n    /**\n     * @internal\n     */\n    _rebuild(fromContextLost = false, forceFullRebuild = false, textureNames) {\n        if (this._count < 1 || fromContextLost) {\n            return;\n        }\n        const mapInternalTexture2MainIndex = this._createInternaTextureIndexMapping();\n        this.releaseInternalTextures();\n        this._createInternalTextures();\n        if (forceFullRebuild) {\n            this._releaseTextures();\n            this._createTextures(textureNames);\n        }\n        const internalTextures = this._renderTarget.textures;\n        for (let i = 0; i < internalTextures.length; i++) {\n            const texture = this._textures[i];\n            if (mapInternalTexture2MainIndex[i] !== undefined) {\n                this._renderTarget.setTexture(internalTextures[mapInternalTexture2MainIndex[i]], i);\n            }\n            texture._texture = internalTextures[i];\n            if (texture._texture) {\n                texture._noMipmap = !texture._texture.useMipMaps;\n                texture._useSRGBBuffer = texture._texture._useSRGBBuffer;\n            }\n        }\n        if (this.samples !== 1) {\n            this._renderTarget.setSamples(this.samples, !this._drawOnlyOnFirstAttachmentByDefault, true);\n        }\n    }\n    _createInternalTextures() {\n        this._renderTarget = this._getEngine().createMultipleRenderTarget(this._size, this._multiRenderTargetOptions, !this._drawOnlyOnFirstAttachmentByDefault);\n        this._texture = this._renderTarget.texture;\n    }\n    _releaseTextures() {\n        if (this._textures) {\n            for (let i = 0; i < this._textures.length; i++) {\n                this._textures[i]._texture = null; // internal textures are released by a call to releaseInternalTextures()\n                this._textures[i].dispose();\n            }\n        }\n    }\n    _createTextures(textureNames) {\n        const internalTextures = this._renderTarget.textures;\n        this._textures = [];\n        for (let i = 0; i < internalTextures.length; i++) {\n            const texture = new Texture(null, this.getScene());\n            if (textureNames?.[i]) {\n                texture.name = textureNames[i];\n            }\n            texture._texture = internalTextures[i];\n            if (texture._texture) {\n                texture._noMipmap = !texture._texture.useMipMaps;\n                texture._useSRGBBuffer = texture._texture._useSRGBBuffer;\n            }\n            this._textures.push(texture);\n        }\n    }\n    /**\n     * Replaces an internal texture within the MRT. Useful to share textures between MultiRenderTarget.\n     * @param texture The new texture to set in the MRT\n     * @param index The index of the texture to replace\n     * @param disposePrevious Set to true if the previous internal texture should be disposed\n     */\n    setInternalTexture(texture, index, disposePrevious = true) {\n        if (!this.renderTarget) {\n            return;\n        }\n        if (index === 0) {\n            this._texture = texture;\n        }\n        this.renderTarget.setTexture(texture, index, disposePrevious);\n        if (!this.textures[index]) {\n            this.textures[index] = new Texture(null, this.getScene());\n            this.textures[index].name = this._textureNames?.[index] ?? this.textures[index].name;\n        }\n        this.textures[index]._texture = texture;\n        this.textures[index]._noMipmap = !texture.useMipMaps;\n        this.textures[index]._useSRGBBuffer = texture._useSRGBBuffer;\n        this._count = this.renderTarget.textures ? this.renderTarget.textures.length : 0;\n        if (this._multiRenderTargetOptions.types) {\n            this._multiRenderTargetOptions.types[index] = texture.type;\n        }\n        if (this._multiRenderTargetOptions.samplingModes) {\n            this._multiRenderTargetOptions.samplingModes[index] = texture.samplingMode;\n        }\n        if (this._multiRenderTargetOptions.useSRGBBuffers) {\n            this._multiRenderTargetOptions.useSRGBBuffers[index] = texture._useSRGBBuffer;\n        }\n        if (this._multiRenderTargetOptions.targetTypes && this._multiRenderTargetOptions.targetTypes[index] !== -1) {\n            let target = 0;\n            if (texture.is2DArray) {\n                target = Constants.TEXTURE_2D_ARRAY;\n            }\n            else if (texture.isCube) {\n                target = Constants.TEXTURE_CUBE_MAP;\n            } /*else if (texture.isCubeArray) {\n                target = Constants.TEXTURE_CUBE_MAP_ARRAY;\n            }*/\n            else if (texture.is3D) {\n                target = Constants.TEXTURE_3D;\n            }\n            else {\n                target = Constants.TEXTURE_2D;\n            }\n            this._multiRenderTargetOptions.targetTypes[index] = target;\n        }\n    }\n    /**\n     * Changes an attached texture's face index or layer.\n     * @param index The index of the texture to modify the attachment of\n     * @param layerIndex The layer index of the texture to be attached to the framebuffer\n     * @param faceIndex The face index of the texture to be attached to the framebuffer\n     */\n    setLayerAndFaceIndex(index, layerIndex = -1, faceIndex = -1) {\n        if (!this.textures[index] || !this.renderTarget) {\n            return;\n        }\n        if (this._multiRenderTargetOptions.layerIndex) {\n            this._multiRenderTargetOptions.layerIndex[index] = layerIndex;\n        }\n        if (this._multiRenderTargetOptions.faceIndex) {\n            this._multiRenderTargetOptions.faceIndex[index] = faceIndex;\n        }\n        this.renderTarget.setLayerAndFaceIndex(index, layerIndex, faceIndex);\n    }\n    /**\n     * Changes every attached texture's face index or layer.\n     * @param layerIndices The layer indices of the texture to be attached to the framebuffer\n     * @param faceIndices The face indices of the texture to be attached to the framebuffer\n     */\n    setLayerAndFaceIndices(layerIndices, faceIndices) {\n        if (!this.renderTarget) {\n            return;\n        }\n        this._multiRenderTargetOptions.layerIndex = layerIndices;\n        this._multiRenderTargetOptions.faceIndex = faceIndices;\n        this.renderTarget.setLayerAndFaceIndices(layerIndices, faceIndices);\n    }\n    /**\n     * Define the number of samples used if MSAA is enabled.\n     */\n    get samples() {\n        return this._samples;\n    }\n    set samples(value) {\n        if (this._renderTarget) {\n            this._samples = this._renderTarget.setSamples(value);\n        }\n        else {\n            // In case samples are set with 0 textures created, we must save the desired samples value\n            this._samples = value;\n        }\n    }\n    /**\n     * Resize all the textures in the multi render target.\n     * Be careful as it will recreate all the data in the new texture.\n     * @param size Define the new size\n     */\n    resize(size) {\n        this._processSizeParameter(size);\n        this._rebuild(false, undefined, this._textureNames);\n    }\n    /**\n     * Changes the number of render targets in this MRT\n     * Be careful as it will recreate all the data in the new texture.\n     * @param count new texture count\n     * @param options Specifies texture types and sampling modes for new textures\n     * @param textureNames Specifies the names of the textures (optional)\n     */\n    updateCount(count, options, textureNames) {\n        this._multiRenderTargetOptions.textureCount = count;\n        this._count = count;\n        const types = [];\n        const samplingModes = [];\n        const useSRGBBuffers = [];\n        const formats = [];\n        const targetTypes = [];\n        const faceIndex = [];\n        const layerIndex = [];\n        const layerCounts = [];\n        this._textureNames = textureNames;\n        this._initTypes(count, types, samplingModes, useSRGBBuffers, formats, targetTypes, faceIndex, layerIndex, layerCounts, options);\n        this._multiRenderTargetOptions.types = types;\n        this._multiRenderTargetOptions.samplingModes = samplingModes;\n        this._multiRenderTargetOptions.useSRGBBuffers = useSRGBBuffers;\n        this._multiRenderTargetOptions.formats = formats;\n        this._multiRenderTargetOptions.targetTypes = targetTypes;\n        this._multiRenderTargetOptions.faceIndex = faceIndex;\n        this._multiRenderTargetOptions.layerIndex = layerIndex;\n        this._multiRenderTargetOptions.layerCounts = layerCounts;\n        this._multiRenderTargetOptions.labels = textureNames;\n        this._rebuild(false, true, textureNames);\n    }\n    _unbindFrameBuffer(engine, faceIndex) {\n        if (this._renderTarget) {\n            engine.unBindMultiColorAttachmentFramebuffer(this._renderTarget, this.isCube, () => {\n                this.onAfterRenderObservable.notifyObservers(faceIndex);\n            });\n        }\n    }\n    /**\n     * Dispose the render targets and their associated resources\n     * @param doNotDisposeInternalTextures if set to true, internal textures won't be disposed (default: false).\n     */\n    dispose(doNotDisposeInternalTextures = false) {\n        this._releaseTextures();\n        if (!doNotDisposeInternalTextures) {\n            this.releaseInternalTextures();\n        }\n        else {\n            // Prevent internal texture dispose in super.dispose\n            this._texture = null;\n        }\n        super.dispose();\n    }\n    /**\n     * Release all the underlying texture used as draw buffers (render textures).\n     */\n    releaseInternalTextures() {\n        const internalTextures = this._renderTarget?.textures;\n        if (!internalTextures) {\n            return;\n        }\n        for (let i = internalTextures.length - 1; i >= 0; i--) {\n            this._textures[i]._texture = null;\n        }\n        this._renderTarget?.dispose();\n        this._renderTarget = null;\n    }\n}\n//# sourceMappingURL=multiRenderTarget.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nconst name = \"mrtFragmentDeclaration\";\nconst shader = `#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nlayout(location=0) out vec4 glFragData[{X}];\n#endif\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const mrtFragmentDeclaration = { name, shader };\n//# sourceMappingURL=mrtFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/mrtFragmentDeclaration\";\nimport \"./ShadersInclude/bumpFragmentMainFunctions\";\nimport \"./ShadersInclude/bumpFragmentFunctions\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/bumpFragment\";\nconst name = \"geometryPixelShader\";\nconst shader = `#extension GL_EXT_draw_buffers : require\n#if defined(BUMP) || !defined(NORMAL)\n#extension GL_OES_standard_derivatives : enable\n#endif\nprecision highp float;\n#ifdef BUMP\nvarying mat4 vWorldView;varying vec3 vNormalW;\n#else\nvarying vec3 vNormalV;\n#endif\nvarying vec4 vViewPos;\n#if defined(POSITION) || defined(BUMP)\nvarying vec3 vPositionW;\n#endif\n#if defined(VELOCITY) || defined(VELOCITY_LINEAR)\nvarying vec4 vCurrentPosition;varying vec4 vPreviousPosition;\n#endif\n#ifdef NEED_UV\nvarying vec2 vUV;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;uniform vec2 vTangentSpaceParams;\n#endif\n#if defined(REFLECTIVITY)\n#if defined(ORMTEXTURE) || defined(SPECULARGLOSSINESSTEXTURE) || defined(REFLECTIVITYTEXTURE)\nuniform sampler2D reflectivitySampler;varying vec2 vReflectivityUV;\n#else\n#ifdef METALLIC_TEXTURE\nuniform sampler2D metallicSampler;varying vec2 vMetallicUV;\n#endif\n#ifdef ROUGHNESS_TEXTURE\nuniform sampler2D roughnessSampler;varying vec2 vRoughnessUV;\n#endif\n#endif\n#ifdef ALBEDOTEXTURE\nvarying vec2 vAlbedoUV;uniform sampler2D albedoSampler;\n#endif\n#ifdef REFLECTIVITYCOLOR\nuniform vec3 reflectivityColor;\n#endif\n#ifdef ALBEDOCOLOR\nuniform vec3 albedoColor;\n#endif\n#ifdef METALLIC\nuniform float metallic;\n#endif\n#if defined(ROUGHNESS) || defined(GLOSSINESS)\nuniform float glossiness;\n#endif\n#endif\n#if defined(ALPHATEST) && defined(NEED_UV)\nuniform sampler2D diffuseSampler;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#include<mrtFragmentDeclaration>[SCENE_MRT_COUNT]\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<helperFunctions>\nvoid main() {\n#include<clipPlaneFragment>\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\ndiscard;\n#endif\nvec3 normalOutput;\n#ifdef BUMP\nvec3 normalW=normalize(vNormalW);\n#include<bumpFragment>\n#ifdef NORMAL_WORLDSPACE\nnormalOutput=normalW;\n#else\nnormalOutput=normalize(vec3(vWorldView*vec4(normalW,0.0)));\n#endif\n#elif defined(HAS_NORMAL_ATTRIBUTE)\nnormalOutput=normalize(vNormalV);\n#elif defined(POSITION)\nnormalOutput=normalize(-cross(dFdx(vPositionW),dFdy(vPositionW)));\n#endif\n#ifdef ENCODE_NORMAL\nnormalOutput=normalOutput*0.5+0.5;\n#endif\n#ifdef DEPTH\ngl_FragData[DEPTH_INDEX]=vec4(vViewPos.z/vViewPos.w,0.0,0.0,1.0);\n#endif\n#ifdef NORMAL\ngl_FragData[NORMAL_INDEX]=vec4(normalOutput,1.0);\n#endif\n#ifdef SCREENSPACE_DEPTH\ngl_FragData[SCREENSPACE_DEPTH_INDEX]=vec4(gl_FragCoord.z,0.0,0.0,1.0);\n#endif\n#ifdef POSITION\ngl_FragData[POSITION_INDEX]=vec4(vPositionW,1.0);\n#endif\n#ifdef VELOCITY\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;vec2 velocity=abs(a-b);velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;gl_FragData[VELOCITY_INDEX]=vec4(velocity,0.0,1.0);\n#endif\n#ifdef VELOCITY_LINEAR\nvec2 velocity=vec2(0.5)*((vPreviousPosition.xy/vPreviousPosition.w) -\n(vCurrentPosition.xy/vCurrentPosition.w));gl_FragData[VELOCITY_LINEAR_INDEX]=vec4(velocity,0.0,1.0);\n#endif\n#ifdef REFLECTIVITY\nvec4 reflectivity=vec4(0.0,0.0,0.0,1.0);\n#ifdef METALLICWORKFLOW\nfloat metal=1.0;float roughness=1.0;\n#ifdef ORMTEXTURE\nmetal*=texture2D(reflectivitySampler,vReflectivityUV).b;roughness*=texture2D(reflectivitySampler,vReflectivityUV).g;\n#else\n#ifdef METALLIC_TEXTURE\nmetal*=texture2D(metallicSampler,vMetallicUV).r;\n#endif\n#ifdef ROUGHNESS_TEXTURE\nroughness*=texture2D(roughnessSampler,vRoughnessUV).r;\n#endif\n#endif\n#ifdef METALLIC\nmetal*=metallic;\n#endif\n#ifdef ROUGHNESS\nroughness*=(1.0-glossiness); \n#endif\nreflectivity.a-=roughness;vec3 color=vec3(1.0);\n#ifdef ALBEDOTEXTURE\ncolor=texture2D(albedoSampler,vAlbedoUV).rgb;\n#ifdef GAMMAALBEDO\ncolor=toLinearSpace(color);\n#endif\n#endif\n#ifdef ALBEDOCOLOR\ncolor*=albedoColor.xyz;\n#endif\nreflectivity.rgb=mix(vec3(0.04),color,metal);\n#else\n#if defined(SPECULARGLOSSINESSTEXTURE) || defined(REFLECTIVITYTEXTURE)\nreflectivity=texture2D(reflectivitySampler,vReflectivityUV);\n#ifdef GAMMAREFLECTIVITYTEXTURE\nreflectivity.rgb=toLinearSpace(reflectivity.rgb);\n#endif\n#else \n#ifdef REFLECTIVITYCOLOR\nreflectivity.rgb=toLinearSpace(reflectivityColor.xyz);reflectivity.a=1.0;\n#endif\n#endif\n#ifdef GLOSSINESSS\nreflectivity.a*=glossiness; \n#endif\n#endif\ngl_FragData[REFLECTIVITY_INDEX]=reflectivity;\n#endif\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const geometryPixelShader = { name, shader };\n//# sourceMappingURL=geometry.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nconst name = \"geometryVertexDeclaration\";\nconst shader = `uniform mat4 viewProjection;uniform mat4 view;`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const geometryVertexDeclaration = { name, shader };\n//# sourceMappingURL=geometryVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./sceneUboDeclaration\";\nconst name = \"geometryUboDeclaration\";\nconst shader = `#include<sceneUboDeclaration>\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const geometryUboDeclaration = { name, shader };\n//# sourceMappingURL=geometryUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/geometryVertexDeclaration\";\nimport \"./ShadersInclude/geometryUboDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/bumpVertex\";\nconst name = \"geometryVertexShader\";\nconst shader = `precision highp float;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<instancesDeclaration>\n#include<__decl__geometryVertex>\n#include<clipPlaneVertexDeclaration>\nattribute vec3 position;\n#ifdef HAS_NORMAL_ATTRIBUTE\nattribute vec3 normal;\n#endif\n#ifdef NEED_UV\nvarying vec2 vUV;\n#ifdef ALPHATEST\nuniform mat4 diffuseMatrix;\n#endif\n#ifdef BUMP\nuniform mat4 bumpMatrix;varying vec2 vBumpUV;\n#endif\n#ifdef REFLECTIVITY\nuniform mat4 reflectivityMatrix;uniform mat4 albedoMatrix;varying vec2 vReflectivityUV;varying vec2 vAlbedoUV;\n#endif\n#ifdef METALLIC_TEXTURE\nvarying vec2 vMetallicUV;uniform mat4 metallicMatrix;\n#endif\n#ifdef ROUGHNESS_TEXTURE\nvarying vec2 vRoughnessUV;uniform mat4 roughnessMatrix;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\n#ifdef BUMP\nvarying mat4 vWorldView;\n#endif\n#ifdef BUMP\nvarying vec3 vNormalW;\n#else\nvarying vec3 vNormalV;\n#endif\nvarying vec4 vViewPos;\n#if defined(POSITION) || defined(BUMP)\nvarying vec3 vPositionW;\n#endif\n#if defined(VELOCITY) || defined(VELOCITY_LINEAR)\nuniform mat4 previousViewProjection;varying vec4 vCurrentPosition;varying vec4 vPreviousPosition;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\n{vec3 positionUpdated=position;\n#ifdef HAS_NORMAL_ATTRIBUTE\nvec3 normalUpdated=normal;\n#else\nvec3 normalUpdated=vec3(0.0,0.0,0.0);\n#endif\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#ifdef UV2\nvec2 uv2Updated=uv2;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#if (defined(VELOCITY) || defined(VELOCITY_LINEAR)) && !defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=vec4(finalWorld*vec4(positionUpdated,1.0));\n#ifdef BUMP\nvWorldView=view*finalWorld;mat3 normalWorld=mat3(finalWorld);vNormalW=normalize(normalWorld*normalUpdated);\n#else\n#ifdef NORMAL_WORLDSPACE\nvNormalV=normalize(vec3(finalWorld*vec4(normalUpdated,0.0)));\n#else\nvNormalV=normalize(vec3((view*finalWorld)*vec4(normalUpdated,0.0)));\n#endif\n#endif\nvViewPos=view*worldPos;\n#if (defined(VELOCITY) || defined(VELOCITY_LINEAR)) && defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\n#if NUM_BONE_INFLUENCERS>0\nmat4 previousInfluence;previousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\npreviousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\npreviousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\npreviousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\nvPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);\n#else\nvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#endif\n#if defined(POSITION) || defined(BUMP)\nvPositionW=worldPos.xyz/worldPos.w;\n#endif\ngl_Position=viewProjection*finalWorld*vec4(positionUpdated,1.0);\n#include<clipPlaneVertex>\n#ifdef NEED_UV\n#ifdef UV1\n#if defined(ALPHATEST) && defined(ALPHATEST_UV1)\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#else\nvUV=uvUpdated;\n#endif\n#ifdef BUMP_UV1\nvBumpUV=vec2(bumpMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef REFLECTIVITY_UV1\nvReflectivityUV=vec2(reflectivityMatrix*vec4(uvUpdated,1.0,0.0));\n#else\n#ifdef METALLIC_UV1\nvMetallicUV=vec2(metallicMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef ROUGHNESS_UV1\nvRoughnessUV=vec2(roughnessMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#endif\n#ifdef ALBEDO_UV1\nvAlbedoUV=vec2(albedoMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#endif\n#ifdef UV2\n#if defined(ALPHATEST) && defined(ALPHATEST_UV2)\nvUV=vec2(diffuseMatrix*vec4(uv2Updated,1.0,0.0));\n#else\nvUV=uv2Updated;\n#endif\n#ifdef BUMP_UV2\nvBumpUV=vec2(bumpMatrix*vec4(uv2Updated,1.0,0.0));\n#endif\n#ifdef REFLECTIVITY_UV2\nvReflectivityUV=vec2(reflectivityMatrix*vec4(uv2Updated,1.0,0.0));\n#else\n#ifdef METALLIC_UV2\nvMetallicUV=vec2(metallicMatrix*vec4(uv2Updated,1.0,0.0));\n#endif\n#ifdef ROUGHNESS_UV2\nvRoughnessUV=vec2(roughnessMatrix*vec4(uv2Updated,1.0,0.0));\n#endif\n#endif\n#ifdef ALBEDO_UV2\nvAlbedoUV=vec2(albedoMatrix*vec4(uv2Updated,1.0,0.0));\n#endif\n#endif\n#endif\n#include<bumpVertex>\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const geometryVertexShader = { name, shader };\n//# sourceMappingURL=geometry.vertex.js.map","import { Matrix } from \"../Maths/math.vector\";\nimport { VertexBuffer } from \"../Buffers/buffer\";\nimport { Constants } from \"../Engines/constants\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { MultiRenderTarget } from \"../Materials/Textures/multiRenderTarget\";\nimport { Color4 } from \"../Maths/math.color\";\nimport { _WarnImport } from \"../Misc/devTools\";\nimport { Material } from \"../Materials/material\";\nimport \"../Shaders/geometry.fragment\";\nimport \"../Shaders/geometry.vertex\";\nimport { MaterialFlags } from \"../Materials/materialFlags\";\nimport { AddClipPlaneUniforms, BindClipPlane, PrepareStringDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper\";\nimport { BindMorphTargetParameters, BindSceneUniformBuffer, PrepareDefinesAndAttributesForMorphTargets, PushAttributesForInstances } from \"../Materials/materialHelper.functions\";\nimport \"../Engines/Extensions/engine.multiRender\";\n/** list the uniforms used by the geometry renderer */\nconst Uniforms = [\n    \"world\",\n    \"mBones\",\n    \"viewProjection\",\n    \"diffuseMatrix\",\n    \"view\",\n    \"previousWorld\",\n    \"previousViewProjection\",\n    \"mPreviousBones\",\n    \"bumpMatrix\",\n    \"reflectivityMatrix\",\n    \"albedoMatrix\",\n    \"reflectivityColor\",\n    \"albedoColor\",\n    \"metallic\",\n    \"glossiness\",\n    \"vTangentSpaceParams\",\n    \"vBumpInfos\",\n    \"morphTargetInfluences\",\n    \"morphTargetCount\",\n    \"morphTargetTextureInfo\",\n    \"morphTargetTextureIndices\",\n    \"boneTextureWidth\",\n];\nAddClipPlaneUniforms(Uniforms);\n/**\n * This renderer is helpful to fill one of the render target with a geometry buffer.\n */\nexport class GeometryBufferRenderer {\n    /**\n     * Gets a boolean indicating if normals are encoded in the [0,1] range in the render target. If true, you should do `normal = normal_rt * 2.0 - 1.0` to get the right normal\n     */\n    get normalsAreUnsigned() {\n        return this._normalsAreUnsigned;\n    }\n    /**\n     * @internal\n     * Sets up internal structures to share outputs with PrePassRenderer\n     * This method should only be called by the PrePassRenderer itself\n     */\n    _linkPrePassRenderer(prePassRenderer) {\n        this._linkedWithPrePass = true;\n        this._prePassRenderer = prePassRenderer;\n        if (this._multiRenderTarget) {\n            // prevents clearing of the RT since it's done by prepass\n            this._multiRenderTarget.onClearObservable.clear();\n            this._multiRenderTarget.onClearObservable.add(() => {\n                // pass\n            });\n        }\n    }\n    /**\n     * @internal\n     * Separates internal structures from PrePassRenderer so the geometry buffer can now operate by itself.\n     * This method should only be called by the PrePassRenderer itself\n     */\n    _unlinkPrePassRenderer() {\n        this._linkedWithPrePass = false;\n        this._createRenderTargets();\n    }\n    /**\n     * @internal\n     * Resets the geometry buffer layout\n     */\n    _resetLayout() {\n        this._enableDepth = true;\n        this._enableNormal = true;\n        this._enablePosition = false;\n        this._enableReflectivity = false;\n        this._enableVelocity = false;\n        this._enableVelocityLinear = false;\n        this._enableScreenspaceDepth = false;\n        this._attachmentsFromPrePass = [];\n    }\n    /**\n     * @internal\n     * Replaces a texture in the geometry buffer renderer\n     * Useful when linking textures of the prepass renderer\n     */\n    _forceTextureType(geometryBufferType, index) {\n        if (geometryBufferType === GeometryBufferRenderer.POSITION_TEXTURE_TYPE) {\n            this._positionIndex = index;\n            this._enablePosition = true;\n        }\n        else if (geometryBufferType === GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE) {\n            this._velocityIndex = index;\n            this._enableVelocity = true;\n        }\n        else if (geometryBufferType === GeometryBufferRenderer.VELOCITY_LINEAR_TEXTURE_TYPE) {\n            this._velocityLinearIndex = index;\n            this._enableVelocityLinear = true;\n        }\n        else if (geometryBufferType === GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE) {\n            this._reflectivityIndex = index;\n            this._enableReflectivity = true;\n        }\n        else if (geometryBufferType === GeometryBufferRenderer.DEPTH_TEXTURE_TYPE) {\n            this._depthIndex = index;\n            this._enableDepth = true;\n        }\n        else if (geometryBufferType === GeometryBufferRenderer.NORMAL_TEXTURE_TYPE) {\n            this._normalIndex = index;\n            this._enableNormal = true;\n        }\n        else if (geometryBufferType === GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE) {\n            this._screenspaceDepthIndex = index;\n            this._enableScreenspaceDepth = true;\n        }\n    }\n    /**\n     * @internal\n     * Sets texture attachments\n     * Useful when linking textures of the prepass renderer\n     */\n    _setAttachments(attachments) {\n        this._attachmentsFromPrePass = attachments;\n    }\n    /**\n     * @internal\n     * Replaces the first texture which is hard coded as a depth texture in the geometry buffer\n     * Useful when linking textures of the prepass renderer\n     */\n    _linkInternalTexture(internalTexture) {\n        this._multiRenderTarget.setInternalTexture(internalTexture, 0, false);\n    }\n    /**\n     * Gets the render list (meshes to be rendered) used in the G buffer.\n     */\n    get renderList() {\n        return this._multiRenderTarget.renderList;\n    }\n    /**\n     * Set the render list (meshes to be rendered) used in the G buffer.\n     */\n    set renderList(meshes) {\n        this._multiRenderTarget.renderList = meshes;\n    }\n    /**\n     * Gets whether or not G buffer are supported by the running hardware.\n     * This requires draw buffer supports\n     */\n    get isSupported() {\n        return this._multiRenderTarget.isSupported;\n    }\n    /**\n     * Returns the index of the given texture type in the G-Buffer textures array\n     * @param textureType The texture type constant. For example GeometryBufferRenderer.POSITION_TEXTURE_INDEX\n     * @returns the index of the given texture type in the G-Buffer textures array\n     */\n    getTextureIndex(textureType) {\n        switch (textureType) {\n            case GeometryBufferRenderer.POSITION_TEXTURE_TYPE:\n                return this._positionIndex;\n            case GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE:\n                return this._velocityIndex;\n            case GeometryBufferRenderer.VELOCITY_LINEAR_TEXTURE_TYPE:\n                return this._velocityLinearIndex;\n            case GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE:\n                return this._reflectivityIndex;\n            case GeometryBufferRenderer.DEPTH_TEXTURE_TYPE:\n                return this._depthIndex;\n            case GeometryBufferRenderer.NORMAL_TEXTURE_TYPE:\n                return this._normalIndex;\n            case GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE:\n                return this._screenspaceDepthIndex;\n            default:\n                return -1;\n        }\n    }\n    /**\n     * @returns a boolean indicating if object's depths are enabled for the G buffer.\n     */\n    get enableDepth() {\n        return this._enableDepth;\n    }\n    /**\n     * Sets whether or not object's depths are enabled for the G buffer.\n     */\n    set enableDepth(enable) {\n        this._enableDepth = enable;\n        if (!this._linkedWithPrePass) {\n            this.dispose();\n            this._createRenderTargets();\n        }\n    }\n    /**\n     * @returns a boolean indicating if object's normals are enabled for the G buffer.\n     */\n    get enableNormal() {\n        return this._enableNormal;\n    }\n    /**\n     * Sets whether or not object's normals are enabled for the G buffer.\n     */\n    set enableNormal(enable) {\n        this._enableNormal = enable;\n        if (!this._linkedWithPrePass) {\n            this.dispose();\n            this._createRenderTargets();\n        }\n    }\n    /**\n     * @returns a boolean indicating if objects positions are enabled for the G buffer.\n     */\n    get enablePosition() {\n        return this._enablePosition;\n    }\n    /**\n     * Sets whether or not objects positions are enabled for the G buffer.\n     */\n    set enablePosition(enable) {\n        this._enablePosition = enable;\n        // PrePass handles index and texture links\n        if (!this._linkedWithPrePass) {\n            this.dispose();\n            this._createRenderTargets();\n        }\n    }\n    /**\n     * @returns a boolean indicating if objects velocities are enabled for the G buffer.\n     */\n    get enableVelocity() {\n        return this._enableVelocity;\n    }\n    /**\n     * Sets whether or not objects velocities are enabled for the G buffer.\n     */\n    set enableVelocity(enable) {\n        this._enableVelocity = enable;\n        if (!enable) {\n            this._previousTransformationMatrices = {};\n        }\n        if (!this._linkedWithPrePass) {\n            this.dispose();\n            this._createRenderTargets();\n        }\n        this._scene.needsPreviousWorldMatrices = enable;\n    }\n    /**\n     * @returns a boolean indicating if object's linear velocities are enabled for the G buffer.\n     */\n    get enableVelocityLinear() {\n        return this._enableVelocityLinear;\n    }\n    /**\n     * Sets whether or not object's linear velocities are enabled for the G buffer.\n     */\n    set enableVelocityLinear(enable) {\n        this._enableVelocityLinear = enable;\n        if (!this._linkedWithPrePass) {\n            this.dispose();\n            this._createRenderTargets();\n        }\n    }\n    /**\n     * Gets a boolean indicating if objects reflectivity are enabled in the G buffer.\n     */\n    get enableReflectivity() {\n        return this._enableReflectivity;\n    }\n    /**\n     * Sets whether or not objects reflectivity are enabled for the G buffer.\n     * For Metallic-Roughness workflow with ORM texture, we assume that ORM texture is defined according to the default layout:\n     * pbr.useRoughnessFromMetallicTextureAlpha = false;\n     * pbr.useRoughnessFromMetallicTextureGreen = true;\n     * pbr.useMetallnessFromMetallicTextureBlue = true;\n     */\n    set enableReflectivity(enable) {\n        this._enableReflectivity = enable;\n        if (!this._linkedWithPrePass) {\n            this.dispose();\n            this._createRenderTargets();\n        }\n    }\n    /**\n     * Sets whether or not objects screenspace depth are enabled for the G buffer.\n     */\n    get enableScreenspaceDepth() {\n        return this._enableScreenspaceDepth;\n    }\n    set enableScreenspaceDepth(enable) {\n        this._enableScreenspaceDepth = enable;\n        if (!this._linkedWithPrePass) {\n            this.dispose();\n            this._createRenderTargets();\n        }\n    }\n    /**\n     * Gets the scene associated with the buffer.\n     */\n    get scene() {\n        return this._scene;\n    }\n    /**\n     * Gets the ratio used by the buffer during its creation.\n     * How big is the buffer related to the main canvas.\n     */\n    get ratio() {\n        return typeof this._ratioOrDimensions === \"object\" ? 1 : this._ratioOrDimensions;\n    }\n    /**\n     * Gets the shader language used in this material.\n     */\n    get shaderLanguage() {\n        return this._shaderLanguage;\n    }\n    /**\n     * Creates a new G Buffer for the scene\n     * @param scene The scene the buffer belongs to\n     * @param ratioOrDimensions How big is the buffer related to the main canvas (default: 1). You can also directly pass a width and height for the generated textures\n     * @param depthFormat Format of the depth texture (default: Constants.TEXTUREFORMAT_DEPTH16)\n     * @param textureTypesAndFormats The types and formats of textures to create as render targets. If not provided, all textures will be RGBA and float or half float, depending on the engine capabilities.\n     */\n    constructor(scene, ratioOrDimensions = 1, depthFormat = Constants.TEXTUREFORMAT_DEPTH16, textureTypesAndFormats) {\n        /**\n         * Dictionary used to store the previous transformation matrices of each rendered mesh\n         * in order to compute objects velocities when enableVelocity is set to \"true\"\n         * @internal\n         */\n        this._previousTransformationMatrices = {};\n        /**\n         * Dictionary used to store the previous bones transformation matrices of each rendered mesh\n         * in order to compute objects velocities when enableVelocity is set to \"true\"\n         * @internal\n         */\n        this._previousBonesTransformationMatrices = {};\n        /**\n         * Array used to store the ignored skinned meshes while computing velocity map (typically used by the motion blur post-process).\n         * Avoids computing bones velocities and computes only mesh's velocity itself (position, rotation, scaling).\n         */\n        this.excludedSkinnedMeshesFromVelocity = [];\n        /** Gets or sets a boolean indicating if transparent meshes should be rendered */\n        this.renderTransparentMeshes = true;\n        /**\n         * Gets or sets a boolean indicating if normals should be generated in world space (default: false, meaning normals are generated in view space)\n         */\n        this.generateNormalsInWorldSpace = false;\n        this._normalsAreUnsigned = false;\n        this._resizeObserver = null;\n        this._enableDepth = true;\n        this._enableNormal = true;\n        this._enablePosition = false;\n        this._enableVelocity = false;\n        this._enableVelocityLinear = false;\n        this._enableReflectivity = false;\n        this._enableScreenspaceDepth = false;\n        this._clearColor = new Color4(0, 0, 0, 0);\n        this._clearDepthColor = new Color4(0, 0, 0, 1); // sets an invalid value by default - depth in the depth texture is view.z, so 0 is not possible because view.z can't be less than camera.minZ\n        this._positionIndex = -1;\n        this._velocityIndex = -1;\n        this._velocityLinearIndex = -1;\n        this._reflectivityIndex = -1;\n        this._depthIndex = -1;\n        this._normalIndex = -1;\n        this._screenspaceDepthIndex = -1;\n        this._linkedWithPrePass = false;\n        /**\n         * If set to true (default: false), the depth texture will be cleared with the depth value corresponding to the far plane (1 in normal mode, 0 in reverse depth buffer mode)\n         * If set to false, the depth texture is always cleared with 0.\n         */\n        this.useSpecificClearForDepthTexture = false;\n        /** Shader language used by the material */\n        this._shaderLanguage = 0 /* ShaderLanguage.GLSL */;\n        this._shadersLoaded = false;\n        this._scene = scene;\n        this._ratioOrDimensions = ratioOrDimensions;\n        this._useUbo = scene.getEngine().supportsUniformBuffers;\n        this._depthFormat = depthFormat;\n        this._textureTypesAndFormats = textureTypesAndFormats || {};\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this._initShaderSourceAsync();\n        GeometryBufferRenderer._SceneComponentInitialization(this._scene);\n        // Render target\n        this._createRenderTargets();\n    }\n    async _initShaderSourceAsync() {\n        const engine = this._scene.getEngine();\n        if (engine.isWebGPU && !GeometryBufferRenderer.ForceGLSL) {\n            this._shaderLanguage = 1 /* ShaderLanguage.WGSL */;\n            await Promise.all([import(\"../ShadersWGSL/geometry.vertex\"), import(\"../ShadersWGSL/geometry.fragment\")]);\n        }\n        else {\n            await Promise.all([import(\"../Shaders/geometry.vertex\"), import(\"../Shaders/geometry.fragment\")]);\n        }\n        this._shadersLoaded = true;\n    }\n    /**\n     * Checks whether everything is ready to render a submesh to the G buffer.\n     * @param subMesh the submesh to check readiness for\n     * @param useInstances is the mesh drawn using instance or not\n     * @returns true if ready otherwise false\n     */\n    isReady(subMesh, useInstances) {\n        if (!this._shadersLoaded) {\n            return false;\n        }\n        const material = subMesh.getMaterial();\n        if (material && material.disableDepthWrite) {\n            return false;\n        }\n        const defines = [];\n        const attribs = [VertexBuffer.PositionKind];\n        const mesh = subMesh.getMesh();\n        const hasNormals = mesh.isVerticesDataPresent(VertexBuffer.NormalKind);\n        if (hasNormals) {\n            defines.push(\"#define HAS_NORMAL_ATTRIBUTE\");\n            attribs.push(VertexBuffer.NormalKind);\n        }\n        let uv1 = false;\n        let uv2 = false;\n        const color = false;\n        if (material) {\n            let needUv = false;\n            // Alpha test\n            if (material.needAlphaTestingForMesh(mesh) && material.getAlphaTestTexture()) {\n                defines.push(\"#define ALPHATEST\");\n                defines.push(`#define ALPHATEST_UV${material.getAlphaTestTexture().coordinatesIndex + 1}`);\n                needUv = true;\n            }\n            // Normal map texture\n            if ((material.bumpTexture || material.normalTexture || material.geometryNormalTexture) && MaterialFlags.BumpTextureEnabled) {\n                const texture = material.bumpTexture || material.normalTexture || material.geometryNormalTexture;\n                defines.push(\"#define BUMP\");\n                defines.push(`#define BUMP_UV${texture.coordinatesIndex + 1}`);\n                needUv = true;\n            }\n            if (this._enableReflectivity) {\n                let metallicWorkflow = false;\n                // for PBR materials: cf. https://doc.babylonjs.com/features/featuresDeepDive/materials/using/masterPBR\n                if (material.getClassName() === \"PBRMetallicRoughnessMaterial\") {\n                    // if it is a PBR material in MetallicRoughness Mode:\n                    if (material.metallicRoughnessTexture) {\n                        defines.push(\"#define ORMTEXTURE\");\n                        defines.push(`#define REFLECTIVITY_UV${material.metallicRoughnessTexture.coordinatesIndex + 1}`);\n                        defines.push(\"#define METALLICWORKFLOW\");\n                        needUv = true;\n                        metallicWorkflow = true;\n                    }\n                    // null or undefined\n                    if (material.metallic != null) {\n                        defines.push(\"#define METALLIC\");\n                        defines.push(\"#define METALLICWORKFLOW\");\n                        metallicWorkflow = true;\n                    }\n                    // null or undefined\n                    if (material.roughness != null) {\n                        defines.push(\"#define ROUGHNESS\");\n                        defines.push(\"#define METALLICWORKFLOW\");\n                        metallicWorkflow = true;\n                    }\n                    if (metallicWorkflow) {\n                        if (material.baseTexture) {\n                            defines.push(\"#define ALBEDOTEXTURE\");\n                            defines.push(`#define ALBEDO_UV${material.baseTexture.coordinatesIndex + 1}`);\n                            if (material.baseTexture.gammaSpace) {\n                                defines.push(\"#define GAMMAALBEDO\");\n                            }\n                            needUv = true;\n                        }\n                        if (material.baseColor) {\n                            defines.push(\"#define ALBEDOCOLOR\");\n                        }\n                    }\n                }\n                else if (material.getClassName() === \"PBRSpecularGlossinessMaterial\") {\n                    // if it is a PBR material in Specular/Glossiness Mode:\n                    if (material.specularGlossinessTexture) {\n                        defines.push(\"#define SPECULARGLOSSINESSTEXTURE\");\n                        defines.push(`#define REFLECTIVITY_UV${material.specularGlossinessTexture.coordinatesIndex + 1}`);\n                        needUv = true;\n                        if (material.specularGlossinessTexture.gammaSpace) {\n                            defines.push(\"#define GAMMAREFLECTIVITYTEXTURE\");\n                        }\n                    }\n                    else {\n                        if (material.specularColor) {\n                            defines.push(\"#define REFLECTIVITYCOLOR\");\n                        }\n                    }\n                    // null or undefined\n                    if (material.glossiness != null) {\n                        defines.push(\"#define GLOSSINESS\");\n                    }\n                }\n                else if (material.getClassName() === \"PBRMaterial\") {\n                    // if it is the bigger PBRMaterial\n                    if (material.metallicTexture) {\n                        defines.push(\"#define ORMTEXTURE\");\n                        defines.push(`#define REFLECTIVITY_UV${material.metallicTexture.coordinatesIndex + 1}`);\n                        defines.push(\"#define METALLICWORKFLOW\");\n                        needUv = true;\n                        metallicWorkflow = true;\n                    }\n                    // null or undefined\n                    if (material.metallic != null) {\n                        defines.push(\"#define METALLIC\");\n                        defines.push(\"#define METALLICWORKFLOW\");\n                        metallicWorkflow = true;\n                    }\n                    // null or undefined\n                    if (material.roughness != null) {\n                        defines.push(\"#define ROUGHNESS\");\n                        defines.push(\"#define METALLICWORKFLOW\");\n                        metallicWorkflow = true;\n                    }\n                    if (metallicWorkflow) {\n                        if (material.albedoTexture) {\n                            defines.push(\"#define ALBEDOTEXTURE\");\n                            defines.push(`#define ALBEDO_UV${material.albedoTexture.coordinatesIndex + 1}`);\n                            if (material.albedoTexture.gammaSpace) {\n                                defines.push(\"#define GAMMAALBEDO\");\n                            }\n                            needUv = true;\n                        }\n                        if (material.albedoColor) {\n                            defines.push(\"#define ALBEDOCOLOR\");\n                        }\n                    }\n                    else {\n                        // SpecularGlossiness Model\n                        if (material.reflectivityTexture) {\n                            defines.push(\"#define SPECULARGLOSSINESSTEXTURE\");\n                            defines.push(`#define REFLECTIVITY_UV${material.reflectivityTexture.coordinatesIndex + 1}`);\n                            if (material.reflectivityTexture.gammaSpace) {\n                                defines.push(\"#define GAMMAREFLECTIVITYTEXTURE\");\n                            }\n                            needUv = true;\n                        }\n                        else if (material.reflectivityColor) {\n                            defines.push(\"#define REFLECTIVITYCOLOR\");\n                        }\n                        // null or undefined\n                        if (material.microSurface != null) {\n                            defines.push(\"#define GLOSSINESS\");\n                        }\n                    }\n                }\n                else if (material.getClassName() === \"StandardMaterial\") {\n                    // if StandardMaterial:\n                    if (material.specularTexture) {\n                        defines.push(\"#define REFLECTIVITYTEXTURE\");\n                        defines.push(`#define REFLECTIVITY_UV${material.specularTexture.coordinatesIndex + 1}`);\n                        if (material.specularTexture.gammaSpace) {\n                            defines.push(\"#define GAMMAREFLECTIVITYTEXTURE\");\n                        }\n                        needUv = true;\n                    }\n                    if (material.specularColor) {\n                        defines.push(\"#define REFLECTIVITYCOLOR\");\n                    }\n                }\n                else if (material.getClassName() === \"OpenPBRMaterial\") {\n                    const pbrMaterial = material;\n                    defines.push(\"#define METALLICWORKFLOW\");\n                    metallicWorkflow = true;\n                    defines.push(\"#define METALLIC\");\n                    defines.push(\"#define ROUGHNESS\");\n                    if (pbrMaterial._useRoughnessFromMetallicTextureGreen && pbrMaterial.baseMetalnessTexture) {\n                        defines.push(\"#define ORMTEXTURE\");\n                        defines.push(`#define REFLECTIVITY_UV${pbrMaterial.baseMetalnessTexture.coordinatesIndex + 1}`);\n                        needUv = true;\n                    }\n                    else if (pbrMaterial.baseMetalnessTexture) {\n                        defines.push(\"#define METALLIC_TEXTURE\");\n                        defines.push(`#define METALLIC_UV${pbrMaterial.baseMetalnessTexture.coordinatesIndex + 1}`);\n                        needUv = true;\n                    }\n                    else if (pbrMaterial.specularRoughnessTexture) {\n                        defines.push(\"#define ROUGHNESS_TEXTURE\");\n                        defines.push(`#define ROUGHNESS_UV${pbrMaterial.specularRoughnessTexture.coordinatesIndex + 1}`);\n                        needUv = true;\n                    }\n                    if (pbrMaterial.baseColorTexture) {\n                        defines.push(\"#define ALBEDOTEXTURE\");\n                        defines.push(`#define ALBEDO_UV${pbrMaterial.baseColorTexture.coordinatesIndex + 1}`);\n                        if (pbrMaterial.baseColorTexture.gammaSpace) {\n                            defines.push(\"#define GAMMAALBEDO\");\n                        }\n                        needUv = true;\n                    }\n                    if (pbrMaterial.baseColor) {\n                        defines.push(\"#define ALBEDOCOLOR\");\n                    }\n                }\n            }\n            if (needUv) {\n                defines.push(\"#define NEED_UV\");\n                if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n                    attribs.push(VertexBuffer.UVKind);\n                    defines.push(\"#define UV1\");\n                    uv1 = true;\n                }\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n                    attribs.push(VertexBuffer.UV2Kind);\n                    defines.push(\"#define UV2\");\n                    uv2 = true;\n                }\n            }\n        }\n        // Buffers\n        if (this._enableDepth) {\n            defines.push(\"#define DEPTH\");\n            defines.push(\"#define DEPTH_INDEX \" + this._depthIndex);\n        }\n        if (this._enableNormal) {\n            defines.push(\"#define NORMAL\");\n            defines.push(\"#define NORMAL_INDEX \" + this._normalIndex);\n        }\n        if (this._enablePosition) {\n            defines.push(\"#define POSITION\");\n            defines.push(\"#define POSITION_INDEX \" + this._positionIndex);\n        }\n        if (this._enableVelocity) {\n            defines.push(\"#define VELOCITY\");\n            defines.push(\"#define VELOCITY_INDEX \" + this._velocityIndex);\n            if (this.excludedSkinnedMeshesFromVelocity.indexOf(mesh) === -1) {\n                defines.push(\"#define BONES_VELOCITY_ENABLED\");\n            }\n        }\n        if (this._enableVelocityLinear) {\n            defines.push(\"#define VELOCITY_LINEAR\");\n            defines.push(\"#define VELOCITY_LINEAR_INDEX \" + this._velocityLinearIndex);\n            if (this.excludedSkinnedMeshesFromVelocity.indexOf(mesh) === -1) {\n                defines.push(\"#define BONES_VELOCITY_ENABLED\");\n            }\n        }\n        if (this._enableReflectivity) {\n            defines.push(\"#define REFLECTIVITY\");\n            defines.push(\"#define REFLECTIVITY_INDEX \" + this._reflectivityIndex);\n        }\n        if (this._enableScreenspaceDepth) {\n            if (this._screenspaceDepthIndex !== -1) {\n                defines.push(\"#define SCREENSPACE_DEPTH_INDEX \" + this._screenspaceDepthIndex);\n                defines.push(\"#define SCREENSPACE_DEPTH\");\n            }\n        }\n        if (this.generateNormalsInWorldSpace) {\n            defines.push(\"#define NORMAL_WORLDSPACE\");\n        }\n        if (this._normalsAreUnsigned) {\n            defines.push(\"#define ENCODE_NORMAL\");\n        }\n        // Bones\n        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n            attribs.push(VertexBuffer.MatricesIndicesKind);\n            attribs.push(VertexBuffer.MatricesWeightsKind);\n            if (mesh.numBoneInfluencers > 4) {\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n            }\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n            defines.push(\"#define BONETEXTURE \" + mesh.skeleton.isUsingTextureForMatrices);\n            defines.push(\"#define BonesPerMesh \" + (mesh.skeleton.bones.length + 1));\n        }\n        else {\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n            defines.push(\"#define BONETEXTURE false\");\n            defines.push(\"#define BonesPerMesh 0\");\n        }\n        // Morph targets\n        const numMorphInfluencers = mesh.morphTargetManager\n            ? PrepareDefinesAndAttributesForMorphTargets(mesh.morphTargetManager, defines, attribs, mesh, true, // usePositionMorph\n            true, // useNormalMorph\n            false, // useTangentMorph\n            uv1, // useUVMorph\n            uv2, // useUV2Morph\n            color // useColorMorph\n            )\n            : 0;\n        // Instances\n        if (useInstances) {\n            defines.push(\"#define INSTANCES\");\n            PushAttributesForInstances(attribs, this._enableVelocity || this._enableVelocityLinear);\n            if (subMesh.getRenderingMesh().hasThinInstances) {\n                defines.push(\"#define THIN_INSTANCES\");\n            }\n        }\n        // Setup textures count\n        if (this._linkedWithPrePass) {\n            defines.push(\"#define SCENE_MRT_COUNT \" + this._attachmentsFromPrePass.length);\n        }\n        else {\n            defines.push(\"#define SCENE_MRT_COUNT \" + this._multiRenderTarget.textures.length);\n        }\n        PrepareStringDefinesForClipPlanes(material, this._scene, defines);\n        // Get correct effect\n        const engine = this._scene.getEngine();\n        const drawWrapper = subMesh._getDrawWrapper(undefined, true);\n        const cachedDefines = drawWrapper.defines;\n        const join = defines.join(\"\\n\");\n        if (cachedDefines !== join) {\n            drawWrapper.setEffect(engine.createEffect(\"geometry\", {\n                attributes: attribs,\n                uniformsNames: Uniforms,\n                samplers: [\"diffuseSampler\", \"bumpSampler\", \"reflectivitySampler\", \"albedoSampler\", \"morphTargets\", \"boneSampler\"],\n                defines: join,\n                onCompiled: null,\n                fallbacks: null,\n                onError: null,\n                uniformBuffersNames: [\"Scene\"],\n                indexParameters: { buffersCount: this._multiRenderTarget.textures.length - 1, maxSimultaneousMorphTargets: numMorphInfluencers },\n                shaderLanguage: this.shaderLanguage,\n            }, engine), join);\n        }\n        return drawWrapper.effect.isReady();\n    }\n    /**\n     * Gets the current underlying G Buffer.\n     * @returns the buffer\n     */\n    getGBuffer() {\n        return this._multiRenderTarget;\n    }\n    /**\n     * Gets the number of samples used to render the buffer (anti aliasing).\n     */\n    get samples() {\n        return this._multiRenderTarget.samples;\n    }\n    /**\n     * Sets the number of samples used to render the buffer (anti aliasing).\n     */\n    set samples(value) {\n        this._multiRenderTarget.samples = value;\n    }\n    /**\n     * Disposes the renderer and frees up associated resources.\n     */\n    dispose() {\n        if (this._resizeObserver) {\n            const engine = this._scene.getEngine();\n            engine.onResizeObservable.remove(this._resizeObserver);\n            this._resizeObserver = null;\n        }\n        this.getGBuffer().dispose();\n    }\n    _assignRenderTargetIndices() {\n        const textureNames = [];\n        const textureTypesAndFormats = [];\n        let count = 0;\n        if (this._enableDepth) {\n            this._depthIndex = count;\n            count++;\n            textureNames.push(\"gBuffer_Depth\");\n            textureTypesAndFormats.push(this._textureTypesAndFormats[GeometryBufferRenderer.DEPTH_TEXTURE_TYPE]);\n        }\n        if (this._enableNormal) {\n            this._normalIndex = count;\n            count++;\n            textureNames.push(\"gBuffer_Normal\");\n            textureTypesAndFormats.push(this._textureTypesAndFormats[GeometryBufferRenderer.NORMAL_TEXTURE_TYPE]);\n        }\n        if (this._enablePosition) {\n            this._positionIndex = count;\n            count++;\n            textureNames.push(\"gBuffer_Position\");\n            textureTypesAndFormats.push(this._textureTypesAndFormats[GeometryBufferRenderer.POSITION_TEXTURE_TYPE]);\n        }\n        if (this._enableVelocity) {\n            this._velocityIndex = count;\n            count++;\n            textureNames.push(\"gBuffer_Velocity\");\n            textureTypesAndFormats.push(this._textureTypesAndFormats[GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE]);\n        }\n        if (this._enableVelocityLinear) {\n            this._velocityLinearIndex = count;\n            count++;\n            textureNames.push(\"gBuffer_VelocityLinear\");\n            textureTypesAndFormats.push(this._textureTypesAndFormats[GeometryBufferRenderer.VELOCITY_LINEAR_TEXTURE_TYPE]);\n        }\n        if (this._enableReflectivity) {\n            this._reflectivityIndex = count;\n            count++;\n            textureNames.push(\"gBuffer_Reflectivity\");\n            textureTypesAndFormats.push(this._textureTypesAndFormats[GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE]);\n        }\n        if (this._enableScreenspaceDepth) {\n            this._screenspaceDepthIndex = count;\n            count++;\n            textureNames.push(\"gBuffer_ScreenspaceDepth\");\n            textureTypesAndFormats.push(this._textureTypesAndFormats[GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE]);\n        }\n        return [count, textureNames, textureTypesAndFormats];\n    }\n    _createRenderTargets() {\n        const engine = this._scene.getEngine();\n        const [count, textureNames, textureTypesAndFormat] = this._assignRenderTargetIndices();\n        let type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\n        if (engine._caps.textureFloat && engine._caps.textureFloatLinearFiltering) {\n            type = Constants.TEXTURETYPE_FLOAT;\n        }\n        else if (engine._caps.textureHalfFloat && engine._caps.textureHalfFloatLinearFiltering) {\n            type = Constants.TEXTURETYPE_HALF_FLOAT;\n        }\n        const dimensions = this._ratioOrDimensions.width !== undefined\n            ? this._ratioOrDimensions\n            : { width: engine.getRenderWidth() * this._ratioOrDimensions, height: engine.getRenderHeight() * this._ratioOrDimensions };\n        const textureTypes = [];\n        const textureFormats = [];\n        for (const typeAndFormat of textureTypesAndFormat) {\n            if (typeAndFormat) {\n                textureTypes.push(typeAndFormat.textureType);\n                textureFormats.push(typeAndFormat.textureFormat);\n            }\n            else {\n                textureTypes.push(type);\n                textureFormats.push(Constants.TEXTUREFORMAT_RGBA);\n            }\n        }\n        this._normalsAreUnsigned =\n            textureTypes[GeometryBufferRenderer.NORMAL_TEXTURE_TYPE] === Constants.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV ||\n                textureTypes[GeometryBufferRenderer.NORMAL_TEXTURE_TYPE] === Constants.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV;\n        this._multiRenderTarget = new MultiRenderTarget(\"gBuffer\", dimensions, count, this._scene, { generateMipMaps: false, generateDepthTexture: true, types: textureTypes, formats: textureFormats, depthTextureFormat: this._depthFormat }, textureNames.concat(\"gBuffer_DepthBuffer\"));\n        if (!this.isSupported) {\n            return;\n        }\n        this._multiRenderTarget.wrapU = Texture.CLAMP_ADDRESSMODE;\n        this._multiRenderTarget.wrapV = Texture.CLAMP_ADDRESSMODE;\n        this._multiRenderTarget.refreshRate = 1;\n        this._multiRenderTarget.renderParticles = false;\n        this._multiRenderTarget.renderList = null;\n        // Depth is always the first texture in the geometry buffer renderer!\n        const layoutAttachmentsAll = [true];\n        const layoutAttachmentsAllButDepth = [false];\n        const layoutAttachmentsDepthOnly = [true];\n        for (let i = 1; i < count; ++i) {\n            layoutAttachmentsAll.push(true);\n            layoutAttachmentsDepthOnly.push(false);\n            layoutAttachmentsAllButDepth.push(true);\n        }\n        const attachmentsAll = engine.buildTextureLayout(layoutAttachmentsAll);\n        const attachmentsAllButDepth = engine.buildTextureLayout(layoutAttachmentsAllButDepth);\n        const attachmentsDepthOnly = engine.buildTextureLayout(layoutAttachmentsDepthOnly);\n        this._multiRenderTarget.onClearObservable.add((engine) => {\n            engine.bindAttachments(this.useSpecificClearForDepthTexture ? attachmentsAllButDepth : attachmentsAll);\n            engine.clear(this._clearColor, true, true, true);\n            if (this.useSpecificClearForDepthTexture) {\n                engine.bindAttachments(attachmentsDepthOnly);\n                engine.clear(this._clearDepthColor, true, true, true);\n            }\n            engine.bindAttachments(attachmentsAll);\n        });\n        this._resizeObserver = engine.onResizeObservable.add(() => {\n            if (this._multiRenderTarget) {\n                const dimensions = this._ratioOrDimensions.width !== undefined\n                    ? this._ratioOrDimensions\n                    : { width: engine.getRenderWidth() * this._ratioOrDimensions, height: engine.getRenderHeight() * this._ratioOrDimensions };\n                this._multiRenderTarget.resize(dimensions);\n            }\n        });\n        // Custom render function\n        const renderSubMesh = (subMesh) => {\n            const renderingMesh = subMesh.getRenderingMesh();\n            const effectiveMesh = subMesh.getEffectiveMesh();\n            const scene = this._scene;\n            const engine = scene.getEngine();\n            const material = subMesh.getMaterial();\n            if (!material) {\n                return;\n            }\n            effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n            // Velocity\n            if ((this._enableVelocity || this._enableVelocityLinear) && !this._previousTransformationMatrices[effectiveMesh.uniqueId]) {\n                this._previousTransformationMatrices[effectiveMesh.uniqueId] = {\n                    world: Matrix.Identity(),\n                    viewProjection: scene.getTransformMatrix(),\n                };\n                if (renderingMesh.skeleton) {\n                    const bonesTransformations = renderingMesh.skeleton.getTransformMatrices(renderingMesh);\n                    this._previousBonesTransformationMatrices[renderingMesh.uniqueId] = this._copyBonesTransformationMatrices(bonesTransformations, new Float32Array(bonesTransformations.length));\n                }\n            }\n            // Managing instances\n            const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n            if (batch.mustReturn) {\n                return;\n            }\n            const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\n            const world = effectiveMesh.getWorldMatrix();\n            if (this.isReady(subMesh, hardwareInstancedRendering)) {\n                const drawWrapper = subMesh._getDrawWrapper();\n                if (!drawWrapper) {\n                    return;\n                }\n                const effect = drawWrapper.effect;\n                engine.enableEffect(drawWrapper);\n                if (!hardwareInstancedRendering) {\n                    renderingMesh._bind(subMesh, effect, material.fillMode);\n                }\n                if (!this._useUbo) {\n                    effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n                    effect.setMatrix(\"view\", scene.getViewMatrix());\n                }\n                else {\n                    BindSceneUniformBuffer(effect, this._scene.getSceneUniformBuffer());\n                    this._scene.finalizeSceneUbo();\n                }\n                let sideOrientation;\n                const instanceDataStorage = renderingMesh._instanceDataStorage;\n                if (!instanceDataStorage.isFrozen && (material.backFaceCulling || material.sideOrientation !== null)) {\n                    const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\n                    sideOrientation = material._getEffectiveOrientation(renderingMesh);\n                    if (mainDeterminant < 0) {\n                        sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n                    }\n                }\n                else {\n                    sideOrientation = renderingMesh._effectiveSideOrientation;\n                }\n                material._preBind(drawWrapper, sideOrientation);\n                // Alpha test\n                if (material.needAlphaTestingForMesh(effectiveMesh)) {\n                    const alphaTexture = material.getAlphaTestTexture();\n                    if (alphaTexture) {\n                        effect.setTexture(\"diffuseSampler\", alphaTexture);\n                        effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n                    }\n                }\n                // Bump\n                if ((material.bumpTexture || material.normalTexture || material.geometryNormalTexture) &&\n                    scene.getEngine().getCaps().standardDerivatives &&\n                    MaterialFlags.BumpTextureEnabled) {\n                    const texture = material.bumpTexture || material.normalTexture || material.geometryNormalTexture;\n                    effect.setFloat3(\"vBumpInfos\", texture.coordinatesIndex, 1.0 / texture.level, material.parallaxScaleBias);\n                    effect.setMatrix(\"bumpMatrix\", texture.getTextureMatrix());\n                    effect.setTexture(\"bumpSampler\", texture);\n                    effect.setFloat2(\"vTangentSpaceParams\", material.invertNormalMapX ? -1.0 : 1.0, material.invertNormalMapY ? -1.0 : 1.0);\n                }\n                // Reflectivity\n                if (this._enableReflectivity) {\n                    // for PBR materials: cf. https://doc.babylonjs.com/features/featuresDeepDive/materials/using/masterPBR\n                    if (material.getClassName() === \"PBRMetallicRoughnessMaterial\") {\n                        // if it is a PBR material in MetallicRoughness Mode:\n                        if (material.metallicRoughnessTexture !== null) {\n                            effect.setTexture(\"reflectivitySampler\", material.metallicRoughnessTexture);\n                            effect.setMatrix(\"reflectivityMatrix\", material.metallicRoughnessTexture.getTextureMatrix());\n                        }\n                        if (material.metallic !== null) {\n                            effect.setFloat(\"metallic\", material.metallic);\n                        }\n                        if (material.roughness !== null) {\n                            effect.setFloat(\"glossiness\", 1.0 - material.roughness);\n                        }\n                        if (material.baseTexture !== null) {\n                            effect.setTexture(\"albedoSampler\", material.baseTexture);\n                            effect.setMatrix(\"albedoMatrix\", material.baseTexture.getTextureMatrix());\n                        }\n                        if (material.baseColor !== null) {\n                            effect.setColor3(\"albedoColor\", material.baseColor);\n                        }\n                    }\n                    else if (material.getClassName() === \"PBRSpecularGlossinessMaterial\") {\n                        // if it is a PBR material in Specular/Glossiness Mode:\n                        if (material.specularGlossinessTexture !== null) {\n                            effect.setTexture(\"reflectivitySampler\", material.specularGlossinessTexture);\n                            effect.setMatrix(\"reflectivityMatrix\", material.specularGlossinessTexture.getTextureMatrix());\n                        }\n                        else {\n                            if (material.specularColor !== null) {\n                                effect.setColor3(\"reflectivityColor\", material.specularColor);\n                            }\n                        }\n                        if (material.glossiness !== null) {\n                            effect.setFloat(\"glossiness\", material.glossiness);\n                        }\n                    }\n                    else if (material.getClassName() === \"PBRMaterial\") {\n                        // if it is the bigger PBRMaterial\n                        if (material.metallicTexture !== null) {\n                            effect.setTexture(\"reflectivitySampler\", material.metallicTexture);\n                            effect.setMatrix(\"reflectivityMatrix\", material.metallicTexture.getTextureMatrix());\n                        }\n                        if (material.metallic !== null) {\n                            effect.setFloat(\"metallic\", material.metallic);\n                        }\n                        if (material.roughness !== null) {\n                            effect.setFloat(\"glossiness\", 1.0 - material.roughness);\n                        }\n                        if (material.roughness !== null || material.metallic !== null || material.metallicTexture !== null) {\n                            // MetallicRoughness Model\n                            if (material.albedoTexture !== null) {\n                                effect.setTexture(\"albedoSampler\", material.albedoTexture);\n                                effect.setMatrix(\"albedoMatrix\", material.albedoTexture.getTextureMatrix());\n                            }\n                            if (material.albedoColor !== null) {\n                                effect.setColor3(\"albedoColor\", material.albedoColor);\n                            }\n                        }\n                        else {\n                            // SpecularGlossiness Model\n                            if (material.reflectivityTexture !== null) {\n                                effect.setTexture(\"reflectivitySampler\", material.reflectivityTexture);\n                                effect.setMatrix(\"reflectivityMatrix\", material.reflectivityTexture.getTextureMatrix());\n                            }\n                            else if (material.reflectivityColor !== null) {\n                                effect.setColor3(\"reflectivityColor\", material.reflectivityColor);\n                            }\n                            if (material.microSurface !== null) {\n                                effect.setFloat(\"glossiness\", material.microSurface);\n                            }\n                        }\n                    }\n                    else if (material.getClassName() === \"StandardMaterial\") {\n                        // if StandardMaterial:\n                        if (material.specularTexture !== null) {\n                            effect.setTexture(\"reflectivitySampler\", material.specularTexture);\n                            effect.setMatrix(\"reflectivityMatrix\", material.specularTexture.getTextureMatrix());\n                        }\n                        if (material.specularColor !== null) {\n                            effect.setColor3(\"reflectivityColor\", material.specularColor);\n                        }\n                    }\n                    else if (material.getClassName() === \"OpenPBRMaterial\") {\n                        // if it is a OpenPBR material:\n                        const openpbrMaterial = material;\n                        if (openpbrMaterial._useRoughnessFromMetallicTextureGreen && openpbrMaterial.baseMetalnessTexture) {\n                            effect.setTexture(\"reflectivitySampler\", openpbrMaterial.baseMetalnessTexture);\n                            effect.setMatrix(\"reflectivityMatrix\", openpbrMaterial.baseMetalnessTexture.getTextureMatrix());\n                        }\n                        else if (openpbrMaterial.baseMetalnessTexture) {\n                            effect.setTexture(\"metallicSampler\", openpbrMaterial.baseMetalnessTexture);\n                            effect.setMatrix(\"metallicMatrix\", openpbrMaterial.baseMetalnessTexture.getTextureMatrix());\n                        }\n                        else if (openpbrMaterial.specularRoughnessTexture) {\n                            effect.setTexture(\"roughnessSampler\", openpbrMaterial.specularRoughnessTexture);\n                            effect.setMatrix(\"roughnessMatrix\", openpbrMaterial.specularRoughnessTexture.getTextureMatrix());\n                        }\n                        effect.setFloat(\"metallic\", openpbrMaterial.baseMetalness);\n                        effect.setFloat(\"glossiness\", 1.0 - openpbrMaterial.specularRoughness);\n                        if (openpbrMaterial.baseColorTexture !== null) {\n                            effect.setTexture(\"albedoSampler\", openpbrMaterial.baseColorTexture);\n                            effect.setMatrix(\"albedoMatrix\", openpbrMaterial.baseColorTexture.getTextureMatrix());\n                        }\n                        if (openpbrMaterial.baseColor !== null) {\n                            effect.setColor3(\"albedoColor\", openpbrMaterial.baseColor);\n                        }\n                    }\n                }\n                // Clip plane\n                BindClipPlane(effect, material, this._scene);\n                // Bones\n                if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n                    const skeleton = renderingMesh.skeleton;\n                    if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex(\"boneTextureWidth\") > -1) {\n                        const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\n                        effect.setTexture(\"boneSampler\", boneTexture);\n                        effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n                    }\n                    else {\n                        effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\n                    }\n                    if (this._enableVelocity || this._enableVelocityLinear) {\n                        effect.setMatrices(\"mPreviousBones\", this._previousBonesTransformationMatrices[renderingMesh.uniqueId]);\n                    }\n                }\n                // Morph targets\n                BindMorphTargetParameters(renderingMesh, effect);\n                if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\n                    renderingMesh.morphTargetManager._bind(effect);\n                }\n                // Velocity\n                if (this._enableVelocity || this._enableVelocityLinear) {\n                    effect.setMatrix(\"previousWorld\", this._previousTransformationMatrices[effectiveMesh.uniqueId].world);\n                    effect.setMatrix(\"previousViewProjection\", this._previousTransformationMatrices[effectiveMesh.uniqueId].viewProjection);\n                }\n                if (hardwareInstancedRendering && renderingMesh.hasThinInstances) {\n                    effect.setMatrix(\"world\", world);\n                }\n                // Draw\n                renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, w) => {\n                    if (!isInstance) {\n                        effect.setMatrix(\"world\", w);\n                    }\n                });\n            }\n            // Velocity\n            if (this._enableVelocity || this._enableVelocityLinear) {\n                this._previousTransformationMatrices[effectiveMesh.uniqueId].world = world.clone();\n                this._previousTransformationMatrices[effectiveMesh.uniqueId].viewProjection = this._scene.getTransformMatrix().clone();\n                if (renderingMesh.skeleton) {\n                    this._copyBonesTransformationMatrices(renderingMesh.skeleton.getTransformMatrices(renderingMesh), this._previousBonesTransformationMatrices[effectiveMesh.uniqueId]);\n                }\n            }\n        };\n        this._multiRenderTarget.customIsReadyFunction = (mesh, refreshRate, preWarm) => {\n            if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\n                for (let i = 0; i < mesh.subMeshes.length; ++i) {\n                    const subMesh = mesh.subMeshes[i];\n                    const material = subMesh.getMaterial();\n                    const renderingMesh = subMesh.getRenderingMesh();\n                    if (!material) {\n                        continue;\n                    }\n                    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n                    const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\n                    if (!this.isReady(subMesh, hardwareInstancedRendering)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        this._multiRenderTarget.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {\n            let index;\n            if (this._linkedWithPrePass) {\n                if (!this._prePassRenderer.enabled) {\n                    return;\n                }\n                this._scene.getEngine().bindAttachments(this._attachmentsFromPrePass);\n            }\n            if (depthOnlySubMeshes.length) {\n                engine.setColorWrite(false);\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\n                    renderSubMesh(depthOnlySubMeshes.data[index]);\n                }\n                engine.setColorWrite(true);\n            }\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\n                renderSubMesh(opaqueSubMeshes.data[index]);\n            }\n            engine.setDepthWrite(false);\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\n                renderSubMesh(alphaTestSubMeshes.data[index]);\n            }\n            if (this.renderTransparentMeshes) {\n                for (index = 0; index < transparentSubMeshes.length; index++) {\n                    renderSubMesh(transparentSubMeshes.data[index]);\n                }\n            }\n            engine.setDepthWrite(true);\n        };\n    }\n    // Copies the bones transformation matrices into the target array and returns the target's reference\n    _copyBonesTransformationMatrices(source, target) {\n        for (let i = 0; i < source.length; i++) {\n            target[i] = source[i];\n        }\n        return target;\n    }\n}\n/**\n * Force all the standard materials to compile to glsl even on WebGPU engines.\n * False by default. This is mostly meant for backward compatibility.\n */\nGeometryBufferRenderer.ForceGLSL = false;\n/**\n * Constant used to retrieve the depth texture index in the G-Buffer textures array\n * using getIndex(GeometryBufferRenderer.DEPTH_TEXTURE_INDEX)\n */\nGeometryBufferRenderer.DEPTH_TEXTURE_TYPE = 0;\n/**\n * Constant used to retrieve the normal texture index in the G-Buffer textures array\n * using getIndex(GeometryBufferRenderer.NORMAL_TEXTURE_INDEX)\n */\nGeometryBufferRenderer.NORMAL_TEXTURE_TYPE = 1;\n/**\n * Constant used to retrieve the position texture index in the G-Buffer textures array\n * using getIndex(GeometryBufferRenderer.POSITION_TEXTURE_INDEX)\n */\nGeometryBufferRenderer.POSITION_TEXTURE_TYPE = 2;\n/**\n * Constant used to retrieve the velocity texture index in the G-Buffer textures array\n * using getIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_INDEX)\n */\nGeometryBufferRenderer.VELOCITY_TEXTURE_TYPE = 3;\n/**\n * Constant used to retrieve the reflectivity texture index in the G-Buffer textures array\n * using the getIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE)\n */\nGeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE = 4;\n/**\n * Constant used to retrieve the screen-space depth texture index in the G-Buffer textures array\n * using getIndex(GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE)\n */\nGeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE = 5;\n/**\n * Constant used to retrieve the linear velocity texture index in the G-Buffer textures array\n * using getIndex(GeometryBufferRenderer.VELOCITY_LINEAR_TEXTURE_TYPE)\n */\nGeometryBufferRenderer.VELOCITY_LINEAR_TEXTURE_TYPE = 6;\n/**\n * @internal\n */\nGeometryBufferRenderer._SceneComponentInitialization = (_) => {\n    throw _WarnImport(\"GeometryBufferRendererSceneComponent\");\n};\n//# sourceMappingURL=geometryBufferRenderer.js.map"],"names":["MultiRenderTarget","RenderTargetTexture","isSupported","this","_engine","getCaps","drawBuffersExtension","textures","_textures","count","_count","depthTexture","length","wrapU","wrap","i","wrapV","constructor","name","size","scene","options","textureNames","generateMipMaps","generateDepthTexture","depthTextureFormat","Constants","TEXTUREFORMAT_DEPTH16","doNotChangeAspectRatio","undefined","drawOnlyOnFirstAttachmentByDefault","super","dispose","_textureNames","types","samplingModes","useSRGBBuffers","formats","targetTypes","faceIndex","layerIndex","layerCounts","_initTypes","generateDepthBuffer","generateStencilBuffer","samples","_multiRenderTargetOptions","textureCount","labels","label","_drawOnlyOnFirstAttachmentByDefault","_createInternalTextures","_createTextures","targets","push","defaultType","TEXTURETYPE_UNSIGNED_BYTE","Texture","BILINEAR_SAMPLINGMODE","TEXTUREFORMAT_RGBA","TEXTURE_2D","_createInternaTextureIndexMapping","mapMainInternalTexture2Index","mapInternalTexture2MainIndex","_renderTarget","internalTextures","texture","mainIndex","uniqueId","_rebuild","fromContextLost","forceFullRebuild","releaseInternalTextures","_releaseTextures","setTexture","_texture","_noMipmap","useMipMaps","_useSRGBBuffer","setSamples","_getEngine","createMultipleRenderTarget","_size","getScene","setInternalTexture","index","disposePrevious","renderTarget","type","samplingMode","target","is2DArray","TEXTURE_2D_ARRAY","isCube","TEXTURE_CUBE_MAP","is3D","TEXTURE_3D","setLayerAndFaceIndex","setLayerAndFaceIndices","layerIndices","faceIndices","_samples","value","resize","_processSizeParameter","updateCount","_unbindFrameBuffer","engine","unBindMultiColorAttachmentFramebuffer","onAfterRenderObservable","notifyObservers","doNotDisposeInternalTextures","ShaderStore","IncludesShadersStore","shader","ShadersStore","geometryPixelShader","geometryVertexShader","Uniforms","AddClipPlaneUniforms","GeometryBufferRenderer","normalsAreUnsigned","_normalsAreUnsigned","_linkPrePassRenderer","prePassRenderer","_linkedWithPrePass","_prePassRenderer","_multiRenderTarget","onClearObservable","clear","add","_unlinkPrePassRenderer","_createRenderTargets","_resetLayout","_enableDepth","_enableNormal","_enablePosition","_enableReflectivity","_enableVelocity","_enableVelocityLinear","_enableScreenspaceDepth","_attachmentsFromPrePass","_forceTextureType","geometryBufferType","POSITION_TEXTURE_TYPE","_positionIndex","VELOCITY_TEXTURE_TYPE","_velocityIndex","VELOCITY_LINEAR_TEXTURE_TYPE","_velocityLinearIndex","REFLECTIVITY_TEXTURE_TYPE","_reflectivityIndex","DEPTH_TEXTURE_TYPE","_depthIndex","NORMAL_TEXTURE_TYPE","_normalIndex","SCREENSPACE_DEPTH_TEXTURE_TYPE","_screenspaceDepthIndex","_setAttachments","attachments","_linkInternalTexture","internalTexture","renderList","meshes","getTextureIndex","textureType","enableDepth","enable","enableNormal","enablePosition","enableVelocity","_previousTransformationMatrices","_scene","needsPreviousWorldMatrices","enableVelocityLinear","enableReflectivity","enableScreenspaceDepth","ratio","_ratioOrDimensions","shaderLanguage","_shaderLanguage","ratioOrDimensions","depthFormat","textureTypesAndFormats","_previousBonesTransformationMatrices","excludedSkinnedMeshesFromVelocity","renderTransparentMeshes","generateNormalsInWorldSpace","_resizeObserver","_clearColor","Color4","_clearDepthColor","useSpecificClearForDepthTexture","_shadersLoaded","_useUbo","getEngine","supportsUniformBuffers","_depthFormat","_textureTypesAndFormats","_initShaderSourceAsync","_SceneComponentInitialization","isWebGPU","ForceGLSL","Promise","all","import","resolve","then","geometry_vertex","geometry_fragment","isReady","subMesh","useInstances","material","getMaterial","disableDepthWrite","defines","attribs","VertexBuffer","PositionKind","mesh","getMesh","isVerticesDataPresent","NormalKind","uv1","uv2","needUv","needAlphaTestingForMesh","getAlphaTestTexture","coordinatesIndex","bumpTexture","normalTexture","geometryNormalTexture","MaterialFlags","BumpTextureEnabled","metallicWorkflow","getClassName","metallicRoughnessTexture","metallic","roughness","baseTexture","gammaSpace","baseColor","specularGlossinessTexture","specularColor","glossiness","metallicTexture","albedoTexture","albedoColor","reflectivityTexture","reflectivityColor","microSurface","specularTexture","pbrMaterial","_useRoughnessFromMetallicTextureGreen","baseMetalnessTexture","specularRoughnessTexture","baseColorTexture","UVKind","UV2Kind","indexOf","useBones","computeBonesUsingShaders","skeleton","MatricesIndicesKind","MatricesWeightsKind","numBoneInfluencers","MatricesIndicesExtraKind","MatricesWeightsExtraKind","isUsingTextureForMatrices","bones","numMorphInfluencers","morphTargetManager","PrepareDefinesAndAttributesForMorphTargets","PushAttributesForInstances","getRenderingMesh","hasThinInstances","PrepareStringDefinesForClipPlanes","drawWrapper","_getDrawWrapper","cachedDefines","join","setEffect","createEffect","attributes","uniformsNames","samplers","onCompiled","fallbacks","onError","uniformBuffersNames","indexParameters","buffersCount","maxSimultaneousMorphTargets","effect","getGBuffer","onResizeObservable","remove","_assignRenderTargetIndices","textureTypesAndFormat","_caps","textureFloat","textureFloatLinearFiltering","TEXTURETYPE_FLOAT","textureHalfFloat","textureHalfFloatLinearFiltering","TEXTURETYPE_HALF_FLOAT","dimensions","width","getRenderWidth","height","getRenderHeight","textureTypes","textureFormats","typeAndFormat","textureFormat","TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV","TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV","concat","CLAMP_ADDRESSMODE","refreshRate","renderParticles","layoutAttachmentsAll","layoutAttachmentsAllButDepth","layoutAttachmentsDepthOnly","attachmentsAll","buildTextureLayout","attachmentsAllButDepth","attachmentsDepthOnly","bindAttachments","renderSubMesh","renderingMesh","effectiveMesh","getEffectiveMesh","_internalAbstractMeshDataInfo","_isActiveIntermediate","world","Matrix","Identity","viewProjection","getTransformMatrix","bonesTransformations","getTransformMatrices","_copyBonesTransformationMatrices","Float32Array","batch","_getInstancesRenderList","_id","getReplacementMesh","mustReturn","hardwareInstancedRendering","instancedArrays","visibleInstances","getWorldMatrix","sideOrientation","enableEffect","_bind","fillMode","BindSceneUniformBuffer","getSceneUniformBuffer","finalizeSceneUbo","setMatrix","getViewMatrix","_instanceDataStorage","isFrozen","backFaceCulling","_effectiveSideOrientation","mainDeterminant","_getWorldMatrixDeterminant","_getEffectiveOrientation","Material","ClockWiseSideOrientation","CounterClockWiseSideOrientation","_preBind","alphaTexture","getTextureMatrix","standardDerivatives","setFloat3","level","parallaxScaleBias","setFloat2","invertNormalMapX","invertNormalMapY","setFloat","setColor3","openpbrMaterial","baseMetalness","specularRoughness","BindClipPlane","getUniformIndex","boneTexture","getTransformMatrixTexture","setMatrices","BindMorphTargetParameters","isUsingTextureForTargets","_processRendering","isInstance","w","clone","customIsReadyFunction","preWarm","subMeshes","customRenderFunction","opaqueSubMeshes","alphaTestSubMeshes","transparentSubMeshes","depthOnlySubMeshes","enabled","setColorWrite","data","setDepthWrite","source","_","_WarnImport"],"mappings":"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"}