{"version":3,"file":"iblShadowsRenderPipeline-BBromb0W.esm.min.js","sources":["../../../../../dev/core/dist/Rendering/IBLShadows/iblShadowsVoxelRenderer.js","../../../../../dev/core/dist/Rendering/IBLShadows/iblShadowsVoxelTracingPass.js","../../../../../dev/core/dist/Rendering/IBLShadows/iblShadowsSpatialBlurPass.js","../../../../../dev/core/dist/Rendering/IBLShadows/iblShadowsAccumulationPass.js","../../../../../dev/core/dist/Materials/Textures/rawTexture3D.js","../../../../../dev/core/dist/Rendering/IBLShadows/iblShadowsPluginMaterial.js","../../../../../dev/core/dist/Rendering/IBLShadows/iblShadowsRenderPipeline.js"],"sourcesContent":["import { Constants } from \"../../Engines/constants\";\nimport { Engine } from \"../../Engines/engine\";\nimport { ShaderMaterial } from \"../../Materials/shaderMaterial\";\nimport { MultiRenderTarget } from \"../../Materials/Textures/multiRenderTarget\";\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\nimport { Color4 } from \"../../Maths/math.color\";\nimport { Matrix, Vector3, Vector4 } from \"../../Maths/math.vector\";\nimport { Texture } from \"../../Materials/Textures/texture\";\nimport { Logger } from \"../../Misc/logger\";\nimport { Observable } from \"../../Misc/observable\";\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\nimport { ProceduralTexture } from \"../../Materials/Textures/Procedurals/proceduralTexture\";\nimport { EffectRenderer, EffectWrapper } from \"../../Materials/effectRenderer\";\n/**\n * Voxel-based shadow rendering for IBL's.\n * This should not be instanciated directly, as it is part of a scene component\n * @internal\n * @see https://playground.babylonjs.com/#8R5SSE#222\n */\nexport class _IblShadowsVoxelRenderer {\n    /**\n     * Return the voxel grid texture.\n     * @returns The voxel grid texture.\n     */\n    getVoxelGrid() {\n        if (this._triPlanarVoxelization) {\n            return this._voxelGridRT;\n        }\n        else {\n            return this._voxelGridZaxis;\n        }\n    }\n    /**\n     * The debug pass post process\n     * @returns The debug pass post process\n     */\n    getDebugPassPP() {\n        if (!this._voxelDebugPass) {\n            this._createDebugPass();\n        }\n        return this._voxelDebugPass;\n    }\n    /**\n     * Whether to use tri-planar voxelization. More expensive, but can help with artifacts.\n     */\n    get triPlanarVoxelization() {\n        return this._triPlanarVoxelization;\n    }\n    /**\n     * Whether to use tri-planar voxelization. More expensive, but can help with artifacts.\n     */\n    set triPlanarVoxelization(enabled) {\n        if (this._triPlanarVoxelization === enabled) {\n            return;\n        }\n        this._triPlanarVoxelization = enabled;\n        this._disposeVoxelTextures();\n        this._createTextures();\n    }\n    /**\n     * Set the matrix to use for scaling the world space to voxel space\n     * @param matrix The matrix to use for scaling the world space to voxel space\n     */\n    setWorldScaleMatrix(matrix) {\n        this._invWorldScaleMatrix = matrix;\n    }\n    /**\n     * @returns Whether voxelization is currently happening.\n     */\n    isVoxelizationInProgress() {\n        return this._voxelizationInProgress;\n    }\n    /**\n     * Resolution of the voxel grid. The final resolution will be 2^resolutionExp.\n     */\n    get voxelResolutionExp() {\n        return this._voxelResolutionExp;\n    }\n    /**\n     * Resolution of the voxel grid. The final resolution will be 2^resolutionExp.\n     */\n    set voxelResolutionExp(resolutionExp) {\n        if (this._voxelResolutionExp === resolutionExp && this._voxelGridZaxis) {\n            return;\n        }\n        this._voxelResolutionExp = Math.round(Math.min(Math.max(resolutionExp, 3), 9));\n        this._voxelResolution = Math.pow(2.0, this._voxelResolutionExp);\n        this._disposeVoxelTextures();\n        this._createTextures();\n    }\n    /**\n     * Shows only the voxels that were rendered along a particular axis (while using triPlanarVoxelization).\n     * If not set, the combined voxel grid will be shown.\n     * Note: This only works when the debugMipNumber is set to 0 because we don't generate mips for each axis.\n     * @param axis The axis to show (0 = x, 1 = y, 2 = z)\n     */\n    set voxelDebugAxis(axis) {\n        this._voxelDebugAxis = axis;\n    }\n    get voxelDebugAxis() {\n        return this._voxelDebugAxis;\n    }\n    /**\n     * Sets params that control the position and scaling of the debug display on the screen.\n     * @param x Screen X offset of the debug display (0-1)\n     * @param y Screen Y offset of the debug display (0-1)\n     * @param widthScale X scale of the debug display (0-1)\n     * @param heightScale Y scale of the debug display (0-1)\n     */\n    setDebugDisplayParams(x, y, widthScale, heightScale) {\n        this._debugSizeParams.set(x, y, widthScale, heightScale);\n    }\n    /**\n     * The mip level to show in the debug display\n     * @param mipNum The mip level to show in the debug display\n     */\n    setDebugMipNumber(mipNum) {\n        this._debugMipNumber = mipNum;\n    }\n    /**\n     * Sets the name of the debug pass\n     */\n    get debugPassName() {\n        return this._debugPassName;\n    }\n    /**\n     * Enable or disable the debug view for this pass\n     */\n    get voxelDebugEnabled() {\n        return this._voxelDebugEnabled;\n    }\n    set voxelDebugEnabled(enabled) {\n        if (this._voxelDebugEnabled === enabled) {\n            return;\n        }\n        this._voxelDebugEnabled = enabled;\n        if (enabled) {\n            this._voxelSlabDebugRT = new RenderTargetTexture(\"voxelSlabDebug\", { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, this._scene, {\n                generateDepthBuffer: true,\n                generateMipMaps: false,\n                type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n                format: Constants.TEXTUREFORMAT_RGBA,\n                samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n            });\n            this._voxelSlabDebugRT.noPrePassRenderer = true;\n        }\n        if (this._voxelSlabDebugRT) {\n            this._removeVoxelRTs([this._voxelSlabDebugRT]);\n        }\n        // Add the slab debug RT if needed.\n        if (this._voxelDebugEnabled) {\n            this._addRTsForRender([this._voxelSlabDebugRT], this._includedMeshes, this._voxelDebugAxis, 1, true);\n            this._setDebugBindingsBound = this._setDebugBindings.bind(this);\n            this._scene.onBeforeRenderObservable.add(this._setDebugBindingsBound);\n        }\n        else {\n            this._scene.onBeforeRenderObservable.removeCallback(this._setDebugBindingsBound);\n        }\n    }\n    /**\n     * Creates the debug post process effect for this pass\n     */\n    _createDebugPass() {\n        const isWebGPU = this._engine.isWebGPU;\n        if (!this._voxelDebugPass) {\n            const debugOptions = {\n                width: this._engine.getRenderWidth(),\n                height: this._engine.getRenderHeight(),\n                textureFormat: Constants.TEXTUREFORMAT_RGBA,\n                textureType: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n                samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n                uniforms: [\"sizeParams\", \"mipNumber\"],\n                samplers: [\"voxelTexture\", \"voxelSlabTexture\"],\n                engine: this._engine,\n                reusable: false,\n                shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n                extraInitializations: (useWebGPU, list) => {\n                    if (this._isVoxelGrid3D) {\n                        if (useWebGPU) {\n                            list.push(import(\"../../ShadersWGSL/iblVoxelGrid3dDebug.fragment\"));\n                        }\n                        else {\n                            list.push(import(\"../../Shaders/iblVoxelGrid3dDebug.fragment\"));\n                        }\n                        return;\n                    }\n                    if (useWebGPU) {\n                        list.push(import(\"../../ShadersWGSL/iblVoxelGrid2dArrayDebug.fragment\"));\n                    }\n                    else {\n                        list.push(import(\"../../Shaders/iblVoxelGrid2dArrayDebug.fragment\"));\n                    }\n                },\n            };\n            this._voxelDebugPass = new PostProcess(this.debugPassName, this._isVoxelGrid3D ? \"iblVoxelGrid3dDebug\" : \"iblVoxelGrid2dArrayDebug\", debugOptions);\n            this._voxelDebugPass.onApplyObservable.add((effect) => {\n                if (this._voxelDebugAxis === 0) {\n                    effect.setTexture(\"voxelTexture\", this._voxelGridXaxis);\n                }\n                else if (this._voxelDebugAxis === 1) {\n                    effect.setTexture(\"voxelTexture\", this._voxelGridYaxis);\n                }\n                else if (this._voxelDebugAxis === 2) {\n                    effect.setTexture(\"voxelTexture\", this._voxelGridZaxis);\n                }\n                else {\n                    effect.setTexture(\"voxelTexture\", this.getVoxelGrid());\n                }\n                effect.setTexture(\"voxelSlabTexture\", this._voxelSlabDebugRT);\n                effect.setVector4(\"sizeParams\", this._debugSizeParams);\n                effect.setFloat(\"mipNumber\", this._debugMipNumber);\n            });\n        }\n    }\n    /**\n     * Instanciates the voxel renderer\n     * @param scene Scene to attach to\n     * @param iblShadowsRenderPipeline The render pipeline this pass is associated with\n     * @param resolutionExp Resolution of the voxel grid. The final resolution will be 2^resolutionExp.\n     * @param triPlanarVoxelization Whether to use tri-planar voxelization. More expensive, but can help with artifacts.\n     * @returns The voxel renderer\n     */\n    constructor(scene, iblShadowsRenderPipeline, resolutionExp = 6, triPlanarVoxelization = true) {\n        this._voxelMrtsXaxis = [];\n        this._voxelMrtsYaxis = [];\n        this._voxelMrtsZaxis = [];\n        this._isVoxelGrid3D = true;\n        /**\n         * Observable that triggers when the voxelization is complete\n         */\n        this.onVoxelizationCompleteObservable = new Observable();\n        this._renderTargets = [];\n        this._triPlanarVoxelization = true;\n        this._voxelizationInProgress = false;\n        this._invWorldScaleMatrix = Matrix.Identity();\n        this._voxelResolution = 64;\n        this._voxelResolutionExp = 6;\n        this._mipArray = [];\n        this._voxelDebugEnabled = false;\n        this._voxelDebugAxis = -1;\n        this._debugSizeParams = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this._includedMeshes = [];\n        this._debugMipNumber = 0;\n        this._debugPassName = \"Voxelization Debug Pass\";\n        this._scene = scene;\n        this._engine = scene.getEngine();\n        this._triPlanarVoxelization = triPlanarVoxelization;\n        if (!this._engine.getCaps().drawBuffersExtension) {\n            Logger.Error(\"Can't do voxel rendering without the draw buffers extension.\");\n        }\n        const isWebGPU = this._engine.isWebGPU;\n        this._maxDrawBuffers = this._engine.getCaps().maxDrawBuffers || 0;\n        this._copyMipEffectRenderer = new EffectRenderer(this._engine);\n        this._copyMipEffectWrapper = new EffectWrapper({\n            engine: this._engine,\n            fragmentShader: \"copyTexture3DLayerToTexture\",\n            useShaderStore: true,\n            uniformNames: [\"layerNum\"],\n            samplerNames: [\"textureSampler\"],\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await import(\"../../ShadersWGSL/copyTexture3DLayerToTexture.fragment\");\n                }\n                else {\n                    await import(\"../../Shaders/copyTexture3DLayerToTexture.fragment\");\n                }\n            },\n        });\n        this.voxelResolutionExp = resolutionExp;\n    }\n    _generateMipMaps() {\n        const iterations = Math.ceil(Math.log2(this._voxelResolution));\n        for (let i = 1; i < iterations + 1; i++) {\n            this._generateMipMap(i);\n        }\n    }\n    _generateMipMap(lodLevel) {\n        // Generate a mip map for the given level by triggering the render of the procedural mip texture.\n        const mipTarget = this._mipArray[lodLevel - 1];\n        if (!mipTarget) {\n            return;\n        }\n        mipTarget.setTexture(\"srcMip\", lodLevel === 1 ? this.getVoxelGrid() : this._mipArray[lodLevel - 2]);\n        mipTarget.render();\n    }\n    _copyMipMaps() {\n        const iterations = Math.ceil(Math.log2(this._voxelResolution));\n        for (let i = 1; i < iterations + 1; i++) {\n            this._copyMipMap(i);\n        }\n    }\n    _copyMipMap(lodLevel) {\n        // Now, copy this mip into the mip chain of the voxel grid.\n        // TODO - this currently isn't working. \"textureSampler\" isn't being properly set to mipTarget.\n        const mipTarget = this._mipArray[lodLevel - 1];\n        if (!mipTarget) {\n            return;\n        }\n        const voxelGrid = this.getVoxelGrid();\n        let rt;\n        if (voxelGrid instanceof RenderTargetTexture && voxelGrid.renderTarget) {\n            rt = voxelGrid.renderTarget;\n        }\n        else {\n            rt = voxelGrid._rtWrapper;\n        }\n        if (rt) {\n            this._copyMipEffectRenderer.saveStates();\n            const bindSize = mipTarget.getSize().width;\n            // Render to each layer of the voxel grid.\n            for (let layer = 0; layer < bindSize; layer++) {\n                this._engine.bindFramebuffer(rt, 0, bindSize, bindSize, true, lodLevel, layer);\n                this._copyMipEffectRenderer.applyEffectWrapper(this._copyMipEffectWrapper);\n                this._copyMipEffectWrapper.effect.setTexture(\"textureSampler\", mipTarget);\n                this._copyMipEffectWrapper.effect.setInt(\"layerNum\", layer);\n                this._copyMipEffectRenderer.draw();\n                this._engine.unBindFramebuffer(rt, true);\n            }\n            this._copyMipEffectRenderer.restoreStates();\n        }\n    }\n    _computeNumberOfSlabs() {\n        return Math.ceil(this._voxelResolution / this._maxDrawBuffers);\n    }\n    _createTextures() {\n        const isWebGPU = this._engine.isWebGPU;\n        const size = {\n            width: this._voxelResolution,\n            height: this._voxelResolution,\n            layers: this._isVoxelGrid3D ? undefined : this._voxelResolution,\n            depth: this._isVoxelGrid3D ? this._voxelResolution : undefined,\n        };\n        const voxelAxisOptions = {\n            generateDepthBuffer: false,\n            generateMipMaps: false,\n            type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n            format: Constants.TEXTUREFORMAT_R,\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n        };\n        // We can render up to maxDrawBuffers voxel slices of the grid per render.\n        // We call this a slab.\n        const numSlabs = this._computeNumberOfSlabs();\n        const voxelCombinedOptions = {\n            generateDepthBuffer: false,\n            generateMipMaps: true,\n            type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n            format: Constants.TEXTUREFORMAT_R,\n            samplingMode: Constants.TEXTURE_NEAREST_NEAREST_MIPNEAREST,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await import(\"../../ShadersWGSL/iblCombineVoxelGrids.fragment\");\n                }\n                else {\n                    await import(\"../../Shaders/iblCombineVoxelGrids.fragment\");\n                }\n            },\n        };\n        if (this._triPlanarVoxelization) {\n            this._voxelGridXaxis = new RenderTargetTexture(\"voxelGridXaxis\", size, this._scene, voxelAxisOptions);\n            this._voxelGridYaxis = new RenderTargetTexture(\"voxelGridYaxis\", size, this._scene, voxelAxisOptions);\n            this._voxelGridZaxis = new RenderTargetTexture(\"voxelGridZaxis\", size, this._scene, voxelAxisOptions);\n            this._voxelMrtsXaxis = this._createVoxelMRTs(\"x_axis_\", this._voxelGridXaxis, numSlabs);\n            this._voxelMrtsYaxis = this._createVoxelMRTs(\"y_axis_\", this._voxelGridYaxis, numSlabs);\n            this._voxelMrtsZaxis = this._createVoxelMRTs(\"z_axis_\", this._voxelGridZaxis, numSlabs);\n            this._voxelGridRT = new ProceduralTexture(\"combinedVoxelGrid\", size, \"iblCombineVoxelGrids\", this._scene, voxelCombinedOptions, false);\n            this._scene.proceduralTextures.splice(this._scene.proceduralTextures.indexOf(this._voxelGridRT), 1);\n            this._voxelGridRT.setFloat(\"layer\", 0.0);\n            this._voxelGridRT.setTexture(\"voxelXaxisSampler\", this._voxelGridXaxis);\n            this._voxelGridRT.setTexture(\"voxelYaxisSampler\", this._voxelGridYaxis);\n            this._voxelGridRT.setTexture(\"voxelZaxisSampler\", this._voxelGridZaxis);\n            // We will render this only after voxelization is completed for the 3 axes.\n            this._voxelGridRT.autoClear = false;\n            this._voxelGridRT.wrapU = Texture.CLAMP_ADDRESSMODE;\n            this._voxelGridRT.wrapV = Texture.CLAMP_ADDRESSMODE;\n        }\n        else {\n            this._voxelGridZaxis = new RenderTargetTexture(\"voxelGridZaxis\", size, this._scene, voxelCombinedOptions);\n            this._voxelMrtsZaxis = this._createVoxelMRTs(\"z_axis_\", this._voxelGridZaxis, numSlabs);\n        }\n        const generateVoxelMipOptions = {\n            generateDepthBuffer: false,\n            generateMipMaps: false,\n            type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n            format: Constants.TEXTUREFORMAT_R,\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await import(\"../../ShadersWGSL/iblGenerateVoxelMip.fragment\");\n                }\n                else {\n                    await import(\"../../Shaders/iblGenerateVoxelMip.fragment\");\n                }\n            },\n        };\n        this._mipArray = new Array(Math.ceil(Math.log2(this._voxelResolution)));\n        for (let mipIdx = 1; mipIdx <= this._mipArray.length; mipIdx++) {\n            const mipDim = this._voxelResolution >> mipIdx;\n            const mipSize = { width: mipDim, height: mipDim, depth: mipDim };\n            this._mipArray[mipIdx - 1] = new ProceduralTexture(\"voxelMip\" + mipIdx, mipSize, \"iblGenerateVoxelMip\", this._scene, generateVoxelMipOptions, false);\n            this._scene.proceduralTextures.splice(this._scene.proceduralTextures.indexOf(this._mipArray[mipIdx - 1]), 1);\n            const mipTarget = this._mipArray[mipIdx - 1];\n            mipTarget.autoClear = false;\n            mipTarget.wrapU = Texture.CLAMP_ADDRESSMODE;\n            mipTarget.wrapV = Texture.CLAMP_ADDRESSMODE;\n            mipTarget.setTexture(\"srcMip\", mipIdx > 1 ? this._mipArray[mipIdx - 2] : this.getVoxelGrid());\n            mipTarget.setInt(\"layerNum\", 0);\n        }\n        this._createVoxelMaterials();\n    }\n    _createVoxelMRTs(name, voxelRT, numSlabs) {\n        voxelRT.wrapU = Texture.CLAMP_ADDRESSMODE;\n        voxelRT.wrapV = Texture.CLAMP_ADDRESSMODE;\n        voxelRT.noPrePassRenderer = true;\n        const mrtArray = [];\n        const targetTypes = new Array(this._maxDrawBuffers).fill(this._isVoxelGrid3D ? Constants.TEXTURE_3D : Constants.TEXTURE_2D_ARRAY);\n        for (let mrtIndex = 0; mrtIndex < numSlabs; mrtIndex++) {\n            let layerIndices = new Array(this._maxDrawBuffers).fill(0);\n            layerIndices = layerIndices.map((value, index) => mrtIndex * this._maxDrawBuffers + index);\n            let textureNames = new Array(this._maxDrawBuffers).fill(\"\");\n            textureNames = textureNames.map((value, index) => \"voxel_grid_\" + name + (mrtIndex * this._maxDrawBuffers + index));\n            const mrt = new MultiRenderTarget(\"mrt_\" + name + mrtIndex, { width: this._voxelResolution, height: this._voxelResolution, depth: this._isVoxelGrid3D ? this._voxelResolution : undefined }, this._maxDrawBuffers, // number of draw buffers\n            this._scene, {\n                types: new Array(this._maxDrawBuffers).fill(Constants.TEXTURETYPE_UNSIGNED_BYTE),\n                samplingModes: new Array(this._maxDrawBuffers).fill(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE),\n                generateMipMaps: false,\n                targetTypes,\n                formats: new Array(this._maxDrawBuffers).fill(Constants.TEXTUREFORMAT_R),\n                faceIndex: new Array(this._maxDrawBuffers).fill(0),\n                layerIndex: layerIndices,\n                layerCounts: new Array(this._maxDrawBuffers).fill(this._voxelResolution),\n                generateDepthBuffer: false,\n                generateStencilBuffer: false,\n            }, textureNames);\n            mrt.clearColor = new Color4(0, 0, 0, 1);\n            mrt.noPrePassRenderer = true;\n            for (let i = 0; i < this._maxDrawBuffers; i++) {\n                mrt.setInternalTexture(voxelRT.getInternalTexture(), i);\n            }\n            mrtArray.push(mrt);\n        }\n        return mrtArray;\n    }\n    _disposeVoxelTextures() {\n        this._stopVoxelization();\n        for (let i = 0; i < this._voxelMrtsZaxis.length; i++) {\n            if (this._triPlanarVoxelization) {\n                this._voxelMrtsXaxis[i].dispose(true);\n                this._voxelMrtsYaxis[i].dispose(true);\n            }\n            this._voxelMrtsZaxis[i].dispose(true);\n        }\n        if (this._triPlanarVoxelization) {\n            this._voxelGridXaxis?.dispose();\n            this._voxelGridYaxis?.dispose();\n            this._voxelGridRT?.dispose();\n        }\n        this._voxelGridZaxis?.dispose();\n        for (const mip of this._mipArray) {\n            mip.dispose();\n        }\n        this._voxelMaterial?.dispose();\n        this._voxelSlabDebugMaterial?.dispose();\n        this._mipArray = [];\n        this._voxelMrtsXaxis = [];\n        this._voxelMrtsYaxis = [];\n        this._voxelMrtsZaxis = [];\n    }\n    _createVoxelMaterials() {\n        const isWebGPU = this._engine.isWebGPU;\n        this._voxelMaterial = new ShaderMaterial(\"voxelization\", this._scene, \"iblVoxelGrid\", {\n            uniforms: [\"world\", \"viewMatrix\", \"invWorldScale\", \"nearPlane\", \"farPlane\", \"stepSize\"],\n            defines: [\"MAX_DRAW_BUFFERS \" + this._maxDrawBuffers],\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../../ShadersWGSL/iblVoxelGrid.fragment\"), import(\"../../ShadersWGSL/iblVoxelGrid.vertex\")]);\n                }\n                else {\n                    await Promise.all([import(\"../../Shaders/iblVoxelGrid.fragment\"), import(\"../../Shaders/iblVoxelGrid.vertex\")]);\n                }\n            },\n        });\n        this._voxelMaterial.cullBackFaces = false;\n        this._voxelMaterial.backFaceCulling = false;\n        this._voxelMaterial.depthFunction = Engine.ALWAYS;\n        this._voxelSlabDebugMaterial = new ShaderMaterial(\"voxelSlabDebug\", this._scene, \"iblVoxelSlabDebug\", {\n            uniforms: [\"world\", \"viewMatrix\", \"cameraViewMatrix\", \"projection\", \"invWorldScale\", \"nearPlane\", \"farPlane\", \"stepSize\"],\n            defines: [\"MAX_DRAW_BUFFERS \" + this._maxDrawBuffers],\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../../ShadersWGSL/iblVoxelSlabDebug.fragment\"), import(\"../../ShadersWGSL/iblVoxelSlabDebug.vertex\")]);\n                }\n                else {\n                    await Promise.all([import(\"../../Shaders/iblVoxelSlabDebug.fragment\"), import(\"../../Shaders/iblVoxelSlabDebug.vertex\")]);\n                }\n            },\n        });\n    }\n    _setDebugBindings() {\n        this._voxelSlabDebugMaterial.setMatrix(\"projection\", this._scene.activeCamera.getProjectionMatrix());\n        this._voxelSlabDebugMaterial.setMatrix(\"cameraViewMatrix\", this._scene.activeCamera.getViewMatrix());\n    }\n    /**\n     * Checks if the voxel renderer is ready to voxelize scene\n     * @returns true if the voxel renderer is ready to voxelize scene\n     */\n    isReady() {\n        let allReady = this.getVoxelGrid().isReady();\n        for (let i = 0; i < this._mipArray.length; i++) {\n            const mipReady = this._mipArray[i].isReady();\n            allReady &&= mipReady;\n        }\n        if (!allReady || this._voxelizationInProgress) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * If the MRT's are already in the list of render targets, this will\n     * remove them so that they don't get rendered again.\n     */\n    _stopVoxelization() {\n        // If the MRT's are already in the list of render targets, remove them.\n        this._removeVoxelRTs(this._voxelMrtsXaxis);\n        this._removeVoxelRTs(this._voxelMrtsYaxis);\n        this._removeVoxelRTs(this._voxelMrtsZaxis);\n    }\n    _removeVoxelRTs(rts) {\n        // const currentRTs = this._scene.customRenderTargets;\n        const rtIdx = this._renderTargets.findIndex((rt) => {\n            if (rt === rts[0]) {\n                return true;\n            }\n            return false;\n        });\n        if (rtIdx >= 0) {\n            this._renderTargets.splice(rtIdx, rts.length);\n        }\n        else {\n            const rtIdx = this._scene.customRenderTargets.findIndex((rt) => {\n                if (rt === rts[0]) {\n                    return true;\n                }\n                return false;\n            });\n            if (rtIdx >= 0) {\n                this._scene.customRenderTargets.splice(rtIdx, rts.length);\n            }\n        }\n    }\n    /**\n     * Renders voxel grid of scene for IBL shadows\n     * @param includedMeshes\n     */\n    updateVoxelGrid(includedMeshes) {\n        this._stopVoxelization();\n        this._includedMeshes = includedMeshes;\n        this._voxelizationInProgress = true;\n        if (this._triPlanarVoxelization) {\n            this._addRTsForRender(this._voxelMrtsXaxis, includedMeshes, 0);\n            this._addRTsForRender(this._voxelMrtsYaxis, includedMeshes, 1);\n            this._addRTsForRender(this._voxelMrtsZaxis, includedMeshes, 2);\n        }\n        else {\n            this._addRTsForRender(this._voxelMrtsZaxis, includedMeshes, 2);\n        }\n        if (this._voxelDebugEnabled) {\n            this._addRTsForRender([this._voxelSlabDebugRT], includedMeshes, this._voxelDebugAxis, 1, true);\n        }\n        this._renderVoxelGridBound = this._renderVoxelGrid.bind(this);\n        this._scene.onAfterRenderObservable.add(this._renderVoxelGridBound);\n    }\n    _renderVoxelGrid() {\n        if (this._voxelizationInProgress) {\n            let allReady = this.getVoxelGrid().isReady();\n            for (let i = 0; i < this._mipArray.length; i++) {\n                const mipReady = this._mipArray[i].isReady();\n                allReady &&= mipReady;\n            }\n            for (let i = 0; i < this._renderTargets.length; i++) {\n                const rttReady = this._renderTargets[i].isReadyForRendering();\n                allReady &&= rttReady;\n            }\n            if (allReady) {\n                for (const rt of this._renderTargets) {\n                    rt.render();\n                }\n                this._stopVoxelization();\n                if (this._triPlanarVoxelization) {\n                    this._voxelGridRT.render();\n                }\n                this._generateMipMaps();\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n                this._copyMipEffectWrapper.effect.whenCompiledAsync().then(() => {\n                    this._copyMipMaps();\n                    this._scene.onAfterRenderObservable.removeCallback(this._renderVoxelGridBound);\n                    this._voxelizationInProgress = false;\n                    this.onVoxelizationCompleteObservable.notifyObservers();\n                });\n            }\n        }\n    }\n    _addRTsForRender(mrts, includedMeshes, axis, shaderType = 0, continuousRender = false) {\n        const slabSize = 1.0 / this._computeNumberOfSlabs();\n        let voxelMaterial;\n        if (shaderType === 0) {\n            voxelMaterial = this._voxelMaterial;\n        }\n        else {\n            voxelMaterial = this._voxelSlabDebugMaterial;\n        }\n        // We need to update the world scale uniform for every mesh being rendered to the voxel grid.\n        for (let mrtIndex = 0; mrtIndex < mrts.length; mrtIndex++) {\n            const mrt = mrts[mrtIndex];\n            mrt.renderList = [];\n            const nearPlane = mrtIndex * slabSize;\n            const farPlane = (mrtIndex + 1) * slabSize;\n            const stepSize = slabSize / this._maxDrawBuffers;\n            const cameraPosition = new Vector3(0, 0, 0);\n            let targetPosition = new Vector3(0, 0, 1);\n            if (axis === 0) {\n                targetPosition = new Vector3(1, 0, 0);\n            }\n            else if (axis === 1) {\n                targetPosition = new Vector3(0, 1, 0);\n            }\n            let upDirection = new Vector3(0, 1, 0);\n            if (axis === 1) {\n                upDirection = new Vector3(1, 0, 0);\n            }\n            mrt.onBeforeRenderObservable.add(() => {\n                voxelMaterial.setMatrix(\"viewMatrix\", Matrix.LookAtLH(cameraPosition, targetPosition, upDirection));\n                voxelMaterial.setMatrix(\"invWorldScale\", this._invWorldScaleMatrix);\n                voxelMaterial.setFloat(\"nearPlane\", nearPlane);\n                voxelMaterial.setFloat(\"farPlane\", farPlane);\n                voxelMaterial.setFloat(\"stepSize\", stepSize);\n            });\n            // Set this material on every mesh in the scene (for this RT)\n            if (includedMeshes.length === 0) {\n                return;\n            }\n            for (const mesh of includedMeshes) {\n                if (mesh) {\n                    if (mesh.subMeshes && mesh.subMeshes.length > 0) {\n                        mrt.renderList?.push(mesh);\n                        mrt.setMaterialForRendering(mesh, voxelMaterial);\n                    }\n                    const meshes = mesh.getChildMeshes();\n                    for (const childMesh of meshes) {\n                        if (childMesh.subMeshes && childMesh.subMeshes.length > 0) {\n                            mrt.renderList?.push(childMesh);\n                            mrt.setMaterialForRendering(childMesh, voxelMaterial);\n                        }\n                    }\n                }\n            }\n        }\n        // Add the MRT's to render.\n        if (continuousRender) {\n            for (const mrt of mrts) {\n                if (this._scene.customRenderTargets.indexOf(mrt) === -1) {\n                    this._scene.customRenderTargets.push(mrt);\n                }\n            }\n        }\n        else {\n            this._renderTargets = this._renderTargets.concat(mrts);\n        }\n    }\n    /**\n     * Called by the pipeline to resize resources.\n     */\n    resize() {\n        this._voxelSlabDebugRT?.resize({ width: this._scene.getEngine().getRenderWidth(), height: this._scene.getEngine().getRenderHeight() });\n    }\n    /**\n     * Disposes the voxel renderer and associated resources\n     */\n    dispose() {\n        this._disposeVoxelTextures();\n        if (this._voxelSlabDebugRT) {\n            this._removeVoxelRTs([this._voxelSlabDebugRT]);\n            this._voxelSlabDebugRT.dispose();\n        }\n        if (this._voxelDebugPass) {\n            this._voxelDebugPass.dispose();\n        }\n        // TODO - dispose all created voxel materials.\n    }\n}\n//# sourceMappingURL=iblShadowsVoxelRenderer.js.map","import { Constants } from \"../../Engines/constants\";\nimport { Matrix, Vector4 } from \"../../Maths/math.vector\";\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\nimport { GeometryBufferRenderer } from \"../../Rendering/geometryBufferRenderer\";\nimport { ProceduralTexture } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\nimport { Logger } from \"../../Misc/logger\";\n/**\n * Build cdf maps for IBL importance sampling during IBL shadow computation.\n * This should not be instantiated directly, as it is part of a scene component\n * @internal\n */\nexport class _IblShadowsVoxelTracingPass {\n    /**\n     * The opacity of the shadow cast from the voxel grid\n     */\n    get voxelShadowOpacity() {\n        return this._voxelShadowOpacity;\n    }\n    /**\n     * The opacity of the shadow cast from the voxel grid\n     */\n    set voxelShadowOpacity(value) {\n        this._voxelShadowOpacity = value;\n    }\n    /**\n     * The opacity of the screen-space shadow\n     */\n    get ssShadowOpacity() {\n        return this._ssShadowOpacity;\n    }\n    /**\n     * The opacity of the screen-space shadow\n     */\n    set ssShadowOpacity(value) {\n        this._ssShadowOpacity = value;\n    }\n    /**\n     * The number of samples used in the screen space shadow pass.\n     */\n    get sssSamples() {\n        return this._sssSamples;\n    }\n    /**\n     * The number of samples used in the screen space shadow pass.\n     */\n    set sssSamples(value) {\n        this._sssSamples = value;\n    }\n    /**\n     * The stride used in the screen space shadow pass. This controls the distance between samples.\n     */\n    get sssStride() {\n        return this._sssStride;\n    }\n    /**\n     * The stride used in the screen space shadow pass. This controls the distance between samples.\n     */\n    set sssStride(value) {\n        this._sssStride = value;\n    }\n    /**\n     * The maximum distance that the screen-space shadow will be able to occlude.\n     */\n    get sssMaxDist() {\n        return this._sssMaxDist;\n    }\n    /**\n     * The maximum distance that the screen-space shadow will be able to occlude.\n     */\n    set sssMaxDist(value) {\n        this._sssMaxDist = value;\n    }\n    /**\n     * The thickness of the screen-space shadow\n     */\n    get sssThickness() {\n        return this._sssThickness;\n    }\n    /**\n     * The thickness of the screen-space shadow\n     */\n    set sssThickness(value) {\n        this._sssThickness = value;\n    }\n    /**\n     * The bias to apply to the voxel sampling in the direction of the surface normal of the geometry.\n     */\n    get voxelNormalBias() {\n        return this._voxelNormalBias;\n    }\n    set voxelNormalBias(value) {\n        this._voxelNormalBias = value;\n    }\n    /**\n     * The bias to apply to the voxel sampling in the direction of the light.\n     */\n    get voxelDirectionBias() {\n        return this._voxelDirectionBias;\n    }\n    set voxelDirectionBias(value) {\n        this._voxelDirectionBias = value;\n    }\n    /**\n     * The number of directions to sample for the voxel tracing.\n     */\n    get sampleDirections() {\n        return this._sampleDirections;\n    }\n    /**\n     * The number of directions to sample for the voxel tracing.\n     */\n    set sampleDirections(value) {\n        this._sampleDirections = value;\n    }\n    /**\n     * The current rotation of the environment map, in radians.\n     */\n    get envRotation() {\n        return this._envRotation;\n    }\n    /**\n     * The current rotation of the environment map, in radians.\n     */\n    set envRotation(value) {\n        this._envRotation = value;\n    }\n    /**\n     * Returns the output texture of the pass.\n     * @returns The output texture.\n     */\n    getOutputTexture() {\n        return this._outputTexture;\n    }\n    /**\n     * Gets the debug pass post process. This will create the resources for the pass\n     * if they don't already exist.\n     * @returns The post process\n     */\n    getDebugPassPP() {\n        if (!this._debugPassPP) {\n            this._createDebugPass();\n        }\n        return this._debugPassPP;\n    }\n    /**\n     * The name of the debug pass\n     */\n    get debugPassName() {\n        return this._debugPassName;\n    }\n    /**\n     * Set the matrix to use for scaling the world space to voxel space\n     * @param matrix The matrix to use for scaling the world space to voxel space\n     */\n    setWorldScaleMatrix(matrix) {\n        this._invWorldScaleMatrix = matrix;\n    }\n    /**\n     * Render the shadows in color rather than black and white.\n     * This is slightly more expensive than black and white shadows but can be much\n     * more accurate when the strongest lights in the IBL are non-white.\n     */\n    set coloredShadows(value) {\n        this._coloredShadows = value;\n    }\n    get coloredShadows() {\n        return this._coloredShadows;\n    }\n    /**\n     * Sets params that control the position and scaling of the debug display on the screen.\n     * @param x Screen X offset of the debug display (0-1)\n     * @param y Screen Y offset of the debug display (0-1)\n     * @param widthScale X scale of the debug display (0-1)\n     * @param heightScale Y scale of the debug display (0-1)\n     */\n    setDebugDisplayParams(x, y, widthScale, heightScale) {\n        this._debugSizeParams.set(x, y, widthScale, heightScale);\n    }\n    /**\n     * Creates the debug post process effect for this pass\n     */\n    _createDebugPass() {\n        const isWebGPU = this._engine.isWebGPU;\n        if (!this._debugPassPP) {\n            const debugOptions = {\n                width: this._engine.getRenderWidth(),\n                height: this._engine.getRenderHeight(),\n                uniforms: [\"sizeParams\"],\n                samplers: [\"debugSampler\"],\n                engine: this._engine,\n                reusable: true,\n                shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n                extraInitializations: (useWebGPU, list) => {\n                    if (useWebGPU) {\n                        list.push(import(\"../../ShadersWGSL/iblShadowDebug.fragment\"));\n                    }\n                    else {\n                        list.push(import(\"../../Shaders/iblShadowDebug.fragment\"));\n                    }\n                },\n            };\n            this._debugPassPP = new PostProcess(this.debugPassName, \"iblShadowDebug\", debugOptions);\n            this._debugPassPP.autoClear = false;\n            this._debugPassPP.onApplyObservable.add((effect) => {\n                // update the caustic texture with what we just rendered.\n                effect.setTexture(\"debugSampler\", this._outputTexture);\n                effect.setVector4(\"sizeParams\", this._debugSizeParams);\n            });\n        }\n    }\n    /**\n     * Instantiates the shadow voxel-tracing pass\n     * @param scene Scene to attach to\n     * @param iblShadowsRenderPipeline The IBL shadows render pipeline\n     * @returns The shadow voxel-tracing pass\n     */\n    constructor(scene, iblShadowsRenderPipeline) {\n        this._voxelShadowOpacity = 1.0;\n        this._sssSamples = 16;\n        this._sssStride = 8;\n        this._sssMaxDist = 0.05;\n        this._sssThickness = 0.5;\n        this._ssShadowOpacity = 1.0;\n        this._cameraInvView = Matrix.Identity();\n        this._cameraInvProj = Matrix.Identity();\n        this._invWorldScaleMatrix = Matrix.Identity();\n        this._frameId = 0;\n        this._sampleDirections = 4;\n        this._shadowParameters = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this._sssParameters = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this._opacityParameters = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this._voxelBiasParameters = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this._voxelNormalBias = 1.4;\n        this._voxelDirectionBias = 1.75;\n        /**\n         * Is the effect enabled\n         */\n        this.enabled = true;\n        /** Enable the debug view for this pass */\n        this.debugEnabled = false;\n        this._debugPassName = \"Voxel Tracing Debug Pass\";\n        /** The default rotation of the environment map will align the shadows with the default lighting orientation */\n        this._envRotation = 0.0;\n        this._coloredShadows = false;\n        this._debugVoxelMarchEnabled = false;\n        this._debugSizeParams = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this._renderWhenGBufferReady = null;\n        this._scene = scene;\n        this._engine = scene.getEngine();\n        this._renderPipeline = iblShadowsRenderPipeline;\n        this._createTextures();\n    }\n    _createTextures() {\n        const defines = this._createDefines();\n        const isWebGPU = this._engine.isWebGPU;\n        const textureOptions = {\n            type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n            format: Constants.TEXTUREFORMAT_RGBA,\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n            generateDepthBuffer: false,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../../ShadersWGSL/iblShadowVoxelTracing.fragment\")]);\n                }\n                else {\n                    await Promise.all([import(\"../../Shaders/iblShadowVoxelTracing.fragment\")]);\n                }\n            },\n        };\n        this._outputTexture = new ProceduralTexture(\"voxelTracingPass\", {\n            width: this._engine.getRenderWidth(),\n            height: this._engine.getRenderHeight(),\n        }, \"iblShadowVoxelTracing\", this._scene, textureOptions);\n        this._outputTexture.refreshRate = -1;\n        this._outputTexture.autoClear = false;\n        this._outputTexture.defines = defines;\n        // Need to set all the textures first so that the effect gets created with the proper uniforms.\n        this._setBindings(this._scene.activeCamera);\n        this._renderWhenGBufferReady = this._render.bind(this);\n        // Don't start rendering until the first vozelization is done.\n        this._renderPipeline.onVoxelizationCompleteObservable.addOnce(() => {\n            this._scene.geometryBufferRenderer.getGBuffer().onAfterRenderObservable.add(this._renderWhenGBufferReady);\n        });\n    }\n    _createDefines() {\n        let defines = \"\";\n        if (this._scene.useRightHandedSystem) {\n            defines += \"#define RIGHT_HANDED\\n\";\n        }\n        if (this._debugVoxelMarchEnabled) {\n            defines += \"#define VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION 1u\\n\";\n        }\n        if (this._coloredShadows) {\n            defines += \"#define COLOR_SHADOWS 1u\\n\";\n        }\n        return defines;\n    }\n    _setBindings(camera) {\n        this._outputTexture.defines = this._createDefines();\n        this._outputTexture.setMatrix(\"viewMtx\", camera.getViewMatrix());\n        this._outputTexture.setMatrix(\"projMtx\", camera.getProjectionMatrix());\n        camera.getProjectionMatrix().invertToRef(this._cameraInvProj);\n        camera.getViewMatrix().invertToRef(this._cameraInvView);\n        this._outputTexture.setMatrix(\"invProjMtx\", this._cameraInvProj);\n        this._outputTexture.setMatrix(\"invViewMtx\", this._cameraInvView);\n        this._outputTexture.setMatrix(\"wsNormalizationMtx\", this._invWorldScaleMatrix);\n        this._frameId++;\n        let rotation = 0.0;\n        if (this._scene.environmentTexture) {\n            rotation = this._scene.environmentTexture.rotationY ?? 0;\n        }\n        rotation = this._scene.useRightHandedSystem ? -(rotation + 0.5 * Math.PI) : rotation - 0.5 * Math.PI;\n        rotation = rotation % (2.0 * Math.PI);\n        this._shadowParameters.set(this._sampleDirections, this._frameId, 1.0, rotation);\n        this._outputTexture.setVector4(\"shadowParameters\", this._shadowParameters);\n        const voxelGrid = this._renderPipeline._getVoxelGridTexture();\n        const highestMip = Math.floor(Math.log2(voxelGrid.getSize().width));\n        this._voxelBiasParameters.set(this._voxelNormalBias, this._voxelDirectionBias, highestMip, 0.0);\n        this._outputTexture.setVector4(\"voxelBiasParameters\", this._voxelBiasParameters);\n        // SSS Options.\n        this._sssParameters.set(this._sssSamples, this._sssStride, this._sssMaxDist, this._sssThickness);\n        this._outputTexture.setVector4(\"sssParameters\", this._sssParameters);\n        this._opacityParameters.set(this._voxelShadowOpacity, this._ssShadowOpacity, 0.0, 0.0);\n        this._outputTexture.setVector4(\"shadowOpacity\", this._opacityParameters);\n        this._outputTexture.setTexture(\"voxelGridSampler\", voxelGrid);\n        this._outputTexture.setTexture(\"blueNoiseSampler\", this._renderPipeline._getNoiseTexture());\n        const cdfGenerator = this._scene.iblCdfGenerator;\n        if (!cdfGenerator) {\n            Logger.Warn(\"IBLShadowsVoxelTracingPass: Can't bind for render because iblCdfGenerator is not enabled.\");\n            return false;\n        }\n        this._outputTexture.setTexture(\"icdfSampler\", cdfGenerator.getIcdfTexture());\n        if (this._coloredShadows && this._scene.environmentTexture) {\n            this._outputTexture.setTexture(\"iblSampler\", this._scene.environmentTexture);\n        }\n        const geometryBufferRenderer = this._scene.geometryBufferRenderer;\n        if (!geometryBufferRenderer) {\n            Logger.Warn(\"IBLShadowsVoxelTracingPass: Can't bind for render because GeometryBufferRenderer is not enabled.\");\n            return false;\n        }\n        const depthIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE);\n        this._outputTexture.setTexture(\"depthSampler\", geometryBufferRenderer.getGBuffer().textures[depthIndex]);\n        const wnormalIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.NORMAL_TEXTURE_TYPE);\n        this._outputTexture.setTexture(\"worldNormalSampler\", geometryBufferRenderer.getGBuffer().textures[wnormalIndex]);\n        return true;\n    }\n    _render() {\n        if (this.enabled && this._outputTexture.isReady() && this._outputTexture.getEffect()?.isReady()) {\n            if (this._setBindings(this._scene.activeCamera)) {\n                this._outputTexture.render();\n            }\n        }\n    }\n    /**\n     * Called by render pipeline when canvas resized.\n     * @param scaleFactor The factor by which to scale the canvas size.\n     */\n    resize(scaleFactor = 1.0) {\n        const newSize = {\n            width: Math.max(1.0, Math.floor(this._engine.getRenderWidth() * scaleFactor)),\n            height: Math.max(1.0, Math.floor(this._engine.getRenderHeight() * scaleFactor)),\n        };\n        // Don't resize if the size is the same as the current size.\n        if (this._outputTexture.getSize().width === newSize.width && this._outputTexture.getSize().height === newSize.height) {\n            return;\n        }\n        this._outputTexture.resize(newSize, false);\n    }\n    /**\n     * Checks if the pass is ready\n     * @returns true if the pass is ready\n     */\n    isReady() {\n        return (this._outputTexture.isReady() &&\n            !(this._debugPassPP && !this._debugPassPP.isReady()) &&\n            this._scene.iblCdfGenerator &&\n            this._scene.iblCdfGenerator.getIcdfTexture().isReady() &&\n            this._renderPipeline._getVoxelGridTexture().isReady());\n    }\n    /**\n     * Disposes the associated resources\n     */\n    dispose() {\n        if (this._scene.geometryBufferRenderer && this._renderWhenGBufferReady) {\n            const gBuffer = this._scene.geometryBufferRenderer.getGBuffer();\n            gBuffer.onAfterRenderObservable.removeCallback(this._renderWhenGBufferReady);\n        }\n        this._outputTexture.dispose();\n        if (this._debugPassPP) {\n            this._debugPassPP.dispose();\n        }\n    }\n}\n//# sourceMappingURL=iblShadowsVoxelTracingPass.js.map","import { Constants } from \"../../Engines/constants\";\nimport { Vector4 } from \"../../Maths/math.vector\";\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\nimport { GeometryBufferRenderer } from \"../../Rendering/geometryBufferRenderer\";\nimport { ProceduralTexture } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\n/**\n * This should not be instanciated directly, as it is part of a scene component\n * @internal\n */\nexport class _IblShadowsSpatialBlurPass {\n    /**\n     * Returns the output texture of the pass.\n     * @returns The output texture.\n     */\n    getOutputTexture() {\n        return this._outputTexture;\n    }\n    /**\n     * Gets the debug pass post process\n     * @returns The post process\n     */\n    getDebugPassPP() {\n        if (!this._debugPassPP) {\n            this._createDebugPass();\n        }\n        return this._debugPassPP;\n    }\n    /**\n     * Sets the name of the debug pass\n     */\n    get debugPassName() {\n        return this._debugPassName;\n    }\n    /**\n     * The scale of the voxel grid in world space. This is used to scale the blur radius in world space.\n     * @param scale The scale of the voxel grid in world space.\n     */\n    setWorldScale(scale) {\n        this._worldScale = scale;\n    }\n    /**\n     * Sets params that control the position and scaling of the debug display on the screen.\n     * @param x Screen X offset of the debug display (0-1)\n     * @param y Screen Y offset of the debug display (0-1)\n     * @param widthScale X scale of the debug display (0-1)\n     * @param heightScale Y scale of the debug display (0-1)\n     */\n    setDebugDisplayParams(x, y, widthScale, heightScale) {\n        this._debugSizeParams.set(x, y, widthScale, heightScale);\n    }\n    /**\n     * Creates the debug post process effect for this pass\n     */\n    _createDebugPass() {\n        if (!this._debugPassPP) {\n            const isWebGPU = this._engine.isWebGPU;\n            const debugOptions = {\n                width: this._engine.getRenderWidth(),\n                height: this._engine.getRenderHeight(),\n                textureFormat: Constants.TEXTUREFORMAT_RGBA,\n                textureType: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n                samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n                uniforms: [\"sizeParams\"],\n                samplers: [\"debugSampler\"],\n                engine: this._engine,\n                reusable: false,\n                shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n                extraInitializations: (useWebGPU, list) => {\n                    if (useWebGPU) {\n                        list.push(import(\"../../ShadersWGSL/iblShadowDebug.fragment\"));\n                    }\n                    else {\n                        list.push(import(\"../../Shaders/iblShadowDebug.fragment\"));\n                    }\n                },\n            };\n            this._debugPassPP = new PostProcess(this.debugPassName, \"iblShadowDebug\", debugOptions);\n            this._debugPassPP.autoClear = false;\n            this._debugPassPP.onApplyObservable.add((effect) => {\n                // update the caustic texture with what we just rendered.\n                effect.setTexture(\"debugSampler\", this._outputTexture);\n                effect.setVector4(\"sizeParams\", this._debugSizeParams);\n            });\n        }\n    }\n    /**\n     * Instanciates the importance sampling renderer\n     * @param scene Scene to attach to\n     * @param iblShadowsRenderPipeline The IBL shadows render pipeline\n     * @returns The importance sampling renderer\n     */\n    constructor(scene, iblShadowsRenderPipeline) {\n        this._worldScale = 1.0;\n        this._blurParameters = new Vector4(0.0, 0.0, 0.0, 0.0);\n        /**\n         * Is the effect enabled\n         */\n        this.enabled = true;\n        this._debugPassName = \"Spatial Blur Debug Pass\";\n        /** Enable the debug view for this pass */\n        this.debugEnabled = false;\n        this._debugSizeParams = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this._renderWhenGBufferReady = null;\n        this._scene = scene;\n        this._engine = scene.getEngine();\n        this._renderPipeline = iblShadowsRenderPipeline;\n        this._createTextures();\n    }\n    _createTextures() {\n        const isWebGPU = this._engine.isWebGPU;\n        const textureOptions = {\n            type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n            format: Constants.TEXTUREFORMAT_RGBA,\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n            generateDepthBuffer: false,\n            generateMipMaps: false,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../../ShadersWGSL/iblShadowSpatialBlur.fragment\")]);\n                }\n                else {\n                    await Promise.all([import(\"../../Shaders/iblShadowSpatialBlur.fragment\")]);\n                }\n            },\n        };\n        this._outputTexture = new ProceduralTexture(\"spatialBlurPass\", {\n            width: this._engine.getRenderWidth(),\n            height: this._engine.getRenderHeight(),\n        }, \"iblShadowSpatialBlur\", this._scene, textureOptions, false, false, Constants.TEXTURETYPE_UNSIGNED_BYTE);\n        this._outputTexture.refreshRate = -1;\n        this._outputTexture.autoClear = false;\n        // Need to set all the textures first so that the effect gets created with the proper uniforms.\n        this._setBindings();\n        this._renderWhenGBufferReady = this._render.bind(this);\n        // Don't start rendering until the first vozelization is done.\n        this._renderPipeline.onVoxelizationCompleteObservable.addOnce(() => {\n            this._scene.geometryBufferRenderer.getGBuffer().onAfterRenderObservable.add(this._renderWhenGBufferReady);\n        });\n    }\n    _setBindings() {\n        this._outputTexture.setTexture(\"voxelTracingSampler\", this._renderPipeline._getVoxelTracingTexture());\n        const iterationCount = 1;\n        this._blurParameters.set(iterationCount, this._worldScale, 0.0, 0.0);\n        this._outputTexture.setVector4(\"blurParameters\", this._blurParameters);\n        const geometryBufferRenderer = this._scene.geometryBufferRenderer;\n        if (!geometryBufferRenderer) {\n            return false;\n        }\n        const depthIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE);\n        this._outputTexture.setTexture(\"depthSampler\", geometryBufferRenderer.getGBuffer().textures[depthIndex]);\n        const wnormalIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.NORMAL_TEXTURE_TYPE);\n        this._outputTexture.setTexture(\"worldNormalSampler\", geometryBufferRenderer.getGBuffer().textures[wnormalIndex]);\n        return true;\n    }\n    _render() {\n        if (this.enabled && this._outputTexture.isReady() && this._outputTexture.getEffect()?.isReady()) {\n            if (this._setBindings()) {\n                this._outputTexture.render();\n            }\n        }\n    }\n    /**\n     * Called by render pipeline when canvas resized.\n     * @param scaleFactor The factor by which to scale the canvas size.\n     */\n    resize(scaleFactor = 1.0) {\n        const newSize = {\n            width: Math.max(1.0, Math.floor(this._engine.getRenderWidth() * scaleFactor)),\n            height: Math.max(1.0, Math.floor(this._engine.getRenderHeight() * scaleFactor)),\n        };\n        // Don't resize if the size is the same as the current size.\n        if (this._outputTexture.getSize().width === newSize.width && this._outputTexture.getSize().height === newSize.height) {\n            return;\n        }\n        this._outputTexture.resize(newSize, false);\n    }\n    /**\n     * Checks if the pass is ready\n     * @returns true if the pass is ready\n     */\n    isReady() {\n        return this._outputTexture.isReady() && !(this._debugPassPP && !this._debugPassPP.isReady());\n    }\n    /**\n     * Disposes the associated resources\n     */\n    dispose() {\n        if (this._scene.geometryBufferRenderer && this._renderWhenGBufferReady) {\n            const gBuffer = this._scene.geometryBufferRenderer.getGBuffer();\n            gBuffer.onAfterRenderObservable.removeCallback(this._renderWhenGBufferReady);\n        }\n        this._outputTexture.dispose();\n        if (this._debugPassPP) {\n            this._debugPassPP.dispose();\n        }\n    }\n}\n//# sourceMappingURL=iblShadowsSpatialBlurPass.js.map","import { Constants } from \"../../Engines/constants\";\nimport { Vector4 } from \"../../Maths/math.vector\";\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\nimport { GeometryBufferRenderer } from \"../../Rendering/geometryBufferRenderer\";\nimport { ProceduralTexture } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\nimport { Observable } from \"../../Misc/observable\";\n/**\n * This should not be instantiated directly, as it is part of a scene component\n * @internal\n */\nexport class _IblShadowsAccumulationPass {\n    /**\n     * Returns the output texture of the pass.\n     * @returns The output texture.\n     */\n    getOutputTexture() {\n        return this._outputTexture;\n    }\n    /**\n     * Gets the debug pass post process\n     * @returns The post process\n     */\n    getDebugPassPP() {\n        if (!this._debugPassPP) {\n            this._createDebugPass();\n        }\n        return this._debugPassPP;\n    }\n    /**\n     * Gets the name of the debug pass\n     * @returns The name of the debug pass\n     */\n    get debugPassName() {\n        return this._debugPassName;\n    }\n    /**\n     * A value that controls how much of the previous frame's accumulation to keep.\n     * The higher the value, the faster the shadows accumulate but the more potential ghosting you'll see.\n     */\n    get remanence() {\n        return this._remanence;\n    }\n    /**\n     * A value that controls how much of the previous frame's accumulation to keep.\n     * The higher the value, the faster the shadows accumulate but the more potential ghosting you'll see.\n     */\n    set remanence(value) {\n        this._remanence = value;\n    }\n    /**\n     * Reset the accumulation.\n     */\n    get reset() {\n        return this._reset;\n    }\n    /**\n     * Reset the accumulation.\n     */\n    set reset(value) {\n        this._reset = value;\n    }\n    /**\n     * Tell the pass that the camera is moving. This will cause the accumulation\n     * rate to change.\n     */\n    set isMoving(value) {\n        this._isMoving = value;\n    }\n    /**\n     * Sets params that control the position and scaling of the debug display on the screen.\n     * @param x Screen X offset of the debug display (0-1)\n     * @param y Screen Y offset of the debug display (0-1)\n     * @param widthScale X scale of the debug display (0-1)\n     * @param heightScale Y scale of the debug display (0-1)\n     */\n    setDebugDisplayParams(x, y, widthScale, heightScale) {\n        this._debugSizeParams.set(x, y, widthScale, heightScale);\n    }\n    /**\n     * Creates the debug post process effect for this pass\n     */\n    _createDebugPass() {\n        if (!this._debugPassPP) {\n            const isWebGPU = this._engine.isWebGPU;\n            const debugOptions = {\n                width: this._engine.getRenderWidth(),\n                height: this._engine.getRenderHeight(),\n                textureFormat: Constants.TEXTUREFORMAT_RGBA,\n                textureType: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n                samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n                uniforms: [\"sizeParams\"],\n                samplers: [\"debugSampler\"],\n                engine: this._engine,\n                reusable: false,\n                shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n                extraInitializations: (useWebGPU, list) => {\n                    if (useWebGPU) {\n                        list.push(import(\"../../ShadersWGSL/iblShadowDebug.fragment\"));\n                    }\n                    else {\n                        list.push(import(\"../../Shaders/iblShadowDebug.fragment\"));\n                    }\n                },\n            };\n            this._debugPassPP = new PostProcess(this.debugPassName, \"iblShadowDebug\", debugOptions);\n            this._debugPassPP.autoClear = false;\n            this._debugPassPP.onApplyObservable.add((effect) => {\n                // update the caustic texture with what we just rendered.\n                effect.setTexture(\"debugSampler\", this._outputTexture);\n                effect.setVector4(\"sizeParams\", this._debugSizeParams);\n            });\n        }\n    }\n    /**\n     * Instantiates the accumulation pass\n     * @param scene Scene to attach to\n     * @param iblShadowsRenderPipeline The IBL shadows render pipeline\n     * @returns The accumulation pass\n     */\n    constructor(scene, iblShadowsRenderPipeline) {\n        this._accumulationParams = new Vector4(0.0, 0.0, 0.0, 0.0);\n        /** Enable the debug view for this pass */\n        this.debugEnabled = false;\n        /**\n         * Is the effect enabled\n         */\n        this.enabled = true;\n        /**\n         * Observable that triggers when the accumulation texture is ready\n         */\n        this.onReadyObservable = new Observable();\n        this._debugPassName = \"Shadow Accumulation Debug Pass\";\n        this._remanence = 0.9;\n        this._reset = true;\n        this._isMoving = false;\n        this._debugSizeParams = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this._renderWhenGBufferReady = null;\n        this._scene = scene;\n        this._engine = scene.getEngine();\n        this._renderPipeline = iblShadowsRenderPipeline;\n        this._createTextures();\n    }\n    _createTextures() {\n        const isWebGPU = this._engine.isWebGPU;\n        const outputTextureOptions = {\n            type: Constants.TEXTURETYPE_HALF_FLOAT,\n            format: Constants.TEXTUREFORMAT_RGBA,\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n            generateDepthBuffer: false,\n            generateMipMaps: false,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../../ShadersWGSL/iblShadowAccumulation.fragment\")]);\n                }\n                else {\n                    await Promise.all([import(\"../../Shaders/iblShadowAccumulation.fragment\")]);\n                }\n            },\n        };\n        this._outputTexture = new ProceduralTexture(\"shadowAccumulationPass\", {\n            width: this._engine.getRenderWidth(),\n            height: this._engine.getRenderHeight(),\n        }, \"iblShadowAccumulation\", this._scene, outputTextureOptions);\n        this._outputTexture.refreshRate = 1;\n        this._outputTexture.autoClear = false;\n        this._outputTexture.onGeneratedObservable.addOnce(() => {\n            this.onReadyObservable.notifyObservers();\n        });\n        // Need to set all the textures first so that the effect gets created with the proper uniforms.\n        this._setOutputTextureBindings();\n        this._renderWhenGBufferReady = this._render.bind(this);\n        // Don't start rendering until the first vozelization is done.\n        this._renderPipeline.onVoxelizationCompleteObservable.addOnce(() => {\n            this._scene.geometryBufferRenderer.getGBuffer().onAfterRenderObservable.add(this._renderWhenGBufferReady);\n        });\n        // Create the accumulation texture for the previous frame.\n        // We'll copy the output of the accumulation pass to this texture at the start of every frame.\n        const accumulationOptions = {\n            type: Constants.TEXTURETYPE_HALF_FLOAT,\n            format: Constants.TEXTUREFORMAT_RGBA,\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n            generateDepthBuffer: false,\n            generateMipMaps: false,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../../ShadersWGSL/pass.fragment\")]);\n                }\n                else {\n                    await Promise.all([import(\"../../Shaders/pass.fragment\")]);\n                }\n            },\n        };\n        this._oldAccumulationCopy = new ProceduralTexture(\"oldAccumulationRT\", { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, \"pass\", this._scene, accumulationOptions, false);\n        this._oldAccumulationCopy.autoClear = false;\n        this._oldAccumulationCopy.refreshRate = 1;\n        this._oldAccumulationCopy.onBeforeGenerationObservable.add(this._setAccumulationCopyBindings.bind(this));\n        this._setAccumulationCopyBindings();\n        // Create the local position texture for the previous frame.\n        // We'll copy the previous local position texture to this texture at the start of every frame.\n        const localPositionOptions = {\n            type: Constants.TEXTURETYPE_HALF_FLOAT,\n            format: Constants.TEXTUREFORMAT_RGBA,\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n            generateDepthBuffer: false,\n            generateMipMaps: false,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../../ShadersWGSL/pass.fragment\")]);\n                }\n                else {\n                    await Promise.all([import(\"../../Shaders/pass.fragment\")]);\n                }\n            },\n        };\n        this._oldPositionCopy = new ProceduralTexture(\"oldLocalPositionRT\", { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, \"pass\", this._scene, localPositionOptions, false);\n        this._updatePositionCopy();\n        this._oldPositionCopy.autoClear = false;\n        this._oldPositionCopy.refreshRate = 1;\n        this._oldPositionCopy.onBeforeGenerationObservable.add(this._updatePositionCopy.bind(this));\n    }\n    _setOutputTextureBindings() {\n        const remanence = this._isMoving ? this.remanence : 0.99;\n        this._accumulationParams.set(remanence, this.reset ? 1.0 : 0.0, this._renderPipeline.voxelGridSize, 0.0);\n        this._outputTexture.setTexture(\"spatialBlurSampler\", this._renderPipeline._getSpatialBlurTexture());\n        this._outputTexture.setVector4(\"accumulationParameters\", this._accumulationParams);\n        this._outputTexture.setTexture(\"oldAccumulationSampler\", this._oldAccumulationCopy ? this._oldAccumulationCopy : this._renderPipeline._dummyTexture2d);\n        this._outputTexture.setTexture(\"prevPositionSampler\", this._oldPositionCopy ? this._oldPositionCopy : this._renderPipeline._dummyTexture2d);\n        const geometryBufferRenderer = this._scene.geometryBufferRenderer;\n        if (!geometryBufferRenderer) {\n            return false;\n        }\n        const velocityIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_LINEAR_TEXTURE_TYPE);\n        this._outputTexture.setTexture(\"motionSampler\", geometryBufferRenderer.getGBuffer().textures[velocityIndex]);\n        const wPositionIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);\n        this._outputTexture.setTexture(\"positionSampler\", geometryBufferRenderer.getGBuffer().textures[wPositionIndex]);\n        this.reset = false;\n        this._isMoving = false;\n        return true;\n    }\n    _updatePositionCopy() {\n        const geometryBufferRenderer = this._scene.geometryBufferRenderer;\n        const index = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);\n        this._oldPositionCopy.setTexture(\"textureSampler\", geometryBufferRenderer.getGBuffer().textures[index]);\n    }\n    _setAccumulationCopyBindings() {\n        this._oldAccumulationCopy.setTexture(\"textureSampler\", this._outputTexture);\n    }\n    _render() {\n        if (this.enabled && this._outputTexture.isReady() && this._outputTexture.getEffect()?.isReady()) {\n            if (this._setOutputTextureBindings()) {\n                this._outputTexture.render();\n            }\n        }\n    }\n    /**\n     * Called by render pipeline when canvas resized.\n     * @param scaleFactor The factor by which to scale the canvas size.\n     */\n    resize(scaleFactor = 1.0) {\n        const newSize = {\n            width: Math.max(1.0, Math.floor(this._engine.getRenderWidth() * scaleFactor)),\n            height: Math.max(1.0, Math.floor(this._engine.getRenderHeight() * scaleFactor)),\n        };\n        // Don't resize if the size is the same as the current size.\n        if (this._outputTexture.getSize().width === newSize.width && this._outputTexture.getSize().height === newSize.height) {\n            return;\n        }\n        this._outputTexture.resize(newSize, false);\n        this._oldAccumulationCopy.resize(newSize, false);\n        this._oldPositionCopy.resize({ width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, false);\n        this.reset = true;\n    }\n    _disposeTextures() {\n        this._oldAccumulationCopy.dispose();\n        this._oldPositionCopy.dispose();\n        this._outputTexture.dispose();\n    }\n    /**\n     * Checks if the pass is ready\n     * @returns true if the pass is ready\n     */\n    isReady() {\n        return (this._oldAccumulationCopy &&\n            this._oldAccumulationCopy.isReady() &&\n            this._oldPositionCopy &&\n            this._oldPositionCopy.isReady() &&\n            this._outputTexture.isReady() &&\n            !(this._debugPassPP && !this._debugPassPP.isReady()));\n    }\n    /**\n     * Disposes the associated resources\n     */\n    dispose() {\n        if (this._scene.geometryBufferRenderer && this._renderWhenGBufferReady) {\n            const gBuffer = this._scene.geometryBufferRenderer.getGBuffer();\n            gBuffer.onAfterRenderObservable.removeCallback(this._renderWhenGBufferReady);\n        }\n        this._disposeTextures();\n        if (this._debugPassPP) {\n            this._debugPassPP.dispose();\n        }\n        this.onReadyObservable.clear();\n    }\n}\n//# sourceMappingURL=iblShadowsAccumulationPass.js.map","import { Texture } from \"./texture\";\nimport { Constants } from \"../../Engines/constants\";\n/**\n * Class used to store 3D textures containing user data\n */\nexport class RawTexture3D extends Texture {\n    /**\n     * Gets the width of the texture\n     */\n    get width() {\n        return this._texture ? this._texture.width : 0;\n    }\n    /**\n     * Gets the height of the texture\n     */\n    get height() {\n        return this._texture ? this._texture.height : 0;\n    }\n    /**\n     * Gets the depth of the texture\n     */\n    get depth() {\n        return this._texture ? this._texture.depth : 0;\n    }\n    /**\n     * Create a new RawTexture3D\n     * @param data defines the data of the texture\n     * @param width defines the width of the texture\n     * @param height defines the height of the texture\n     * @param depth defines the depth of the texture\n     * @param format defines the texture format to use\n     * @param scene defines the hosting scene\n     * @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)\n     * @param invertY defines if texture must be stored with Y axis inverted\n     * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)\n     * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_BYTE, Engine.TEXTURETYPE_FLOAT...)\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\n     */\n    constructor(data, width, height, depth, \n    /** Gets or sets the texture format to use */\n    format, scene, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE, creationFlags) {\n        super(null, scene, !generateMipMaps, invertY);\n        this.format = format;\n        this._texture = scene.getEngine().createRawTexture3D(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, null, textureType, creationFlags);\n        this.is3D = true;\n    }\n    /**\n     * Update the texture with new data\n     * @param data defines the data to store in the texture\n     */\n    update(data) {\n        if (!this._texture) {\n            return;\n        }\n        this._getEngine().updateRawTexture3D(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type);\n    }\n}\n//# sourceMappingURL=rawTexture3D.js.map","import { __decorate } from \"tslib\";\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\nimport { MaterialPluginBase } from \"core/Materials/materialPluginBase\";\nimport { Constants } from \"core/Engines/constants\";\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\nimport { expandToProperty, serialize } from \"core/Misc/decorators\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { OpenPBRMaterial } from \"core/Materials/PBR/openPbrMaterial\";\n/**\n * @internal\n */\nclass MaterialIBLShadowsRenderDefines extends MaterialDefines {\n    constructor() {\n        super(...arguments);\n        this.RENDER_WITH_IBL_SHADOWS = false;\n        this.COLORED_IBL_SHADOWS = false;\n    }\n}\n/**\n * Plugin used to render the contribution from IBL shadows.\n */\nexport class IBLShadowsPluginMaterial extends MaterialPluginBase {\n    get isColored() {\n        return this._isColored;\n    }\n    set isColored(value) {\n        if (this._isColored === value) {\n            return;\n        }\n        this._isColored = value;\n        this._markAllSubMeshesAsTexturesDirty();\n    }\n    _markAllSubMeshesAsTexturesDirty() {\n        this._enable(this._isEnabled);\n        this._internalMarkAllSubMeshesAsTexturesDirty();\n    }\n    /**\n     * Gets a boolean indicating that the plugin is compatible with a give shader language.\n     * @returns true if the plugin is compatible with the shader language\n     */\n    isCompatible() {\n        return true;\n    }\n    constructor(material) {\n        super(material, IBLShadowsPluginMaterial.Name, 310, new MaterialIBLShadowsRenderDefines());\n        /**\n         * The opacity of the shadows.\n         */\n        this.shadowOpacity = 1.0;\n        this._isEnabled = false;\n        this._isColored = false;\n        /**\n         * Defines if the plugin is enabled in the material.\n         */\n        this.isEnabled = false;\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\n    }\n    prepareDefines(defines) {\n        defines.RENDER_WITH_IBL_SHADOWS = this._isEnabled;\n        defines.COLORED_IBL_SHADOWS = this.isColored;\n    }\n    getClassName() {\n        return \"IBLShadowsPluginMaterial\";\n    }\n    getUniforms() {\n        return {\n            ubo: [\n                { name: \"renderTargetSize\", size: 2, type: \"vec2\" },\n                { name: \"shadowOpacity\", size: 1, type: \"float\" },\n            ],\n            fragment: `#ifdef RENDER_WITH_IBL_SHADOWS\r\n                    uniform vec2 renderTargetSize;\r\n                    uniform float shadowOpacity;\r\n                #endif`,\n        };\n    }\n    getSamplers(samplers) {\n        samplers.push(\"iblShadowsTexture\");\n    }\n    bindForSubMesh(uniformBuffer) {\n        if (this._isEnabled) {\n            uniformBuffer.bindTexture(\"iblShadowsTexture\", this.iblShadowsTexture);\n            uniformBuffer.updateFloat2(\"renderTargetSize\", this._material.getScene().getEngine().getRenderWidth(), this._material.getScene().getEngine().getRenderHeight());\n            uniformBuffer.updateFloat(\"shadowOpacity\", this.shadowOpacity);\n        }\n    }\n    getCustomCode(shaderType, shaderLanguage) {\n        let frag;\n        if (shaderLanguage === 1 /* ShaderLanguage.WGSL */) {\n            frag = {\n                // eslint-disable-next-line @typescript-eslint/naming-convention\n                CUSTOM_FRAGMENT_DEFINITIONS: `\r\n                #ifdef RENDER_WITH_IBL_SHADOWS\r\n                    var iblShadowsTextureSampler: sampler;\r\n                    var iblShadowsTexture: texture_2d<f32>;\r\n\r\n                    #ifdef COLORED_IBL_SHADOWS\r\n                        fn computeIndirectShadow() -> vec3f {\r\n                            var uv = fragmentInputs.position.xy / uniforms.renderTargetSize;\r\n                            var shadowValue: vec3f = textureSample(iblShadowsTexture, iblShadowsTextureSampler, uv).rgb;\r\n                            return mix(shadowValue, vec3f(1.0), 1.0 - uniforms.shadowOpacity);\r\n                        }\r\n                    #else\r\n                        fn computeIndirectShadow() -> vec2f {\r\n                            var uv = fragmentInputs.position.xy / uniforms.renderTargetSize;\r\n                            var shadowValue: vec2f = textureSample(iblShadowsTexture, iblShadowsTextureSampler, uv).rg;\r\n                            return mix(shadowValue, vec2f(1.0), 1.0 - uniforms.shadowOpacity);\r\n                        }\r\n                    #endif\r\n                #endif\r\n            `,\n            };\n            if (this._material instanceof PBRBaseMaterial) {\n                // eslint-disable-next-line @typescript-eslint/naming-convention\n                frag[\"CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION\"] = `\r\n                #ifdef RENDER_WITH_IBL_SHADOWS\r\n                    #ifndef UNLIT\r\n                        #ifdef REFLECTION\r\n                            #ifdef COLORED_IBL_SHADOWS\r\n                                var shadowValue: vec3f = computeIndirectShadow();\r\n                                finalIrradiance *= shadowValue;\r\n                                finalRadianceScaled *= mix(vec3f(1.0), shadowValue, roughness);\r\n                            #else\r\n                                var shadowValue: vec2f = computeIndirectShadow();\r\n                                finalIrradiance *= vec3f(shadowValue.x);\r\n                                finalRadianceScaled *= vec3f(mix(pow(shadowValue.y, 4.0), shadowValue.x, roughness));\r\n                            #endif\r\n                        #endif\r\n                    #else\r\n                        finalDiffuse *= computeIndirectShadow().x;\r\n                    #endif\r\n                #endif\r\n            `;\n            }\n            else if (this._material instanceof OpenPBRMaterial) {\n                // eslint-disable-next-line @typescript-eslint/naming-convention\n                frag[\"CUSTOM_FRAGMENT_BEFORE_IBLLAYERCOMPOSITION\"] = `\r\n                #ifdef RENDER_WITH_IBL_SHADOWS\r\n                    #ifndef UNLIT\r\n                        #ifdef REFLECTION\r\n                            #ifdef COLORED_IBL_SHADOWS\r\n                                var shadowValue: vec3f = computeIndirectShadow();\r\n                                slab_diffuse_ibl *= shadowValue;\r\n                                slab_glossy_ibl *= mix(vec3f(1.0), shadowValue, specularAlphaG);\r\n                            #else\r\n                                var shadowValue: vec2f = computeIndirectShadow();\r\n                                slab_diffuse_ibl *= vec3f(shadowValue.x);\r\n                                slab_glossy_ibl *= vec3f(mix(pow(shadowValue.y, 4.0), shadowValue.x, specularAlphaG));\r\n                            #endif\r\n                        #endif\r\n                    #else\r\n                        slab_diffuse_ibl *= computeIndirectShadow().x;\r\n                    #endif\r\n                #endif\r\n            `;\n            }\n            else {\n                frag[\"CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\"] = `\r\n                #ifdef RENDER_WITH_IBL_SHADOWS\r\n                    #ifdef COLORED_IBL_SHADOWS\r\n                        var shadowValue: vec3f = computeIndirectShadow();\r\n                        color *= toGammaSpace(vec4f(shadowValue, 1.0f));\r\n                    #else\r\n                        var shadowValue: vec2f = computeIndirectShadow();\r\n                        color *= toGammaSpace(vec4f(shadowValue.x, shadowValue.x, shadowValue.x, 1.0f));\r\n                    #endif\r\n                #endif\r\n            `;\n            }\n        }\n        else {\n            frag = {\n                // eslint-disable-next-line @typescript-eslint/naming-convention\n                CUSTOM_FRAGMENT_DEFINITIONS: `\r\n                #ifdef RENDER_WITH_IBL_SHADOWS\r\n                    uniform sampler2D iblShadowsTexture;\r\n                #ifdef COLORED_IBL_SHADOWS\r\n                    vec3 computeIndirectShadow() {\r\n                        vec2 uv = gl_FragCoord.xy / renderTargetSize;\r\n                        vec3 shadowValue = texture2D(iblShadowsTexture, uv).rgb;\r\n                        return mix(shadowValue.rgb, vec3(1.0), 1.0 - shadowOpacity);\r\n                    }\r\n                #else\r\n                    vec2 computeIndirectShadow() {\r\n                        vec2 uv = gl_FragCoord.xy / renderTargetSize;\r\n                        vec2 shadowValue = texture2D(iblShadowsTexture, uv).rg;\r\n                        return mix(shadowValue.rg, vec2(1.0), 1.0 - shadowOpacity);\r\n                    }\r\n                #endif\r\n                #endif\r\n            `,\n            };\n            if (this._material instanceof PBRBaseMaterial) {\n                // eslint-disable-next-line @typescript-eslint/naming-convention\n                frag[\"CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION\"] = `\r\n                #ifdef RENDER_WITH_IBL_SHADOWS\r\n                    #ifndef UNLIT\r\n                        #ifdef REFLECTION\r\n                            #ifdef COLORED_IBL_SHADOWS\r\n                                vec3 shadowValue = computeIndirectShadow();\r\n                                finalIrradiance.rgb *= shadowValue.rgb;\r\n                                finalRadianceScaled *= mix(vec3(1.0), shadowValue.rgb, roughness);\r\n                            #else\r\n                                vec2 shadowValue = computeIndirectShadow();\r\n                                finalIrradiance *= shadowValue.x;\r\n                                finalRadianceScaled *= mix(pow(shadowValue.y, 4.0), shadowValue.x, roughness);\r\n                            #endif\r\n                        #endif\r\n                    #else\r\n                        finalDiffuse *= computeIndirectShadow().x;\r\n                    #endif\r\n                #endif\r\n            `;\n            }\n            else if (this._material instanceof OpenPBRMaterial) {\n                // eslint-disable-next-line @typescript-eslint/naming-convention\n                frag[\"CUSTOM_FRAGMENT_BEFORE_IBLLAYERCOMPOSITION\"] = `\r\n                #ifdef RENDER_WITH_IBL_SHADOWS\r\n                    #ifndef UNLIT\r\n                        #ifdef REFLECTION\r\n                            #ifdef COLORED_IBL_SHADOWS\r\n                                vec3 shadowValue = computeIndirectShadow();\r\n                                slab_diffuse_ibl.rgb *= shadowValue.rgb;\r\n                                slab_glossy_ibl *= mix(vec3(1.0), shadowValue.rgb, specularAlphaG);\r\n                            #else\r\n                                vec2 shadowValue = computeIndirectShadow();\r\n                                slab_diffuse_ibl *= shadowValue.x;\r\n                                slab_glossy_ibl *= mix(pow(shadowValue.y, 4.0), shadowValue.x, specularAlphaG);\r\n                            #endif\r\n                        #endif\r\n                    #else\r\n                        slab_diffuse_ibl *= computeIndirectShadow().x;\r\n                    #endif\r\n                #endif\r\n            `;\n            }\n            else {\n                frag[\"CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\"] = `\r\n                #ifdef RENDER_WITH_IBL_SHADOWS\r\n                    #ifdef COLORED_IBL_SHADOWS\r\n                        vec3 shadowValue = computeIndirectShadow();\r\n                        color.rgb *= toGammaSpace(shadowValue.rgb);\r\n                    #else\r\n                        vec2 shadowValue = computeIndirectShadow();\r\n                        color.rgb *= toGammaSpace(shadowValue.x);\r\n                    #endif\r\n                #endif\r\n            `;\n            }\n        }\n        return shaderType === \"vertex\" ? null : frag;\n    }\n}\n/**\n * Defines the name of the plugin.\n */\nIBLShadowsPluginMaterial.Name = \"IBLShadowsPluginMaterial\";\n__decorate([\n    serialize()\n], IBLShadowsPluginMaterial.prototype, \"shadowOpacity\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], IBLShadowsPluginMaterial.prototype, \"isEnabled\", void 0);\nRegisterClass(`BABYLON.IBLShadowsPluginMaterial`, IBLShadowsPluginMaterial);\n//# sourceMappingURL=iblShadowsPluginMaterial.js.map","import { Constants } from \"../../Engines/constants\";\nimport { EngineStore } from \"../../Engines/engineStore\";\nimport { Matrix, Vector3, Vector4, Quaternion } from \"../../Maths/math.vector\";\nimport { Texture } from \"../../Materials/Textures/texture\";\nimport { Logger } from \"../../Misc/logger\";\nimport { _IblShadowsVoxelRenderer } from \"./iblShadowsVoxelRenderer\";\nimport { _IblShadowsVoxelTracingPass } from \"./iblShadowsVoxelTracingPass\";\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\nimport { _IblShadowsSpatialBlurPass } from \"./iblShadowsSpatialBlurPass\";\nimport { _IblShadowsAccumulationPass } from \"./iblShadowsAccumulationPass\";\nimport { PostProcessRenderPipeline } from \"../../PostProcesses/RenderPipeline/postProcessRenderPipeline\";\nimport { PostProcessRenderEffect } from \"core/PostProcesses/RenderPipeline/postProcessRenderEffect\";\nimport { GeometryBufferRenderer } from \"core/Rendering/geometryBufferRenderer\";\nimport { RawTexture } from \"core/Materials/Textures/rawTexture\";\nimport { RawTexture3D } from \"core/Materials/Textures/rawTexture3D\";\nimport { Engine } from \"core/Engines/engine\";\nimport { IBLShadowsPluginMaterial } from \"./iblShadowsPluginMaterial\";\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\nimport { Observable } from \"core/Misc/observable\";\nimport \"../geometryBufferRendererSceneComponent\";\nimport \"../iblCdfGeneratorSceneComponent\";\nimport { OpenPBRMaterial } from \"core/Materials/PBR/openPbrMaterial\";\n/**\n * Voxel-based shadow rendering for IBL's.\n * This should not be instanciated directly, as it is part of a scene component\n */\nexport class IblShadowsRenderPipeline extends PostProcessRenderPipeline {\n    /**\n     * Reset the shadow accumulation. This has a similar affect to lowering the remanence for a single frame.\n     * This is useful when making a sudden change to the IBL.\n     */\n    resetAccumulation() {\n        this._accumulationPass.reset = true;\n    }\n    /**\n     * How dark the shadows appear. 1.0 is full opacity, 0.0 is no shadows.\n     */\n    get shadowOpacity() {\n        return this._shadowOpacity;\n    }\n    set shadowOpacity(value) {\n        this._shadowOpacity = value;\n        this._setPluginParameters();\n    }\n    /**\n     * Render the shadows in color rather than black and white.\n     * This is slightly more expensive than black and white shadows but can be much\n     * more accurate when the strongest lights in the IBL are non-white.\n     */\n    get coloredShadows() {\n        return this._coloredShadows;\n    }\n    set coloredShadows(value) {\n        this._coloredShadows = value;\n        this._voxelTracingPass.coloredShadows = value;\n        this._setPluginParameters();\n    }\n    /**\n     * A multiplier for the render size of the shadows. Used for rendering lower-resolution shadows.\n     */\n    get shadowRenderSizeFactor() {\n        return this._renderSizeFactor;\n    }\n    set shadowRenderSizeFactor(value) {\n        this._renderSizeFactor = Math.max(Math.min(value, 1.0), 0.0);\n        this._voxelTracingPass.resize(value);\n        this._spatialBlurPass.resize(value);\n        this._accumulationPass.resize(value);\n        this._setPluginParameters();\n    }\n    /**\n     * How dark the voxel shadows appear. 1.0 is full opacity, 0.0 is no shadows.\n     */\n    get voxelShadowOpacity() {\n        return this._voxelTracingPass?.voxelShadowOpacity;\n    }\n    set voxelShadowOpacity(value) {\n        if (!this._voxelTracingPass) {\n            return;\n        }\n        this._voxelTracingPass.voxelShadowOpacity = value;\n    }\n    /**\n     * How dark the screen-space shadows appear. 1.0 is full opacity, 0.0 is no shadows.\n     */\n    get ssShadowOpacity() {\n        return this._voxelTracingPass?.ssShadowOpacity;\n    }\n    set ssShadowOpacity(value) {\n        if (!this._voxelTracingPass) {\n            return;\n        }\n        this._voxelTracingPass.ssShadowOpacity = value;\n    }\n    /**\n     * The number of samples used in the screen space shadow pass.\n     */\n    get ssShadowSampleCount() {\n        return this._voxelTracingPass?.sssSamples;\n    }\n    set ssShadowSampleCount(value) {\n        if (!this._voxelTracingPass) {\n            return;\n        }\n        this._voxelTracingPass.sssSamples = value;\n    }\n    /**\n     * The stride of the screen-space shadow pass. This controls the distance between samples\n     * in pixels.\n     */\n    get ssShadowStride() {\n        return this._voxelTracingPass?.sssStride;\n    }\n    set ssShadowStride(value) {\n        if (!this._voxelTracingPass) {\n            return;\n        }\n        this._voxelTracingPass.sssStride = value;\n    }\n    /**\n     * A scale for the maximum distance a screen-space shadow can be cast in world-space.\n     * The maximum distance that screen-space shadows cast is derived from the voxel size\n     * and this value so shouldn't need to change if you scale your scene\n     */\n    get ssShadowDistanceScale() {\n        return this._sssMaxDistScale;\n    }\n    set ssShadowDistanceScale(value) {\n        this._sssMaxDistScale = value;\n        this._updateSsShadowParams();\n    }\n    /**\n     * Screen-space shadow thickness scale. This value controls the assumed thickness of\n     * on-screen surfaces in world-space. It scales with the size of the shadow-casting\n     * region so shouldn't need to change if you scale your scene.\n     */\n    get ssShadowThicknessScale() {\n        return this._sssThicknessScale;\n    }\n    set ssShadowThicknessScale(value) {\n        this._sssThicknessScale = value;\n        this._updateSsShadowParams();\n    }\n    /**\n     * Returns the texture containing the voxel grid data\n     * @returns The texture containing the voxel grid data\n     * @internal\n     */\n    _getVoxelGridTexture() {\n        const tex = this._voxelRenderer?.getVoxelGrid();\n        if (tex && tex.isReady()) {\n            return tex;\n        }\n        return this._dummyTexture3d;\n    }\n    /**\n     * Returns the noise texture.\n     * @returns The noise texture.\n     * @internal\n     */\n    _getNoiseTexture() {\n        const tex = this._noiseTexture;\n        if (tex && tex.isReady()) {\n            return tex;\n        }\n        return this._dummyTexture2d;\n    }\n    /**\n     * Returns the voxel-tracing texture.\n     * @returns The voxel-tracing texture.\n     * @internal\n     */\n    _getVoxelTracingTexture() {\n        const tex = this._voxelTracingPass?.getOutputTexture();\n        if (tex && tex.isReady()) {\n            return tex;\n        }\n        return this._dummyTexture2d;\n    }\n    /**\n     * Returns the spatial blur texture.\n     * @returns The spatial blur texture.\n     * @internal\n     */\n    _getSpatialBlurTexture() {\n        const tex = this._spatialBlurPass.getOutputTexture();\n        if (tex && tex.isReady()) {\n            return tex;\n        }\n        return this._dummyTexture2d;\n    }\n    /**\n     * Returns the accumulated shadow texture.\n     * @returns The accumulated shadow texture.\n     * @internal\n     */\n    _getAccumulatedTexture() {\n        const tex = this._accumulationPass?.getOutputTexture();\n        if (tex && tex.isReady()) {\n            return tex;\n        }\n        return this._dummyTexture2d;\n    }\n    /**\n     * Turn on or off the debug view of the G-Buffer. This will display only the targets\n     * of the g-buffer that are used by the shadow pipeline.\n     */\n    get gbufferDebugEnabled() {\n        return this._gbufferDebugEnabled;\n    }\n    set gbufferDebugEnabled(enabled) {\n        if (enabled && !this.allowDebugPasses) {\n            Logger.Warn(\"Can't enable G-Buffer debug view without setting allowDebugPasses to true.\");\n            return;\n        }\n        this._gbufferDebugEnabled = enabled;\n        if (enabled) {\n            this._enableEffect(this._getGBufferDebugPass().name, this.cameras);\n        }\n        else {\n            this._disableEffect(this._getGBufferDebugPass().name, this.cameras);\n        }\n    }\n    /**\n     * Turn on or off the debug view of the CDF importance sampling data\n     */\n    get cdfDebugEnabled() {\n        return this.scene.iblCdfGenerator ? this.scene.iblCdfGenerator.debugEnabled : false;\n    }\n    /**\n     * Turn on or off the debug view of the CDF importance sampling data\n     */\n    set cdfDebugEnabled(enabled) {\n        if (!this.scene.iblCdfGenerator) {\n            return;\n        }\n        if (enabled && !this.allowDebugPasses) {\n            Logger.Warn(\"Can't enable importance sampling debug view without setting allowDebugPasses to true.\");\n            return;\n        }\n        if (enabled === this.scene.iblCdfGenerator.debugEnabled) {\n            return;\n        }\n        this.scene.iblCdfGenerator.debugEnabled = enabled;\n        if (enabled) {\n            this._enableEffect(this.scene.iblCdfGenerator.debugPassName, this.cameras);\n        }\n        else {\n            this._disableEffect(this.scene.iblCdfGenerator.debugPassName, this.cameras);\n        }\n    }\n    /**\n     * This displays the voxel grid in slices spread across the screen.\n     * It also displays what slices of the model are stored in each layer\n     * of the voxel grid. Each red stripe represents one layer while each gradient\n     * (from bright red to black) represents the layers rendered in a single draw call.\n     */\n    get voxelDebugEnabled() {\n        return this._voxelRenderer?.voxelDebugEnabled;\n    }\n    set voxelDebugEnabled(enabled) {\n        if (!this._voxelRenderer) {\n            return;\n        }\n        if (enabled && !this.allowDebugPasses) {\n            Logger.Warn(\"Can't enable voxel debug view without setting allowDebugPasses to true.\");\n            return;\n        }\n        this._voxelRenderer.voxelDebugEnabled = enabled;\n        if (enabled) {\n            this._enableEffect(this._voxelRenderer.debugPassName, this.cameras);\n        }\n        else {\n            this._disableEffect(this._voxelRenderer.debugPassName, this.cameras);\n        }\n    }\n    /**\n     * When using tri-planar voxelization (the default), this value can be used to\n     * display only the voxelization result for that axis. z-axis = 0, y-axis = 1, x-axis = 2\n     */\n    get voxelDebugAxis() {\n        return this._voxelRenderer?.voxelDebugAxis;\n    }\n    set voxelDebugAxis(axisNum) {\n        if (!this._voxelRenderer) {\n            return;\n        }\n        this._voxelRenderer.voxelDebugAxis = axisNum;\n    }\n    /**\n     * Displays a given mip of the voxel grid. `voxelDebugAxis` must be undefined in this\n     * case because we only generate mips for the combined voxel grid.\n     */\n    set voxelDebugDisplayMip(mipNum) {\n        if (!this._voxelRenderer) {\n            return;\n        }\n        this._voxelRenderer.setDebugMipNumber(mipNum);\n    }\n    /**\n     * Display the debug view for just the shadow samples taken this frame.\n     */\n    get voxelTracingDebugEnabled() {\n        return this._voxelTracingPass?.debugEnabled;\n    }\n    set voxelTracingDebugEnabled(enabled) {\n        if (!this._voxelTracingPass) {\n            return;\n        }\n        if (enabled && !this.allowDebugPasses) {\n            Logger.Warn(\"Can't enable voxel tracing debug view without setting allowDebugPasses to true.\");\n            return;\n        }\n        if (enabled === this._voxelTracingPass.debugEnabled) {\n            return;\n        }\n        this._voxelTracingPass.debugEnabled = enabled;\n        if (enabled) {\n            this._enableEffect(this._voxelTracingPass.debugPassName, this.cameras);\n        }\n        else {\n            this._disableEffect(this._voxelTracingPass.debugPassName, this.cameras);\n        }\n    }\n    /**\n     * Display the debug view for the spatial blur pass\n     */\n    get spatialBlurPassDebugEnabled() {\n        return this._spatialBlurPass.debugEnabled;\n    }\n    set spatialBlurPassDebugEnabled(enabled) {\n        if (!this._spatialBlurPass) {\n            return;\n        }\n        if (enabled && !this.allowDebugPasses) {\n            Logger.Warn(\"Can't enable spatial blur debug view without setting allowDebugPasses to true.\");\n            return;\n        }\n        if (enabled === this._spatialBlurPass.debugEnabled) {\n            return;\n        }\n        this._spatialBlurPass.debugEnabled = enabled;\n        if (enabled) {\n            this._enableEffect(this._spatialBlurPass.debugPassName, this.cameras);\n        }\n        else {\n            this._disableEffect(this._spatialBlurPass.debugPassName, this.cameras);\n        }\n    }\n    /**\n     * Display the debug view for the shadows accumulated over time.\n     */\n    get accumulationPassDebugEnabled() {\n        return this._accumulationPass?.debugEnabled;\n    }\n    set accumulationPassDebugEnabled(enabled) {\n        if (!this._accumulationPass) {\n            return;\n        }\n        if (enabled && !this.allowDebugPasses) {\n            Logger.Warn(\"Can't enable accumulation pass debug view without setting allowDebugPasses to true.\");\n            return;\n        }\n        if (enabled === this._accumulationPass.debugEnabled) {\n            return;\n        }\n        this._accumulationPass.debugEnabled = enabled;\n        if (enabled) {\n            this._enableEffect(this._accumulationPass.debugPassName, this.cameras);\n        }\n        else {\n            this._disableEffect(this._accumulationPass.debugPassName, this.cameras);\n        }\n    }\n    /**\n     * Add a mesh to be used for shadow-casting in the IBL shadow pipeline.\n     * These meshes will be written to the voxel grid.\n     * @param mesh A mesh or list of meshes that you want to cast shadows\n     */\n    addShadowCastingMesh(mesh) {\n        if (Array.isArray(mesh)) {\n            for (const m of mesh) {\n                if (m && this._shadowCastingMeshes.indexOf(m) === -1) {\n                    this._shadowCastingMeshes.push(m);\n                }\n            }\n        }\n        else {\n            if (mesh && this._shadowCastingMeshes.indexOf(mesh) === -1) {\n                this._shadowCastingMeshes.push(mesh);\n            }\n        }\n    }\n    /**\n     * Remove a mesh from the shadow-casting list. The mesh will no longer be written\n     * to the voxel grid and will not cast shadows.\n     * @param mesh The mesh or list of meshes that you don't want to cast shadows.\n     */\n    removeShadowCastingMesh(mesh) {\n        if (Array.isArray(mesh)) {\n            for (const m of mesh) {\n                const index = this._shadowCastingMeshes.indexOf(m);\n                if (index !== -1) {\n                    this._shadowCastingMeshes.splice(index, 1);\n                }\n            }\n        }\n        else {\n            const index = this._shadowCastingMeshes.indexOf(mesh);\n            if (index !== -1) {\n                this._shadowCastingMeshes.splice(index, 1);\n            }\n        }\n    }\n    /**\n     * Clear the list of shadow-casting meshes. This will remove all meshes from the list\n     */\n    clearShadowCastingMeshes() {\n        this._shadowCastingMeshes.length = 0;\n    }\n    /**\n     * The exponent of the resolution of the voxel shadow grid. Higher resolutions will result in sharper\n     * shadows but are more expensive to compute and require more memory.\n     * The resolution is calculated as 2 to the power of this number.\n     */\n    get resolutionExp() {\n        return this._voxelRenderer.voxelResolutionExp;\n    }\n    set resolutionExp(newResolution) {\n        if (newResolution === this._voxelRenderer.voxelResolutionExp) {\n            return;\n        }\n        if (this._voxelRenderer.isVoxelizationInProgress()) {\n            Logger.Warn(\"Can't change the resolution of the voxel grid while voxelization is in progress.\");\n            return;\n        }\n        this._voxelRenderer.voxelResolutionExp = Math.max(1, Math.min(newResolution, 8));\n        this._accumulationPass.reset = true;\n    }\n    /**\n     * The number of different directions to sample during the voxel tracing pass\n     */\n    get sampleDirections() {\n        return this._voxelTracingPass?.sampleDirections;\n    }\n    /**\n     * The number of different directions to sample during the voxel tracing pass\n     */\n    set sampleDirections(value) {\n        if (!this._voxelTracingPass) {\n            return;\n        }\n        this._voxelTracingPass.sampleDirections = value;\n    }\n    /**\n     * The decree to which the shadows persist between frames. 0.0 is no persistence, 1.0 is full persistence.\n     **/\n    get shadowRemanence() {\n        return this._accumulationPass?.remanence;\n    }\n    /**\n     * The decree to which the shadows persist between frames. 0.0 is no persistence, 1.0 is full persistence.\n     **/\n    set shadowRemanence(value) {\n        if (!this._accumulationPass) {\n            return;\n        }\n        this._accumulationPass.remanence = value;\n    }\n    /**\n     * The global Y-axis rotation of the IBL for shadows. This should match the Y-rotation of the environment map applied to materials, skybox, etc.\n     */\n    get envRotation() {\n        return this._voxelTracingPass?.envRotation;\n    }\n    /**\n     * The global Y-axis rotation of the IBL for shadows. This should match the Y-rotation of the environment map applied to materials, skybox, etc.\n     */\n    set envRotation(value) {\n        if (!this._voxelTracingPass) {\n            return;\n        }\n        this._voxelTracingPass.envRotation = value;\n        this._accumulationPass.reset = true;\n    }\n    /**\n     * Allow debug passes to be enabled. Default is false.\n     */\n    get allowDebugPasses() {\n        return this._allowDebugPasses;\n    }\n    /**\n     * Allow debug passes to be enabled. Default is false.\n     */\n    set allowDebugPasses(value) {\n        if (this._allowDebugPasses === value) {\n            return;\n        }\n        this._allowDebugPasses = value;\n        if (value && this.scene.iblCdfGenerator) {\n            if (this.scene.iblCdfGenerator.isReady()) {\n                this._createDebugPasses();\n            }\n            else {\n                this.scene.iblCdfGenerator.onGeneratedObservable.addOnce(() => {\n                    this._createDebugPasses();\n                });\n            }\n        }\n        else {\n            this._disposeDebugPasses();\n        }\n    }\n    /**\n     *  Support test.\n     */\n    static get IsSupported() {\n        const engine = EngineStore.LastCreatedEngine;\n        if (!engine) {\n            return false;\n        }\n        return engine._features.supportIBLShadows;\n    }\n    /**\n     * Toggle the shadow tracing on or off\n     * @param enabled Toggle the shadow tracing on or off\n     */\n    toggleShadow(enabled) {\n        this._enabled = enabled;\n        this._voxelTracingPass.enabled = enabled;\n        this._spatialBlurPass.enabled = enabled;\n        this._accumulationPass.enabled = enabled;\n        for (const mat of this._materialsWithRenderPlugin) {\n            if (mat.pluginManager) {\n                const plugin = mat.pluginManager.getPlugin(IBLShadowsPluginMaterial.Name);\n                plugin.isEnabled = enabled;\n            }\n        }\n        this._setPluginParameters();\n    }\n    /**\n     * Trigger the scene to be re-voxelized. This should be run when any shadow-casters have been added, removed or moved.\n     */\n    updateVoxelization() {\n        if (this._shadowCastingMeshes.length === 0) {\n            Logger.Warn(\"IBL Shadows: updateVoxelization called with no shadow-casting meshes to voxelize.\");\n            return;\n        }\n        this._voxelRenderer.updateVoxelGrid(this._shadowCastingMeshes);\n        this._voxelRenderer.onVoxelizationCompleteObservable.addOnce(() => {\n            this.onVoxelizationCompleteObservable.notifyObservers();\n        });\n        this._updateSsShadowParams();\n    }\n    /**\n     * Trigger the scene bounds of shadow-casters to be calculated. This is the world size that the voxel grid will cover and will always be a cube.\n     */\n    updateSceneBounds() {\n        const bounds = {\n            min: new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE),\n            max: new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE),\n        };\n        for (const mesh of this._shadowCastingMeshes) {\n            const localBounds = mesh.getHierarchyBoundingVectors(true);\n            bounds.min = Vector3.Minimize(bounds.min, localBounds.min);\n            bounds.max = Vector3.Maximize(bounds.max, localBounds.max);\n        }\n        const size = bounds.max.subtract(bounds.min);\n        this.voxelGridSize = Math.max(size.x, size.y, size.z);\n        if (this._shadowCastingMeshes.length === 0 || !isFinite(this.voxelGridSize) || this.voxelGridSize === 0) {\n            Logger.Warn(\"IBL Shadows: Scene size is invalid. Can't update bounds.\");\n            this.voxelGridSize = 1.0;\n            return;\n        }\n        const halfSize = this.voxelGridSize / 2.0;\n        const centre = bounds.max.add(bounds.min).multiplyByFloats(-0.5, -0.5, -0.5);\n        const invWorldScaleMatrix = Matrix.Compose(new Vector3(1.0 / halfSize, 1.0 / halfSize, 1.0 / halfSize), new Quaternion(), new Vector3(0, 0, 0));\n        const invTranslationMatrix = Matrix.Compose(new Vector3(1.0, 1.0, 1.0), new Quaternion(), centre);\n        invTranslationMatrix.multiplyToRef(invWorldScaleMatrix, invWorldScaleMatrix);\n        this._voxelTracingPass.setWorldScaleMatrix(invWorldScaleMatrix);\n        this._voxelRenderer.setWorldScaleMatrix(invWorldScaleMatrix);\n        // Set world scale for spatial blur.\n        this._spatialBlurPass.setWorldScale(halfSize * 2.0);\n        this._updateSsShadowParams();\n    }\n    /**\n     * @param name The rendering pipeline name\n     * @param scene The scene linked to this pipeline\n     * @param options Options to configure the pipeline\n     * @param cameras Cameras to apply the pipeline to.\n     */\n    constructor(name, scene, options = {}, cameras) {\n        super(scene.getEngine(), name);\n        this._allowDebugPasses = false;\n        this._debugPasses = [];\n        this._shadowCastingMeshes = [];\n        this._shadowOpacity = 0.8;\n        this._enabled = true;\n        this._coloredShadows = false;\n        this._materialsWithRenderPlugin = [];\n        /**\n         * Observable that triggers when the shadow renderer is ready\n         */\n        this.onShadowTextureReadyObservable = new Observable();\n        /**\n         * Observable that triggers when a new IBL is set and the importance sampling is ready\n         */\n        this.onNewIblReadyObservable = new Observable();\n        /**\n         * Observable that triggers when the voxelization is complete\n         */\n        this.onVoxelizationCompleteObservable = new Observable();\n        /**\n         * The current world-space size of that the voxel grid covers in the scene.\n         */\n        this.voxelGridSize = 1.0;\n        this._renderSizeFactor = 1.0;\n        this._gbufferDebugEnabled = false;\n        this._gBufferDebugSizeParams = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this.scene = scene;\n        this._cameras = cameras || [scene.activeCamera];\n        // Create the dummy textures to be used when the pipeline is not ready\n        const blackPixels = new Uint8Array([0, 0, 0, 255]);\n        this._dummyTexture2d = new RawTexture(blackPixels, 1, 1, Engine.TEXTUREFORMAT_RGBA, scene, false);\n        this._dummyTexture3d = new RawTexture3D(blackPixels, 1, 1, 1, Engine.TEXTUREFORMAT_RGBA, scene, false);\n        // Setup the geometry buffer target formats\n        const textureTypesAndFormats = {};\n        textureTypesAndFormats[GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE] = { textureFormat: Constants.TEXTUREFORMAT_R, textureType: Constants.TEXTURETYPE_FLOAT };\n        textureTypesAndFormats[GeometryBufferRenderer.VELOCITY_LINEAR_TEXTURE_TYPE] = { textureFormat: Constants.TEXTUREFORMAT_RG, textureType: Constants.TEXTURETYPE_HALF_FLOAT };\n        textureTypesAndFormats[GeometryBufferRenderer.POSITION_TEXTURE_TYPE] = { textureFormat: Constants.TEXTUREFORMAT_RGBA, textureType: Constants.TEXTURETYPE_HALF_FLOAT };\n        textureTypesAndFormats[GeometryBufferRenderer.NORMAL_TEXTURE_TYPE] = { textureFormat: Constants.TEXTUREFORMAT_RGBA, textureType: Constants.TEXTURETYPE_HALF_FLOAT };\n        const geometryBufferRenderer = scene.enableGeometryBufferRenderer(undefined, Constants.TEXTUREFORMAT_DEPTH32_FLOAT, textureTypesAndFormats);\n        if (!geometryBufferRenderer) {\n            Logger.Error(\"Geometry buffer renderer is required for IBL shadows to work.\");\n            return;\n        }\n        this._geometryBufferRenderer = geometryBufferRenderer;\n        this._geometryBufferRenderer.enableScreenspaceDepth = true;\n        this._geometryBufferRenderer.enableVelocityLinear = true;\n        this._geometryBufferRenderer.enablePosition = true;\n        this._geometryBufferRenderer.enableNormal = true;\n        this._geometryBufferRenderer.generateNormalsInWorldSpace = true;\n        this.scene.enableIblCdfGenerator();\n        this.shadowOpacity = options.shadowOpacity || 0.8;\n        this._voxelRenderer = new _IblShadowsVoxelRenderer(this.scene, this, options ? options.resolutionExp : 6, options.triPlanarVoxelization !== undefined ? options.triPlanarVoxelization : true);\n        this._voxelTracingPass = new _IblShadowsVoxelTracingPass(this.scene, this);\n        this._spatialBlurPass = new _IblShadowsSpatialBlurPass(this.scene, this);\n        this._accumulationPass = new _IblShadowsAccumulationPass(this.scene, this);\n        this._accumulationPass.onReadyObservable.addOnce(() => {\n            this.onShadowTextureReadyObservable.notifyObservers();\n        });\n        this.sampleDirections = options.sampleDirections || 2;\n        this.voxelShadowOpacity = options.voxelShadowOpacity ?? 1.0;\n        this.envRotation = options.envRotation ?? 0.0;\n        this.shadowRenderSizeFactor = options.shadowRenderSizeFactor || 1.0;\n        this.ssShadowOpacity = options.ssShadowsEnabled === undefined || options.ssShadowsEnabled ? 1.0 : 0.0;\n        this.ssShadowDistanceScale = options.ssShadowDistanceScale || 1.25;\n        this.ssShadowSampleCount = options.ssShadowSampleCount || 16;\n        this.ssShadowStride = options.ssShadowStride || 8;\n        this.ssShadowThicknessScale = options.ssShadowThicknessScale || 1.0;\n        this.shadowRemanence = options.shadowRemanence ?? 0.75;\n        this._noiseTexture = new Texture(\"https://assets.babylonjs.com/textures/blue_noise/blue_noise_rgb.png\", this.scene, false, true, Constants.TEXTURE_NEAREST_SAMPLINGMODE);\n        scene.postProcessRenderPipelineManager.addPipeline(this);\n        this.scene.onActiveCameraChanged.add(this._listenForCameraChanges.bind(this));\n        this.scene.onBeforeRenderObservable.add(this._updateBeforeRender.bind(this));\n        this._listenForCameraChanges();\n        this.scene.getEngine().onResizeObservable.add(this._handleResize.bind(this));\n        // Assigning the shadow texture to the materials needs to be done after the RT's are created.\n        if (this.scene.iblCdfGenerator) {\n            this.scene.iblCdfGenerator.onGeneratedObservable.add(() => {\n                this._setPluginParameters();\n                this.onNewIblReadyObservable.notifyObservers();\n            });\n        }\n    }\n    _handleResize() {\n        this._voxelRenderer.resize();\n        this._voxelTracingPass.resize(this.shadowRenderSizeFactor);\n        this._spatialBlurPass.resize(this.shadowRenderSizeFactor);\n        this._accumulationPass.resize(this.shadowRenderSizeFactor);\n        this._setPluginParameters();\n    }\n    _getGBufferDebugPass() {\n        if (this._gbufferDebugPass) {\n            return this._gbufferDebugPass;\n        }\n        const isWebGPU = this.engine.isWebGPU;\n        const textureNames = [\"depthSampler\", \"normalSampler\", \"positionSampler\", \"velocitySampler\"];\n        const options = {\n            width: this.scene.getEngine().getRenderWidth(),\n            height: this.scene.getEngine().getRenderHeight(),\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n            engine: this.scene.getEngine(),\n            textureType: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n            textureFormat: Constants.TEXTUREFORMAT_RGBA,\n            uniforms: [\"sizeParams\"],\n            samplers: textureNames,\n            reusable: false,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializations: (useWebGPU, list) => {\n                if (useWebGPU) {\n                    list.push(import(\"../../ShadersWGSL/iblShadowGBufferDebug.fragment\"));\n                }\n                else {\n                    list.push(import(\"../../Shaders/iblShadowGBufferDebug.fragment\"));\n                }\n            },\n        };\n        this._gbufferDebugPass = new PostProcess(\"iblShadowGBufferDebug\", \"iblShadowGBufferDebug\", options);\n        if (this.engine.isWebGPU) {\n            this._gbufferDebugPass.samples = this.engine.currentSampleCount ?? 1;\n        }\n        this._gbufferDebugPass.autoClear = false;\n        this._gbufferDebugPass.onApplyObservable.add((effect) => {\n            const depthIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE);\n            effect.setTexture(\"depthSampler\", this._geometryBufferRenderer.getGBuffer().textures[depthIndex]);\n            const normalIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.NORMAL_TEXTURE_TYPE);\n            effect.setTexture(\"normalSampler\", this._geometryBufferRenderer.getGBuffer().textures[normalIndex]);\n            const positionIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);\n            effect.setTexture(\"positionSampler\", this._geometryBufferRenderer.getGBuffer().textures[positionIndex]);\n            const velocityIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_LINEAR_TEXTURE_TYPE);\n            effect.setTexture(\"velocitySampler\", this._geometryBufferRenderer.getGBuffer().textures[velocityIndex]);\n            effect.setVector4(\"sizeParams\", this._gBufferDebugSizeParams);\n            if (this.scene.activeCamera) {\n                effect.setFloat(\"maxDepth\", this.scene.activeCamera.maxZ);\n            }\n        });\n        return this._gbufferDebugPass;\n    }\n    _createDebugPasses() {\n        if (this.scene.iblCdfGenerator) {\n            this._debugPasses = [{ pass: this.scene.iblCdfGenerator.getDebugPassPP(), enabled: this.cdfDebugEnabled }];\n        }\n        else {\n            this._debugPasses = [];\n        }\n        this._debugPasses.push({ pass: this._voxelRenderer.getDebugPassPP(), enabled: this.voxelDebugEnabled }, { pass: this._voxelTracingPass.getDebugPassPP(), enabled: this.voxelTracingDebugEnabled }, { pass: this._spatialBlurPass.getDebugPassPP(), enabled: this.spatialBlurPassDebugEnabled }, { pass: this._accumulationPass.getDebugPassPP(), enabled: this.accumulationPassDebugEnabled }, { pass: this._getGBufferDebugPass(), enabled: this.gbufferDebugEnabled });\n        for (let i = 0; i < this._debugPasses.length; i++) {\n            if (!this._debugPasses[i].pass) {\n                continue;\n            }\n            this.addEffect(new PostProcessRenderEffect(this.scene.getEngine(), this._debugPasses[i].pass.name, () => {\n                return this._debugPasses[i].pass;\n            }, true));\n        }\n        const cameras = this.cameras.slice();\n        this.scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this.name, this.cameras);\n        this.scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this.name, cameras);\n        for (let i = 0; i < this._debugPasses.length; i++) {\n            if (!this._debugPasses[i].pass) {\n                continue;\n            }\n            if (this._debugPasses[i].enabled) {\n                this._enableEffect(this._debugPasses[i].pass.name, this.cameras);\n            }\n            else {\n                this._disableEffect(this._debugPasses[i].pass.name, this.cameras);\n            }\n        }\n    }\n    _disposeEffectPasses() {\n        this.scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this.name, this.cameras);\n        this._disposeDebugPasses();\n        this._reset();\n    }\n    _disposeDebugPasses() {\n        for (let i = 0; i < this._debugPasses.length; i++) {\n            this._disableEffect(this._debugPasses[i].pass.name, this.cameras);\n            this._debugPasses[i].pass.dispose();\n        }\n        this._debugPasses = [];\n    }\n    _updateDebugPasses() {\n        let count = 0;\n        if (this._gbufferDebugEnabled) {\n            count++;\n        }\n        if (this.cdfDebugEnabled) {\n            count++;\n        }\n        if (this.voxelDebugEnabled) {\n            count++;\n        }\n        if (this.voxelTracingDebugEnabled) {\n            count++;\n        }\n        if (this.spatialBlurPassDebugEnabled) {\n            count++;\n        }\n        if (this.accumulationPassDebugEnabled) {\n            count++;\n        }\n        const rows = Math.ceil(Math.sqrt(count));\n        const cols = Math.ceil(count / rows);\n        const width = 1.0 / cols;\n        const height = 1.0 / rows;\n        let x = 0;\n        let y = 0;\n        if (this.gbufferDebugEnabled) {\n            this._gBufferDebugSizeParams.set(x, y, cols, rows);\n            x -= width;\n            if (x <= -1) {\n                x = 0;\n                y -= height;\n            }\n        }\n        if (this.cdfDebugEnabled && this.scene.iblCdfGenerator) {\n            this.scene.iblCdfGenerator.setDebugDisplayParams(x, y, cols, rows);\n            x -= width;\n            if (x <= -1) {\n                x = 0;\n                y -= height;\n            }\n        }\n        if (this.voxelDebugEnabled) {\n            this._voxelRenderer.setDebugDisplayParams(x, y, cols, rows);\n            x -= width;\n            if (x <= -1) {\n                x = 0;\n                y -= height;\n            }\n        }\n        if (this.voxelTracingDebugEnabled) {\n            this._voxelTracingPass.setDebugDisplayParams(x, y, cols, rows);\n            x -= width;\n            if (x <= -1) {\n                x = 0;\n                y -= height;\n            }\n        }\n        if (this.spatialBlurPassDebugEnabled) {\n            this._spatialBlurPass.setDebugDisplayParams(x, y, cols, rows);\n            x -= width;\n            if (x <= -1) {\n                x = 0;\n                y -= height;\n            }\n        }\n        if (this.accumulationPassDebugEnabled) {\n            this._accumulationPass.setDebugDisplayParams(x, y, cols, rows);\n            x -= width;\n            if (x <= -1) {\n                x = 0;\n                y -= height;\n            }\n        }\n    }\n    /**\n     * Update the SS shadow max distance and thickness based on the voxel grid size and resolution.\n     * The max distance should be just a little larger than the world size of a single voxel.\n     */\n    _updateSsShadowParams() {\n        this._voxelTracingPass.sssMaxDist = (this._sssMaxDistScale * this.voxelGridSize) / (1 << this.resolutionExp);\n        this._voxelTracingPass.sssThickness = this._sssThicknessScale * 0.005 * this.voxelGridSize;\n    }\n    /**\n     * Apply the shadows to a material or array of materials. If no material is provided, all\n     * materials in the scene will be added.\n     * @param material Material that will be affected by the shadows. If not provided, all materials of the scene will be affected.\n     */\n    addShadowReceivingMaterial(material) {\n        if (material) {\n            if (Array.isArray(material)) {\n                for (const m of material) {\n                    this._addShadowSupportToMaterial(m);\n                }\n            }\n            else {\n                this._addShadowSupportToMaterial(material);\n            }\n        }\n        else {\n            for (const mat of this.scene.materials) {\n                this._addShadowSupportToMaterial(mat);\n            }\n        }\n    }\n    /**\n     * Remove a material from the list of materials that receive shadows. If no material\n     * is provided, all materials in the scene will be removed.\n     * @param material The material or array of materials that will no longer receive shadows\n     */\n    removeShadowReceivingMaterial(material) {\n        if (Array.isArray(material)) {\n            for (const m of material) {\n                const matIndex = this._materialsWithRenderPlugin.indexOf(m);\n                if (matIndex !== -1) {\n                    this._materialsWithRenderPlugin.splice(matIndex, 1);\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain\n                    const plugin = m.pluginManager?.getPlugin(IBLShadowsPluginMaterial.Name);\n                    plugin.isEnabled = false;\n                }\n            }\n        }\n        else {\n            const matIndex = this._materialsWithRenderPlugin.indexOf(material);\n            if (matIndex !== -1) {\n                this._materialsWithRenderPlugin.splice(matIndex, 1);\n                const plugin = material.pluginManager.getPlugin(IBLShadowsPluginMaterial.Name);\n                plugin.isEnabled = false;\n            }\n        }\n    }\n    /**\n     * Clear the list of materials that receive shadows. This will remove all materials from the list\n     */\n    clearShadowReceivingMaterials() {\n        for (const mat of this._materialsWithRenderPlugin) {\n            const plugin = mat.pluginManager?.getPlugin(IBLShadowsPluginMaterial.Name);\n            if (plugin) {\n                plugin.isEnabled = false;\n            }\n        }\n        this._materialsWithRenderPlugin.length = 0;\n    }\n    _addShadowSupportToMaterial(material) {\n        if (!(material instanceof PBRBaseMaterial) && !(material instanceof StandardMaterial) && !(material instanceof OpenPBRMaterial)) {\n            return;\n        }\n        let plugin = material.pluginManager?.getPlugin(IBLShadowsPluginMaterial.Name);\n        if (!plugin) {\n            plugin = new IBLShadowsPluginMaterial(material);\n        }\n        if (this._materialsWithRenderPlugin.indexOf(material) !== -1) {\n            return;\n        }\n        if (this._enabled) {\n            plugin.iblShadowsTexture = this._getAccumulatedTexture().getInternalTexture();\n            plugin.shadowOpacity = this.shadowOpacity;\n        }\n        plugin.isEnabled = this._enabled;\n        plugin.isColored = this._coloredShadows;\n        this._materialsWithRenderPlugin.push(material);\n    }\n    _setPluginParameters() {\n        if (!this._enabled) {\n            return;\n        }\n        for (const mat of this._materialsWithRenderPlugin) {\n            if (mat.pluginManager) {\n                const plugin = mat.pluginManager.getPlugin(IBLShadowsPluginMaterial.Name);\n                plugin.iblShadowsTexture = this._getAccumulatedTexture().getInternalTexture();\n                plugin.shadowOpacity = this.shadowOpacity;\n                plugin.isColored = this._coloredShadows;\n            }\n        }\n    }\n    _updateBeforeRender() {\n        this._updateDebugPasses();\n    }\n    _listenForCameraChanges() {\n        // We want to listen for camera changes and change settings while the camera is moving.\n        this.scene.activeCamera?.onViewMatrixChangedObservable.add(() => {\n            this._accumulationPass.isMoving = true;\n        });\n    }\n    /**\n     * Checks if the IBL shadow pipeline is ready to render shadows\n     * @returns true if the IBL shadow pipeline is ready to render the shadows\n     */\n    isReady() {\n        return (this._noiseTexture.isReady() &&\n            this._voxelRenderer.isReady() &&\n            this.scene.iblCdfGenerator &&\n            this.scene.iblCdfGenerator.isReady() &&\n            (!this._voxelTracingPass || this._voxelTracingPass.isReady()) &&\n            (!this._spatialBlurPass || this._spatialBlurPass.isReady()) &&\n            (!this._accumulationPass || this._accumulationPass.isReady()));\n    }\n    /**\n     * Get the class name\n     * @returns \"IBLShadowsRenderPipeline\"\n     */\n    getClassName() {\n        return \"IBLShadowsRenderPipeline\";\n    }\n    /**\n     * Disposes the IBL shadow pipeline and associated resources\n     */\n    dispose() {\n        const materials = this._materialsWithRenderPlugin.splice(0);\n        for (const mat of materials) {\n            this.removeShadowReceivingMaterial(mat);\n        }\n        this._disposeEffectPasses();\n        this._noiseTexture.dispose();\n        this._voxelRenderer.dispose();\n        this._voxelTracingPass.dispose();\n        this._spatialBlurPass.dispose();\n        this._accumulationPass.dispose();\n        this._dummyTexture2d.dispose();\n        this._dummyTexture3d.dispose();\n        this.onNewIblReadyObservable.clear();\n        this.onShadowTextureReadyObservable.clear();\n        this.onVoxelizationCompleteObservable.clear();\n        super.dispose();\n    }\n}\n//# sourceMappingURL=iblShadowsRenderPipeline.js.map"],"names":["_IblShadowsVoxelRenderer","getVoxelGrid","this","_triPlanarVoxelization","_voxelGridRT","_voxelGridZaxis","getDebugPassPP","_voxelDebugPass","_createDebugPass","triPlanarVoxelization","enabled","_disposeVoxelTextures","_createTextures","setWorldScaleMatrix","matrix","_invWorldScaleMatrix","isVoxelizationInProgress","_voxelizationInProgress","voxelResolutionExp","_voxelResolutionExp","resolutionExp","Math","round","min","max","_voxelResolution","pow","voxelDebugAxis","axis","_voxelDebugAxis","setDebugDisplayParams","x","y","widthScale","heightScale","_debugSizeParams","set","setDebugMipNumber","mipNum","_debugMipNumber","debugPassName","_debugPassName","voxelDebugEnabled","_voxelDebugEnabled","_voxelSlabDebugRT","RenderTargetTexture","width","_engine","getRenderWidth","height","getRenderHeight","_scene","generateDepthBuffer","generateMipMaps","type","Constants","TEXTURETYPE_UNSIGNED_BYTE","format","TEXTUREFORMAT_RGBA","samplingMode","TEXTURE_NEAREST_SAMPLINGMODE","noPrePassRenderer","_removeVoxelRTs","_addRTsForRender","_includedMeshes","_setDebugBindingsBound","_setDebugBindings","bind","onBeforeRenderObservable","add","removeCallback","isWebGPU","debugOptions","textureFormat","textureType","uniforms","samplers","engine","reusable","shaderLanguage","extraInitializations","useWebGPU","list","_isVoxelGrid3D","push","import","PostProcess","onApplyObservable","effect","setTexture","_voxelGridXaxis","_voxelGridYaxis","setVector4","setFloat","constructor","scene","iblShadowsRenderPipeline","_voxelMrtsXaxis","_voxelMrtsYaxis","_voxelMrtsZaxis","onVoxelizationCompleteObservable","Observable","_renderTargets","Matrix","Identity","_mipArray","Vector4","getEngine","getCaps","drawBuffersExtension","Logger","Error","_maxDrawBuffers","maxDrawBuffers","_copyMipEffectRenderer","EffectRenderer","_copyMipEffectWrapper","EffectWrapper","fragmentShader","useShaderStore","uniformNames","samplerNames","extraInitializationsAsync","async","_generateMipMaps","iterations","ceil","log2","i","_generateMipMap","lodLevel","mipTarget","render","_copyMipMaps","_copyMipMap","voxelGrid","rt","renderTarget","_rtWrapper","saveStates","bindSize","getSize","layer","bindFramebuffer","applyEffectWrapper","setInt","draw","unBindFramebuffer","restoreStates","_computeNumberOfSlabs","size","layers","undefined","depth","voxelAxisOptions","TEXTUREFORMAT_R","numSlabs","voxelCombinedOptions","TEXTURE_NEAREST_NEAREST_MIPNEAREST","_createVoxelMRTs","ProceduralTexture","proceduralTextures","splice","indexOf","autoClear","wrapU","Texture","CLAMP_ADDRESSMODE","wrapV","generateVoxelMipOptions","Array","mipIdx","length","mipDim","mipSize","_createVoxelMaterials","name","voxelRT","mrtArray","targetTypes","fill","TEXTURE_3D","TEXTURE_2D_ARRAY","mrtIndex","layerIndices","map","value","index","textureNames","mrt","MultiRenderTarget","types","samplingModes","TEXTURE_TRILINEAR_SAMPLINGMODE","formats","faceIndex","layerIndex","layerCounts","generateStencilBuffer","clearColor","Color4","setInternalTexture","getInternalTexture","_stopVoxelization","dispose","mip","_voxelMaterial","_voxelSlabDebugMaterial","ShaderMaterial","defines","Promise","all","cullBackFaces","backFaceCulling","depthFunction","Engine","ALWAYS","setMatrix","activeCamera","getProjectionMatrix","getViewMatrix","isReady","allReady","mipReady","rts","rtIdx","findIndex","customRenderTargets","updateVoxelGrid","includedMeshes","_renderVoxelGridBound","_renderVoxelGrid","onAfterRenderObservable","rttReady","isReadyForRendering","whenCompiledAsync","then","notifyObservers","mrts","shaderType","continuousRender","slabSize","voxelMaterial","renderList","nearPlane","farPlane","stepSize","cameraPosition","Vector3","targetPosition","upDirection","LookAtLH","mesh","subMeshes","setMaterialForRendering","meshes","getChildMeshes","childMesh","concat","resize","_IblShadowsVoxelTracingPass","voxelShadowOpacity","_voxelShadowOpacity","ssShadowOpacity","_ssShadowOpacity","sssSamples","_sssSamples","sssStride","_sssStride","sssMaxDist","_sssMaxDist","sssThickness","_sssThickness","voxelNormalBias","_voxelNormalBias","voxelDirectionBias","_voxelDirectionBias","sampleDirections","_sampleDirections","envRotation","_envRotation","getOutputTexture","_outputTexture","_debugPassPP","coloredShadows","_coloredShadows","_cameraInvView","_cameraInvProj","_frameId","_shadowParameters","_sssParameters","_opacityParameters","_voxelBiasParameters","debugEnabled","_debugVoxelMarchEnabled","_renderWhenGBufferReady","_renderPipeline","_createDefines","textureOptions","refreshRate","_setBindings","_render","addOnce","geometryBufferRenderer","getGBuffer","useRightHandedSystem","camera","invertToRef","rotation","environmentTexture","rotationY","PI","_getVoxelGridTexture","highestMip","floor","_getNoiseTexture","cdfGenerator","iblCdfGenerator","Warn","getIcdfTexture","depthIndex","getTextureIndex","GeometryBufferRenderer","SCREENSPACE_DEPTH_TEXTURE_TYPE","textures","wnormalIndex","NORMAL_TEXTURE_TYPE","getEffect","scaleFactor","newSize","_IblShadowsSpatialBlurPass","setWorldScale","scale","_worldScale","_blurParameters","_getVoxelTracingTexture","_IblShadowsAccumulationPass","remanence","_remanence","reset","_reset","isMoving","_isMoving","_accumulationParams","onReadyObservable","outputTextureOptions","TEXTURETYPE_HALF_FLOAT","onGeneratedObservable","_setOutputTextureBindings","accumulationOptions","_oldAccumulationCopy","onBeforeGenerationObservable","_setAccumulationCopyBindings","localPositionOptions","_oldPositionCopy","_updatePositionCopy","voxelGridSize","_getSpatialBlurTexture","_dummyTexture2d","velocityIndex","VELOCITY_LINEAR_TEXTURE_TYPE","wPositionIndex","POSITION_TEXTURE_TYPE","_disposeTextures","clear","RawTexture3D","_texture","data","invertY","TRILINEAR_SAMPLINGMODE","creationFlags","super","createRawTexture3D","is3D","update","_getEngine","updateRawTexture3D","MaterialIBLShadowsRenderDefines","MaterialDefines","arguments","RENDER_WITH_IBL_SHADOWS","COLORED_IBL_SHADOWS","IBLShadowsPluginMaterial","MaterialPluginBase","isColored","_isColored","_markAllSubMeshesAsTexturesDirty","_enable","_isEnabled","_internalMarkAllSubMeshesAsTexturesDirty","isCompatible","material","Name","shadowOpacity","isEnabled","_dirtyCallbacks","MATERIAL_TextureDirtyFlag","prepareDefines","getClassName","getUniforms","ubo","fragment","getSamplers","bindForSubMesh","uniformBuffer","bindTexture","iblShadowsTexture","updateFloat2","_material","getScene","updateFloat","getCustomCode","frag","CUSTOM_FRAGMENT_DEFINITIONS","PBRBaseMaterial","OpenPBRMaterial","__decorate","serialize","prototype","expandToProperty","RegisterClass","IblShadowsRenderPipeline","PostProcessRenderPipeline","resetAccumulation","_accumulationPass","_shadowOpacity","_setPluginParameters","_voxelTracingPass","shadowRenderSizeFactor","_renderSizeFactor","_spatialBlurPass","ssShadowSampleCount","ssShadowStride","ssShadowDistanceScale","_sssMaxDistScale","_updateSsShadowParams","ssShadowThicknessScale","_sssThicknessScale","tex","_voxelRenderer","_dummyTexture3d","_noiseTexture","_getAccumulatedTexture","gbufferDebugEnabled","_gbufferDebugEnabled","allowDebugPasses","_enableEffect","_getGBufferDebugPass","cameras","_disableEffect","cdfDebugEnabled","axisNum","voxelDebugDisplayMip","voxelTracingDebugEnabled","spatialBlurPassDebugEnabled","accumulationPassDebugEnabled","addShadowCastingMesh","isArray","m","_shadowCastingMeshes","removeShadowCastingMesh","clearShadowCastingMeshes","newResolution","shadowRemanence","_allowDebugPasses","_createDebugPasses","_disposeDebugPasses","IsSupported","EngineStore","LastCreatedEngine","_features","supportIBLShadows","toggleShadow","_enabled","mat","_materialsWithRenderPlugin","pluginManager","getPlugin","updateVoxelization","updateSceneBounds","bounds","Number","MAX_VALUE","localBounds","getHierarchyBoundingVectors","Minimize","Maximize","subtract","z","isFinite","halfSize","centre","multiplyByFloats","invWorldScaleMatrix","Compose","Quaternion","multiplyToRef","options","_debugPasses","onShadowTextureReadyObservable","onNewIblReadyObservable","_gBufferDebugSizeParams","_cameras","blackPixels","Uint8Array","RawTexture","textureTypesAndFormats","TEXTURETYPE_FLOAT","TEXTUREFORMAT_RG","enableGeometryBufferRenderer","TEXTUREFORMAT_DEPTH32_FLOAT","_geometryBufferRenderer","enableScreenspaceDepth","enableVelocityLinear","enablePosition","enableNormal","generateNormalsInWorldSpace","enableIblCdfGenerator","ssShadowsEnabled","postProcessRenderPipelineManager","addPipeline","onActiveCameraChanged","_listenForCameraChanges","_updateBeforeRender","onResizeObservable","_handleResize","_gbufferDebugPass","samples","currentSampleCount","normalIndex","positionIndex","maxZ","pass","addEffect","PostProcessRenderEffect","slice","detachCamerasFromRenderPipeline","attachCamerasToRenderPipeline","_disposeEffectPasses","_updateDebugPasses","count","rows","sqrt","cols","addShadowReceivingMaterial","_addShadowSupportToMaterial","materials","removeShadowReceivingMaterial","matIndex","plugin","clearShadowReceivingMaterials","StandardMaterial","onViewMatrixChangedObservable"],"mappings":"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"}