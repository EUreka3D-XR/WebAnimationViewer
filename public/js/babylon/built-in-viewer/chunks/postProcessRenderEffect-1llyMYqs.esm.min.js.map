{"version":3,"file":"postProcessRenderEffect-1llyMYqs.esm.min.js","sources":["../../../../../dev/core/dist/PostProcesses/RenderPipeline/postProcessRenderPipeline.js","../../../../../dev/core/dist/PostProcesses/RenderPipeline/postProcessRenderEffect.js"],"sourcesContent":["import { __decorate } from \"tslib\";\nimport { Tools } from \"../../Misc/tools\";\nimport { serialize } from \"../../Misc/decorators\";\nimport { UniqueIdGenerator } from \"core/Misc/uniqueIdGenerator\";\n/**\n * PostProcessRenderPipeline\n * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\n */\nexport class PostProcessRenderPipeline {\n    /**\n     * Gets pipeline name\n     */\n    get name() {\n        return this._name;\n    }\n    /** Gets the list of attached cameras */\n    get cameras() {\n        return this._cameras;\n    }\n    /**\n     * Gets the active engine\n     */\n    get engine() {\n        return this._engine;\n    }\n    /**\n     * Initializes a PostProcessRenderPipeline\n     * @param _engine engine to add the pipeline to\n     * @param name name of the pipeline\n     */\n    constructor(_engine, name) {\n        this._engine = _engine;\n        /**\n         * Gets the unique id of the post process rendering pipeline\n         */\n        this.uniqueId = UniqueIdGenerator.UniqueId;\n        this._name = name;\n        this._renderEffects = {};\n        this._renderEffectsForIsolatedPass = new Array();\n        this._cameras = [];\n    }\n    /**\n     * Gets the class name\n     * @returns \"PostProcessRenderPipeline\"\n     */\n    getClassName() {\n        return \"PostProcessRenderPipeline\";\n    }\n    /**\n     * If all the render effects in the pipeline are supported\n     */\n    get isSupported() {\n        for (const renderEffectName in this._renderEffects) {\n            if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {\n                if (!this._renderEffects[renderEffectName].isSupported) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Adds an effect to the pipeline\n     * @param renderEffect the effect to add\n     */\n    addEffect(renderEffect) {\n        this._renderEffects[renderEffect._name] = renderEffect;\n    }\n    // private\n    /** @internal */\n    _rebuild() { }\n    /**\n     * @internal\n     */\n    _enableEffect(renderEffectName, cameras) {\n        const renderEffects = this._renderEffects[renderEffectName];\n        if (!renderEffects) {\n            return;\n        }\n        renderEffects._enable(Tools.MakeArray(cameras || this._cameras));\n    }\n    /**\n     * @internal\n     */\n    _disableEffect(renderEffectName, cameras) {\n        const renderEffects = this._renderEffects[renderEffectName];\n        if (!renderEffects) {\n            return;\n        }\n        renderEffects._disable(Tools.MakeArray(cameras || this._cameras));\n    }\n    /**\n     * @internal\n     */\n    _attachCameras(cameras, unique) {\n        const cams = Tools.MakeArray(cameras || this._cameras);\n        if (!cams) {\n            return;\n        }\n        const indicesToDelete = [];\n        let i;\n        for (i = 0; i < cams.length; i++) {\n            const camera = cams[i];\n            if (!camera) {\n                continue;\n            }\n            if (this._cameras.indexOf(camera) === -1) {\n                this._cameras.push(camera);\n            }\n            else if (unique) {\n                indicesToDelete.push(i);\n            }\n        }\n        for (i = 0; i < indicesToDelete.length; i++) {\n            cams.splice(indicesToDelete[i], 1);\n        }\n        for (const renderEffectName in this._renderEffects) {\n            if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {\n                this._renderEffects[renderEffectName]._attachCameras(cams);\n            }\n        }\n    }\n    /**\n     * @internal\n     */\n    _detachCameras(cameras) {\n        const cams = Tools.MakeArray(cameras || this._cameras);\n        if (!cams) {\n            return;\n        }\n        for (const renderEffectName in this._renderEffects) {\n            if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {\n                this._renderEffects[renderEffectName]._detachCameras(cams);\n            }\n        }\n        for (let i = 0; i < cams.length; i++) {\n            this._cameras.splice(this._cameras.indexOf(cams[i]), 1);\n        }\n    }\n    /** @internal */\n    _update() {\n        for (const renderEffectName in this._renderEffects) {\n            if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {\n                this._renderEffects[renderEffectName]._update();\n            }\n        }\n        for (let i = 0; i < this._cameras.length; i++) {\n            if (!this._cameras[i]) {\n                continue;\n            }\n            const cameraName = this._cameras[i].name;\n            if (this._renderEffectsForIsolatedPass[cameraName]) {\n                this._renderEffectsForIsolatedPass[cameraName]._update();\n            }\n        }\n    }\n    /** @internal */\n    _reset() {\n        this._renderEffects = {};\n        this._renderEffectsForIsolatedPass = new Array();\n    }\n    _enableMSAAOnFirstPostProcess(sampleCount) {\n        if (!this._engine._features.supportMSAA) {\n            return false;\n        }\n        // Set samples of the very first post process to 4 to enable native anti-aliasing in browsers that support webGL 2.0 (See: https://github.com/BabylonJS/Babylon.js/issues/3754)\n        const effectKeys = Object.keys(this._renderEffects);\n        if (effectKeys.length > 0) {\n            const postProcesses = this._renderEffects[effectKeys[0]].getPostProcesses();\n            if (postProcesses) {\n                postProcesses[0].samples = sampleCount;\n            }\n        }\n        return true;\n    }\n    /**\n     * Ensures that all post processes in the pipeline are the correct size according to the\n     * the viewport's required size\n     */\n    _adaptPostProcessesToViewPort() {\n        const effectKeys = Object.keys(this._renderEffects);\n        for (const effectKey of effectKeys) {\n            const postProcesses = this._renderEffects[effectKey].getPostProcesses();\n            if (postProcesses) {\n                for (const postProcess of postProcesses) {\n                    postProcess.adaptScaleToCurrentViewport = true;\n                }\n            }\n        }\n    }\n    /**\n     * Sets the required values to the prepass renderer.\n     * @param prePassRenderer defines the prepass renderer to setup.\n     * @returns true if the pre pass is needed.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setPrePassRenderer(prePassRenderer) {\n        // Do Nothing by default\n        return false;\n    }\n    /**\n     * Disposes of the pipeline\n     */\n    dispose() {\n        // Must be implemented by children\n    }\n}\n__decorate([\n    serialize()\n], PostProcessRenderPipeline.prototype, \"_name\", void 0);\n//# sourceMappingURL=postProcessRenderPipeline.js.map","import { Tools } from \"../../Misc/tools\";\n/**\n * This represents a set of one or more post processes in Babylon.\n * A post process can be used to apply a shader to a texture after it is rendered.\n * @example https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\n */\nexport class PostProcessRenderEffect {\n    /**\n     * Instantiates a post process render effect.\n     * A post process can be used to apply a shader to a texture after it is rendered.\n     * @param engine The engine the effect is tied to\n     * @param name The name of the effect\n     * @param getPostProcesses A function that returns a set of post processes which the effect will run in order to be run.\n     * @param singleInstance False if this post process can be run on multiple cameras. (default: true)\n     */\n    constructor(engine, name, getPostProcesses, singleInstance = true) {\n        this._name = name;\n        this._singleInstance = singleInstance;\n        this._getPostProcesses = getPostProcesses;\n        this._cameras = {};\n        this._indicesForCamera = {};\n        this._postProcesses = {};\n    }\n    /**\n     * Checks if all the post processes in the effect are supported.\n     */\n    get isSupported() {\n        for (const index in this._postProcesses) {\n            if (Object.prototype.hasOwnProperty.call(this._postProcesses, index)) {\n                const pps = this._postProcesses[index];\n                for (let ppIndex = 0; ppIndex < pps.length; ppIndex++) {\n                    if (!pps[ppIndex].isSupported) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Updates the current state of the effect\n     * @internal\n     */\n    _update() { }\n    /**\n     * Attaches the effect on cameras\n     * @param cameras The camera to attach to.\n     * @internal\n     */\n    _attachCameras(cameras) {\n        let cameraKey;\n        const cams = Tools.MakeArray(cameras || this._cameras);\n        if (!cams) {\n            return;\n        }\n        for (let i = 0; i < cams.length; i++) {\n            const camera = cams[i];\n            if (!camera) {\n                continue;\n            }\n            const cameraName = camera.name;\n            if (this._singleInstance) {\n                cameraKey = 0;\n            }\n            else {\n                cameraKey = cameraName;\n            }\n            if (!this._postProcesses[cameraKey]) {\n                const postProcess = this._getPostProcesses();\n                if (postProcess) {\n                    this._postProcesses[cameraKey] = Array.isArray(postProcess) ? postProcess : [postProcess];\n                }\n            }\n            if (!this._indicesForCamera[cameraName]) {\n                this._indicesForCamera[cameraName] = [];\n            }\n            const pps = this._postProcesses[cameraKey];\n            for (const postProcess of pps) {\n                const index = camera.attachPostProcess(postProcess);\n                this._indicesForCamera[cameraName].push(index);\n            }\n            if (!this._cameras[cameraName]) {\n                this._cameras[cameraName] = camera;\n            }\n        }\n    }\n    /**\n     * Detaches the effect on cameras\n     * @param cameras The camera to detach from.\n     * @internal\n     */\n    _detachCameras(cameras) {\n        const cams = Tools.MakeArray(cameras || this._cameras);\n        if (!cams) {\n            return;\n        }\n        for (let i = 0; i < cams.length; i++) {\n            const camera = cams[i];\n            const cameraName = camera.name;\n            const postProcesses = this._postProcesses[this._singleInstance ? 0 : cameraName];\n            if (postProcesses) {\n                for (const postProcess of postProcesses) {\n                    camera.detachPostProcess(postProcess);\n                }\n            }\n            if (this._cameras[cameraName]) {\n                this._cameras[cameraName] = null;\n            }\n            delete this._indicesForCamera[cameraName];\n        }\n    }\n    /**\n     * Enables the effect on given cameras\n     * @param cameras The camera to enable.\n     * @internal\n     */\n    _enable(cameras) {\n        const cams = Tools.MakeArray(cameras || this._cameras);\n        if (!cams) {\n            return;\n        }\n        for (let i = 0; i < cams.length; i++) {\n            const camera = cams[i];\n            const cameraName = camera.name;\n            const cameraKey = this._singleInstance ? 0 : cameraName;\n            for (let j = 0; j < this._indicesForCamera[cameraName].length; j++) {\n                const index = this._indicesForCamera[cameraName][j];\n                const postProcess = camera._postProcesses[index];\n                if (postProcess === undefined || postProcess === null) {\n                    cams[i].attachPostProcess(this._postProcesses[cameraKey][j], index);\n                }\n            }\n        }\n    }\n    /**\n     * Disables the effect on the given cameras\n     * @param cameras The camera to disable.\n     * @internal\n     */\n    _disable(cameras) {\n        const cams = Tools.MakeArray(cameras || this._cameras);\n        if (!cams) {\n            return;\n        }\n        for (let i = 0; i < cams.length; i++) {\n            const camera = cams[i];\n            const cameraName = camera.name;\n            const pps = this._postProcesses[this._singleInstance ? 0 : cameraName];\n            for (const postProcess of pps) {\n                camera.detachPostProcess(postProcess);\n            }\n        }\n    }\n    /**\n     * Gets a list of the post processes contained in the effect.\n     * @param camera The camera to get the post processes on.\n     * @returns The list of the post processes in the effect.\n     */\n    getPostProcesses(camera) {\n        if (this._singleInstance) {\n            return this._postProcesses[0];\n        }\n        else {\n            if (!camera) {\n                return null;\n            }\n            return this._postProcesses[camera.name];\n        }\n    }\n}\n//# sourceMappingURL=postProcessRenderEffect.js.map"],"names":["PostProcessRenderPipeline","name","this","_name","cameras","_cameras","engine","_engine","constructor","uniqueId","UniqueIdGenerator","UniqueId","_renderEffects","_renderEffectsForIsolatedPass","Array","getClassName","isSupported","renderEffectName","Object","prototype","hasOwnProperty","call","addEffect","renderEffect","_rebuild","_enableEffect","renderEffects","_enable","Tools","MakeArray","_disableEffect","_disable","_attachCameras","unique","cams","indicesToDelete","i","length","camera","indexOf","push","splice","_detachCameras","_update","cameraName","_reset","_enableMSAAOnFirstPostProcess","sampleCount","_features","supportMSAA","effectKeys","keys","postProcesses","getPostProcesses","samples","_adaptPostProcessesToViewPort","effectKey","postProcess","adaptScaleToCurrentViewport","setPrePassRenderer","prePassRenderer","dispose","__decorate","serialize","PostProcessRenderEffect","singleInstance","_singleInstance","_getPostProcesses","_indicesForCamera","_postProcesses","index","pps","ppIndex","cameraKey","isArray","attachPostProcess","detachPostProcess","j"],"mappings":"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"}