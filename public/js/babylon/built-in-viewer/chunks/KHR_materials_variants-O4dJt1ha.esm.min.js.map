{"version":3,"file":"KHR_materials_variants-O4dJt1ha.esm.min.js","sources":["../../../../../dev/loaders/dist/glTF/2.0/Extensions/KHR_materials_variants.js"],"sourcesContent":["import { GLTFLoader, ArrayItem } from \"../glTFLoader\";\nimport { Mesh } from \"core/Meshes/mesh\";\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\nconst NAME = \"KHR_materials_variants\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_variants/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_materials_variants {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME) && !this._loader.parent.skipMaterials;\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n    }\n    /**\n     * Gets the list of available variant names for this asset.\n     * @param rootNode The glTF root node\n     * @returns the list of all the variant names for this model\n     */\n    static GetAvailableVariants(rootNode) {\n        const extensionMetadata = this._GetExtensionMetadata(rootNode);\n        if (!extensionMetadata) {\n            return [];\n        }\n        return Object.keys(extensionMetadata.variants);\n    }\n    /**\n     * Gets the list of available variant names for this asset.\n     * @param rootNode The glTF root node\n     * @returns the list of all the variant names for this model\n     */\n    getAvailableVariants(rootNode) {\n        return KHR_materials_variants.GetAvailableVariants(rootNode);\n    }\n    /**\n     * Select a variant given a variant name or a list of variant names.\n     * @param rootNode The glTF root node\n     * @param variantName The variant name(s) to select.\n     */\n    static SelectVariant(rootNode, variantName) {\n        const extensionMetadata = this._GetExtensionMetadata(rootNode);\n        if (!extensionMetadata) {\n            throw new Error(`Cannot select variant on a glTF mesh that does not have the ${NAME} extension`);\n        }\n        const select = (variantName) => {\n            const entries = extensionMetadata.variants[variantName];\n            if (entries) {\n                for (const entry of entries) {\n                    entry.mesh.material = entry.material;\n                }\n            }\n        };\n        if (variantName instanceof Array) {\n            for (const name of variantName) {\n                select(name);\n            }\n        }\n        else {\n            select(variantName);\n        }\n        extensionMetadata.lastSelected = variantName;\n    }\n    /**\n     * Select a variant given a variant name or a list of variant names.\n     * @param rootNode The glTF root node\n     * @param variantName The variant name(s) to select.\n     */\n    selectVariant(rootNode, variantName) {\n        KHR_materials_variants.SelectVariant(rootNode, variantName);\n    }\n    /**\n     * Reset back to the original before selecting a variant.\n     * @param rootNode The glTF root node\n     */\n    static Reset(rootNode) {\n        const extensionMetadata = this._GetExtensionMetadata(rootNode);\n        if (!extensionMetadata) {\n            throw new Error(`Cannot reset on a glTF mesh that does not have the ${NAME} extension`);\n        }\n        for (const entry of extensionMetadata.original) {\n            entry.mesh.material = entry.material;\n        }\n        extensionMetadata.lastSelected = null;\n    }\n    /**\n     * Reset back to the original before selecting a variant.\n     * @param rootNode The glTF root node\n     */\n    reset(rootNode) {\n        KHR_materials_variants.Reset(rootNode);\n    }\n    /**\n     * Gets the last selected variant name(s) or null if original.\n     * @param rootNode The glTF root node\n     * @returns The selected variant name(s).\n     */\n    static GetLastSelectedVariant(rootNode) {\n        const extensionMetadata = this._GetExtensionMetadata(rootNode);\n        if (!extensionMetadata) {\n            throw new Error(`Cannot get the last selected variant on a glTF mesh that does not have the ${NAME} extension`);\n        }\n        return extensionMetadata.lastSelected;\n    }\n    /**\n     * Gets the last selected variant name(s) or null if original.\n     * @param rootNode The glTF root node\n     * @returns The selected variant name(s).\n     */\n    getLastSelectedVariant(rootNode) {\n        return KHR_materials_variants.GetLastSelectedVariant(rootNode);\n    }\n    static _GetExtensionMetadata(rootNode) {\n        return rootNode?._internalMetadata?.gltf?.[NAME] || null;\n    }\n    /** @internal */\n    onLoading() {\n        const extensions = this._loader.gltf.extensions;\n        if (extensions && extensions[this.name]) {\n            const extension = extensions[this.name];\n            this._variants = extension.variants;\n        }\n    }\n    /** @internal */\n    onReady() {\n        const rootNode = this._loader.rootBabylonMesh;\n        if (rootNode) {\n            const options = this._loader.parent.extensionOptions[NAME];\n            if (options?.defaultVariant) {\n                KHR_materials_variants.SelectVariant(rootNode, options.defaultVariant);\n            }\n            options?.onLoaded?.({\n                get variants() {\n                    return KHR_materials_variants.GetAvailableVariants(rootNode);\n                },\n                get selectedVariant() {\n                    const lastSelectedVariant = KHR_materials_variants.GetLastSelectedVariant(rootNode);\n                    if (!lastSelectedVariant) {\n                        return KHR_materials_variants.GetAvailableVariants(rootNode)[0];\n                    }\n                    if (Array.isArray(lastSelectedVariant)) {\n                        return lastSelectedVariant[0];\n                    }\n                    return lastSelectedVariant;\n                },\n                set selectedVariant(variantName) {\n                    KHR_materials_variants.SelectVariant(rootNode, variantName);\n                },\n            });\n        }\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    _loadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign) {\n        return GLTFLoader.LoadExtensionAsync(context, primitive, this.name, async (extensionContext, extension) => {\n            const promises = new Array();\n            promises.push(this._loader._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, (babylonMesh) => {\n                assign(babylonMesh);\n                if (babylonMesh instanceof Mesh) {\n                    const babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);\n                    const root = this._loader.rootBabylonMesh;\n                    const metadata = root ? (root._internalMetadata = root._internalMetadata || {}) : {};\n                    const gltf = (metadata.gltf = metadata.gltf || {});\n                    const extensionMetadata = (gltf[NAME] = gltf[NAME] || { lastSelected: null, original: [], variants: {} });\n                    // Store the original material.\n                    extensionMetadata.original.push({ mesh: babylonMesh, material: babylonMesh.material });\n                    // For each mapping, look at the variants and make a new entry for them.\n                    for (let mappingIndex = 0; mappingIndex < extension.mappings.length; ++mappingIndex) {\n                        const mapping = extension.mappings[mappingIndex];\n                        const material = ArrayItem.Get(`${extensionContext}/mappings/${mappingIndex}/material`, this._loader.gltf.materials, mapping.material);\n                        promises.push(this._loader._loadMaterialAsync(`#/materials/${mapping.material}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {\n                            for (let mappingVariantIndex = 0; mappingVariantIndex < mapping.variants.length; ++mappingVariantIndex) {\n                                const variantIndex = mapping.variants[mappingVariantIndex];\n                                const variant = ArrayItem.Get(`/extensions/${NAME}/variants/${variantIndex}`, this._variants, variantIndex);\n                                extensionMetadata.variants[variant.name] = extensionMetadata.variants[variant.name] || [];\n                                extensionMetadata.variants[variant.name].push({\n                                    mesh: babylonMesh,\n                                    material: babylonMaterial,\n                                });\n                                // Replace the target when original mesh is cloned\n                                babylonMesh.onClonedObservable.add((newOne) => {\n                                    const newMesh = newOne;\n                                    let metadata = null;\n                                    let newRoot = newMesh;\n                                    // Find root to get medata\n                                    do {\n                                        newRoot = newRoot.parent;\n                                        if (!newRoot) {\n                                            return;\n                                        }\n                                        metadata = KHR_materials_variants._GetExtensionMetadata(newRoot);\n                                    } while (metadata === null);\n                                    // Need to clone the metadata on the root (first time only)\n                                    if (root && metadata === KHR_materials_variants._GetExtensionMetadata(root)) {\n                                        // Copy main metadata\n                                        newRoot._internalMetadata = {};\n                                        for (const key in root._internalMetadata) {\n                                            newRoot._internalMetadata[key] = root._internalMetadata[key];\n                                        }\n                                        // Copy the gltf metadata\n                                        newRoot._internalMetadata.gltf = [];\n                                        for (const key in root._internalMetadata.gltf) {\n                                            newRoot._internalMetadata.gltf[key] = root._internalMetadata.gltf[key];\n                                        }\n                                        // Duplicate the extension specific metadata\n                                        newRoot._internalMetadata.gltf[NAME] = { lastSelected: null, original: [], variants: {} };\n                                        for (const original of metadata.original) {\n                                            newRoot._internalMetadata.gltf[NAME].original.push({\n                                                mesh: original.mesh,\n                                                material: original.material,\n                                            });\n                                        }\n                                        for (const key in metadata.variants) {\n                                            if (Object.prototype.hasOwnProperty.call(metadata.variants, key)) {\n                                                newRoot._internalMetadata.gltf[NAME].variants[key] = [];\n                                                for (const variantEntry of metadata.variants[key]) {\n                                                    newRoot._internalMetadata.gltf[NAME].variants[key].push({\n                                                        mesh: variantEntry.mesh,\n                                                        material: variantEntry.material,\n                                                    });\n                                                }\n                                            }\n                                        }\n                                        metadata = newRoot._internalMetadata.gltf[NAME];\n                                    }\n                                    // Relocate\n                                    for (const target of metadata.original) {\n                                        if (target.mesh === babylonMesh) {\n                                            target.mesh = newMesh;\n                                        }\n                                    }\n                                    for (const target of metadata.variants[variant.name]) {\n                                        if (target.mesh === babylonMesh) {\n                                            target.mesh = newMesh;\n                                        }\n                                    }\n                                });\n                            }\n                        }));\n                    }\n                }\n            }));\n            // eslint-disable-next-line github/no-then\n            return await Promise.all(promises).then(([babylonMesh]) => {\n                return babylonMesh;\n            });\n        });\n    }\n}\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_variants(loader));\n//# sourceMappingURL=KHR_materials_variants.js.map"],"names":["NAME","KHR_materials_variants","constructor","loader","this","name","_loader","enabled","isExtensionUsed","parent","skipMaterials","dispose","GetAvailableVariants","rootNode","extensionMetadata","_GetExtensionMetadata","Object","keys","variants","getAvailableVariants","SelectVariant","variantName","Error","select","entries","entry","mesh","material","Array","lastSelected","selectVariant","Reset","original","reset","GetLastSelectedVariant","getLastSelectedVariant","_internalMetadata","gltf","onLoading","extensions","extension","_variants","onReady","rootBabylonMesh","options","extensionOptions","defaultVariant","onLoaded","selectedVariant","lastSelectedVariant","isArray","_loadMeshPrimitiveAsync","context","node","primitive","assign","GLTFLoader","LoadExtensionAsync","async","extensionContext","promises","push","babylonMesh","Mesh","babylonDrawMode","_GetDrawMode","mode","root","metadata","mappingIndex","mappings","length","mapping","ArrayItem","Get","materials","_loadMaterialAsync","babylonMaterial","mappingVariantIndex","variantIndex","variant","onClonedObservable","add","newOne","newMesh","newRoot","key","prototype","hasOwnProperty","call","variantEntry","target","Promise","all","then","unregisterGLTFExtension","registerGLTFExtension"],"mappings":"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"}