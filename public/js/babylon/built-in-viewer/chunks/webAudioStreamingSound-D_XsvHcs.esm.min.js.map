{"version":3,"file":"webAudioStreamingSound-D_XsvHcs.esm.min.js","sources":["../../../../../dev/core/dist/AudioV2/abstractAudio/streamingSound.js","../../../../../dev/core/dist/AudioV2/abstractAudio/streamingSoundInstance.js","../../../../../dev/core/dist/AudioV2/webAudio/webAudioStreamingSound.js"],"sourcesContent":["import { AbstractSound } from \"./abstractSound\";\n/**\n * Abstract class representing a streaming sound.\n *\n * A streaming sound has a sound buffer that is loaded into memory in chunks as it is played. This allows it to be played\n * more quickly than a static sound, but it also means that it cannot have loop points or playback rate changes.\n *\n * Due to the way streaming sounds are typically implemented, there can be a significant delay when attempting to play\n * a streaming sound for the first time. To prevent this delay, it is recommended to preload instances of the sound\n * using the {@link IStreamingSoundStoredOptions.preloadCount} options, or the {@link preloadInstanceAsync} and\n * {@link preloadInstancesAsync} methods before calling the `play` method.\n *\n * Streaming sounds are created by the {@link CreateStreamingSoundAsync} function.\n */\nexport class StreamingSound extends AbstractSound {\n    constructor(name, engine) {\n        super(name, engine);\n        this._preloadedInstances = new Array();\n    }\n    /**\n     * The number of instances to preload. Defaults to `1`.\n     */\n    get preloadCount() {\n        return this._options.preloadCount ?? 1;\n    }\n    /**\n     * Returns the number of instances that have been preloaded.\n     */\n    get preloadCompletedCount() {\n        return this._preloadedInstances.length;\n    }\n    /**\n     * Preloads an instance of the sound.\n     * @returns A promise that resolves when the instance is preloaded.\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    preloadInstanceAsync() {\n        const instance = this._createInstance();\n        this._addPreloadedInstance(instance);\n        return instance.preloadedPromise;\n    }\n    /**\n     * Preloads the given number of instances of the sound.\n     * @param count - The number of instances to preload.\n     * @returns A promise that resolves when all instances are preloaded.\n     */\n    async preloadInstancesAsync(count) {\n        for (let i = 0; i < count; i++) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.preloadInstanceAsync();\n        }\n        await Promise.all(this._preloadedInstances.map(async (instance) => await instance.preloadedPromise));\n    }\n    /**\n     * Plays the sound.\n     * - Triggers `onEndedObservable` if played for the full duration and the `loop` option is not set.\n     * @param options The options to use when playing the sound. Options set here override the sound's options.\n     */\n    play(options = {}) {\n        if (this.state === 5 /* SoundState.Paused */) {\n            this.resume();\n            return;\n        }\n        let instance;\n        if (this.preloadCompletedCount > 0) {\n            instance = this._preloadedInstances[0];\n            instance.startOffset = this.startOffset;\n            this._removePreloadedInstance(instance);\n        }\n        else {\n            instance = this._createInstance();\n        }\n        const onInstanceStateChanged = () => {\n            if (instance.state === 3 /* SoundState.Started */) {\n                this._stopExcessInstances();\n                instance.onStateChangedObservable.removeCallback(onInstanceStateChanged);\n            }\n        };\n        instance.onStateChangedObservable.add(onInstanceStateChanged);\n        options.startOffset ??= this.startOffset;\n        options.loop ??= this.loop;\n        options.volume ??= 1;\n        this._beforePlay(instance);\n        instance.play(options);\n        this._afterPlay(instance);\n    }\n    /**\n     * Stops the sound.\n     */\n    stop() {\n        this._setState(1 /* SoundState.Stopped */);\n        if (!this._instances) {\n            return;\n        }\n        for (const instance of Array.from(this._instances)) {\n            instance.stop();\n        }\n    }\n    _addPreloadedInstance(instance) {\n        if (!this._preloadedInstances.includes(instance)) {\n            this._preloadedInstances.push(instance);\n        }\n    }\n    _removePreloadedInstance(instance) {\n        const index = this._preloadedInstances.indexOf(instance);\n        if (index !== -1) {\n            this._preloadedInstances.splice(index, 1);\n        }\n    }\n}\n//# sourceMappingURL=streamingSound.js.map","import { Observable } from \"../../Misc/observable\";\nimport { _AbstractSoundInstance } from \"./abstractSoundInstance\";\n/** @internal */\nexport class _StreamingSoundInstance extends _AbstractSoundInstance {\n    constructor(sound) {\n        super(sound);\n        /** @internal */\n        this.onReadyObservable = new Observable();\n        /** @internal */\n        this.preloadedPromise = new Promise((resolve, reject) => {\n            this._rejectPreloadedProimse = reject;\n            this._resolvePreloadedPromise = resolve;\n        });\n        this.onErrorObservable.add(this._rejectPreloadedProimse);\n        this.onReadyObservable.add(this._resolvePreloadedPromise);\n    }\n    /** @internal */\n    set startOffset(value) {\n        this._options.startOffset = value;\n    }\n    /** @internal */\n    dispose() {\n        super.dispose();\n        this.onErrorObservable.clear();\n        this.onReadyObservable.clear();\n        this._resolvePreloadedPromise();\n    }\n}\n//# sourceMappingURL=streamingSoundInstance.js.map","import { Logger } from \"../../Misc/logger\";\nimport { Tools } from \"../../Misc/tools\";\nimport { StreamingSound } from \"../abstractAudio/streamingSound\";\nimport { _StreamingSoundInstance } from \"../abstractAudio/streamingSoundInstance\";\nimport { _HasSpatialAudioOptions } from \"../abstractAudio/subProperties/abstractSpatialAudio\";\nimport { _StereoAudio } from \"../abstractAudio/subProperties/stereoAudio\";\nimport { _CleanUrl } from \"../audioUtils\";\nimport { _WebAudioBusAndSoundSubGraph } from \"./subNodes/webAudioBusAndSoundSubGraph\";\nimport { _SpatialWebAudio } from \"./subProperties/spatialWebAudio\";\n/** @internal */\nexport class _WebAudioStreamingSound extends StreamingSound {\n    /** @internal */\n    constructor(name, engine, options) {\n        super(name, engine);\n        this._spatial = null;\n        this._spatialAutoUpdate = true;\n        this._spatialMinUpdateTime = 0;\n        this._stereo = null;\n        if (typeof options.spatialAutoUpdate === \"boolean\") {\n            this._spatialAutoUpdate = options.spatialAutoUpdate;\n        }\n        if (typeof options.spatialMinUpdateTime === \"number\") {\n            this._spatialMinUpdateTime = options.spatialMinUpdateTime;\n        }\n        this._options = {\n            autoplay: options.autoplay ?? false,\n            loop: options.loop ?? false,\n            maxInstances: options.maxInstances ?? Infinity,\n            preloadCount: options.preloadCount ?? 1,\n            startOffset: options.startOffset ?? 0,\n        };\n        this._subGraph = new _WebAudioStreamingSound._SubGraph(this);\n    }\n    /** @internal */\n    async _initAsync(source, options) {\n        const audioContext = this.engine._audioContext;\n        if (!(audioContext instanceof AudioContext)) {\n            throw new Error(\"Unsupported audio context type.\");\n        }\n        this._audioContext = audioContext;\n        this._source = source;\n        if (options.outBus) {\n            this.outBus = options.outBus;\n        }\n        else if (options.outBusAutoDefault !== false) {\n            await this.engine.isReadyPromise;\n            this.outBus = this.engine.defaultMainBus;\n        }\n        await this._subGraph.initAsync(options);\n        if (_HasSpatialAudioOptions(options)) {\n            this._initSpatialProperty();\n        }\n        if (this.preloadCount) {\n            await this.preloadInstancesAsync(this.preloadCount);\n        }\n        if (options.autoplay) {\n            this.play(options);\n        }\n        this.engine._addNode(this);\n    }\n    /** @internal */\n    get _inNode() {\n        return this._subGraph._inNode;\n    }\n    /** @internal */\n    get _outNode() {\n        return this._subGraph._outNode;\n    }\n    /** @internal */\n    get spatial() {\n        if (this._spatial) {\n            return this._spatial;\n        }\n        return this._initSpatialProperty();\n    }\n    /** @internal */\n    get stereo() {\n        return this._stereo ?? (this._stereo = new _StereoAudio(this._subGraph));\n    }\n    /** @internal */\n    dispose() {\n        super.dispose();\n        this._spatial = null;\n        this._stereo = null;\n        this._subGraph.dispose();\n        this.engine._removeNode(this);\n    }\n    /** @internal */\n    getClassName() {\n        return \"_WebAudioStreamingSound\";\n    }\n    _createInstance() {\n        return new _WebAudioStreamingSoundInstance(this, this._options);\n    }\n    _connect(node) {\n        const connected = super._connect(node);\n        if (!connected) {\n            return false;\n        }\n        // If the wrapped node is not available now, it will be connected later by the subgraph.\n        if (node._inNode) {\n            this._outNode?.connect(node._inNode);\n        }\n        return true;\n    }\n    _disconnect(node) {\n        const disconnected = super._disconnect(node);\n        if (!disconnected) {\n            return false;\n        }\n        if (node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n        }\n        return true;\n    }\n    _initSpatialProperty() {\n        if (!this._spatial) {\n            this._spatial = new _SpatialWebAudio(this._subGraph, this._spatialAutoUpdate, this._spatialMinUpdateTime);\n        }\n        return this._spatial;\n    }\n}\n_WebAudioStreamingSound._SubGraph = class extends _WebAudioBusAndSoundSubGraph {\n    get _downstreamNodes() {\n        return this._owner._downstreamNodes ?? null;\n    }\n    get _upstreamNodes() {\n        return this._owner._upstreamNodes ?? null;\n    }\n};\n/** @internal */\nclass _WebAudioStreamingSoundInstance extends _StreamingSoundInstance {\n    constructor(sound, options) {\n        super(sound);\n        this._currentTimeChangedWhilePaused = false;\n        this._enginePlayTime = Infinity;\n        this._enginePauseTime = 0;\n        this._isReady = false;\n        this._isReadyPromise = new Promise((resolve, reject) => {\n            this._resolveIsReadyPromise = resolve;\n            this._rejectIsReadyPromise = reject;\n        });\n        this._onCanPlayThrough = () => {\n            this._isReady = true;\n            this._resolveIsReadyPromise(this._mediaElement);\n            this.onReadyObservable.notifyObservers(this);\n        };\n        this._onEnded = () => {\n            this.onEndedObservable.notifyObservers(this);\n            this.dispose();\n        };\n        this._onError = (reason) => {\n            this._setState(4 /* SoundState.FailedToStart */);\n            this.onErrorObservable.notifyObservers(reason);\n            this._rejectIsReadyPromise(reason);\n            this.dispose();\n        };\n        this._onEngineStateChanged = () => {\n            if (this.engine.state !== \"running\") {\n                return;\n            }\n            if (this._options.loop && this.state === 2 /* SoundState.Starting */) {\n                this.play();\n            }\n            this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n        };\n        this._onUserGesture = () => {\n            this.play();\n        };\n        this._options = options;\n        this._volumeNode = new GainNode(sound._audioContext);\n        if (typeof sound._source === \"string\") {\n            this._initFromUrl(sound._source);\n        }\n        else if (Array.isArray(sound._source)) {\n            this._initFromUrls(sound._source);\n        }\n        else if (sound._source instanceof HTMLMediaElement) {\n            this._initFromMediaElement(sound._source);\n        }\n    }\n    /** @internal */\n    get currentTime() {\n        if (this._state === 1 /* SoundState.Stopped */) {\n            return 0;\n        }\n        const timeSinceLastStart = this._state === 5 /* SoundState.Paused */ ? 0 : this.engine.currentTime - this._enginePlayTime;\n        return this._enginePauseTime + timeSinceLastStart + this._options.startOffset;\n    }\n    set currentTime(value) {\n        const restart = this._state === 2 /* SoundState.Starting */ || this._state === 3 /* SoundState.Started */;\n        if (restart) {\n            this._mediaElement.pause();\n            this._setState(1 /* SoundState.Stopped */);\n        }\n        this._options.startOffset = value;\n        if (restart) {\n            this.play({ startOffset: value });\n        }\n        else if (this._state === 5 /* SoundState.Paused */) {\n            this._currentTimeChangedWhilePaused = true;\n        }\n    }\n    get _outNode() {\n        return this._volumeNode;\n    }\n    /** @internal */\n    get startTime() {\n        if (this._state === 1 /* SoundState.Stopped */) {\n            return 0;\n        }\n        return this._enginePlayTime;\n    }\n    /** @internal */\n    dispose() {\n        super.dispose();\n        this.stop();\n        this._sourceNode?.disconnect(this._volumeNode);\n        this._sourceNode = null;\n        this._mediaElement.removeEventListener(\"error\", this._onError);\n        this._mediaElement.removeEventListener(\"ended\", this._onEnded);\n        this._mediaElement.removeEventListener(\"canplaythrough\", this._onCanPlayThrough);\n        for (const source of Array.from(this._mediaElement.children)) {\n            this._mediaElement.removeChild(source);\n        }\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n        this.engine.userGestureObservable.removeCallback(this._onUserGesture);\n    }\n    /** @internal */\n    play(options = {}) {\n        if (this._state === 3 /* SoundState.Started */) {\n            return;\n        }\n        if (options.loop !== undefined) {\n            this._options.loop = options.loop;\n        }\n        this._mediaElement.loop = this._options.loop;\n        let startOffset = options.startOffset;\n        if (this._currentTimeChangedWhilePaused) {\n            startOffset = this._options.startOffset;\n            this._currentTimeChangedWhilePaused = false;\n        }\n        else if (this._state === 5 /* SoundState.Paused */) {\n            startOffset = this.currentTime + this._options.startOffset;\n        }\n        if (startOffset && startOffset > 0) {\n            this._mediaElement.currentTime = startOffset;\n        }\n        this._volumeNode.gain.value = options.volume ?? 1;\n        this._play();\n    }\n    /** @internal */\n    pause() {\n        if (this._state !== 2 /* SoundState.Starting */ && this._state !== 3 /* SoundState.Started */) {\n            return;\n        }\n        this._setState(5 /* SoundState.Paused */);\n        this._enginePauseTime += this.engine.currentTime - this._enginePlayTime;\n        this._mediaElement.pause();\n    }\n    /** @internal */\n    resume() {\n        if (this._state === 5 /* SoundState.Paused */) {\n            this.play();\n        }\n        else if (this._currentTimeChangedWhilePaused) {\n            this.play();\n        }\n    }\n    /** @internal */\n    stop() {\n        if (this._state === 1 /* SoundState.Stopped */) {\n            return;\n        }\n        this._stop();\n    }\n    /** @internal */\n    getClassName() {\n        return \"_WebAudioStreamingSoundInstance\";\n    }\n    _connect(node) {\n        const connected = super._connect(node);\n        if (!connected) {\n            return false;\n        }\n        // If the wrapped node is not available now, it will be connected later by the sound's subgraph.\n        if (node instanceof _WebAudioStreamingSound && node._inNode) {\n            this._outNode?.connect(node._inNode);\n        }\n        return true;\n    }\n    _disconnect(node) {\n        const disconnected = super._disconnect(node);\n        if (!disconnected) {\n            return false;\n        }\n        if (node instanceof _WebAudioStreamingSound && node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n        }\n        return true;\n    }\n    _initFromMediaElement(mediaElement) {\n        Tools.SetCorsBehavior(mediaElement.currentSrc, mediaElement);\n        mediaElement.controls = false;\n        mediaElement.loop = this._options.loop;\n        mediaElement.preload = \"auto\";\n        mediaElement.addEventListener(\"canplaythrough\", this._onCanPlayThrough, { once: true });\n        mediaElement.addEventListener(\"ended\", this._onEnded, { once: true });\n        mediaElement.addEventListener(\"error\", this._onError, { once: true });\n        mediaElement.load();\n        this._sourceNode = new MediaElementAudioSourceNode(this._sound._audioContext, { mediaElement: mediaElement });\n        this._sourceNode.connect(this._volumeNode);\n        if (!this._connect(this._sound)) {\n            throw new Error(\"Connect failed\");\n        }\n        this._mediaElement = mediaElement;\n    }\n    _initFromUrl(url) {\n        const audio = new Audio(_CleanUrl(url));\n        this._initFromMediaElement(audio);\n    }\n    _initFromUrls(urls) {\n        const audio = new Audio();\n        for (const url of urls) {\n            const source = document.createElement(\"source\");\n            source.src = _CleanUrl(url);\n            audio.appendChild(source);\n        }\n        this._initFromMediaElement(audio);\n    }\n    _play() {\n        this._setState(2 /* SoundState.Starting */);\n        if (!this._isReady) {\n            this._playWhenReady();\n            return;\n        }\n        if (this._state !== 2 /* SoundState.Starting */) {\n            return;\n        }\n        if (this.engine.state === \"running\") {\n            const result = this._mediaElement.play();\n            this._enginePlayTime = this.engine.currentTime;\n            this._setState(3 /* SoundState.Started */);\n            // It's possible that the play() method fails on Safari, even if the audio engine's state is \"running\".\n            // This occurs when the audio context is paused by the system and resumed automatically by the audio engine\n            // without a user interaction (e.g. when the Vision Pro exits and reenters immersive mode).\n            // eslint-disable-next-line github/no-then\n            result.catch(() => {\n                this._setState(4 /* SoundState.FailedToStart */);\n                if (this._options.loop) {\n                    this.engine.userGestureObservable.addOnce(this._onUserGesture);\n                }\n            });\n        }\n        else if (this._options.loop) {\n            this.engine.stateChangedObservable.add(this._onEngineStateChanged);\n        }\n        else {\n            this.stop();\n            this._setState(4 /* SoundState.FailedToStart */);\n        }\n    }\n    _playWhenReady() {\n        this._isReadyPromise\n            // eslint-disable-next-line github/no-then\n            .then(() => {\n            this._play();\n        })\n            // eslint-disable-next-line github/no-then\n            .catch(() => {\n            Logger.Error(\"Streaming sound instance failed to play\");\n            this._setState(4 /* SoundState.FailedToStart */);\n        });\n    }\n    _stop() {\n        this._mediaElement.pause();\n        this._setState(1 /* SoundState.Stopped */);\n        this._onEnded();\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    }\n}\n//# sourceMappingURL=webAudioStreamingSound.js.map"],"names":["StreamingSound","AbstractSound","constructor","name","engine","super","this","_preloadedInstances","Array","preloadCount","_options","preloadCompletedCount","length","preloadInstanceAsync","instance","_createInstance","_addPreloadedInstance","preloadedPromise","preloadInstancesAsync","count","i","Promise","all","map","async","play","options","state","resume","startOffset","_removePreloadedInstance","onInstanceStateChanged","_stopExcessInstances","onStateChangedObservable","removeCallback","add","loop","volume","_beforePlay","_afterPlay","stop","_setState","_instances","from","includes","push","index","indexOf","splice","_StreamingSoundInstance","_AbstractSoundInstance","sound","onReadyObservable","Observable","resolve","reject","_rejectPreloadedProimse","_resolvePreloadedPromise","onErrorObservable","value","dispose","clear","_WebAudioStreamingSound","_spatial","_spatialAutoUpdate","_spatialMinUpdateTime","_stereo","spatialAutoUpdate","spatialMinUpdateTime","autoplay","maxInstances","Infinity","_subGraph","_SubGraph","_initAsync","source","audioContext","_audioContext","AudioContext","Error","_source","outBus","outBusAutoDefault","isReadyPromise","defaultMainBus","initAsync","_HasSpatialAudioOptions","_initSpatialProperty","_addNode","_inNode","_outNode","spatial","stereo","_StereoAudio","_removeNode","getClassName","_WebAudioStreamingSoundInstance","_connect","node","connect","_disconnect","disconnect","_SpatialWebAudio","_WebAudioBusAndSoundSubGraph","_downstreamNodes","_owner","_upstreamNodes","_currentTimeChangedWhilePaused","_enginePlayTime","_enginePauseTime","_isReady","_isReadyPromise","_resolveIsReadyPromise","_rejectIsReadyPromise","_onCanPlayThrough","_mediaElement","notifyObservers","_onEnded","onEndedObservable","_onError","reason","_onEngineStateChanged","stateChangedObservable","_onUserGesture","_volumeNode","GainNode","_initFromUrl","isArray","_initFromUrls","HTMLMediaElement","_initFromMediaElement","currentTime","_state","timeSinceLastStart","restart","pause","startTime","_sourceNode","removeEventListener","children","removeChild","userGestureObservable","undefined","gain","_play","_stop","mediaElement","Tools","SetCorsBehavior","currentSrc","controls","preload","addEventListener","once","load","MediaElementAudioSourceNode","_sound","url","audio","Audio","_CleanUrl","urls","document","createElement","src","appendChild","result","catch","addOnce","_playWhenReady","then","Logger"],"mappings":"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"}