{"version":3,"file":"KHR_lights_punctual-CDe71TLr.esm.min.js","sources":["../../../../../dev/core/dist/Lights/pointLight.js","../../../../../dev/loaders/dist/glTF/2.0/Extensions/KHR_lights_punctual.js"],"sourcesContent":["import { __decorate } from \"tslib\";\nimport { serialize } from \"../Misc/decorators\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { Node } from \"../node\";\nimport { Light } from \"./light\";\nimport { ShadowLight } from \"./shadowLight\";\nimport { RegisterClass } from \"../Misc/typeStore\";\nNode.AddNodeConstructor(\"Light_Type_0\", (name, scene) => {\n    return () => new PointLight(name, Vector3.Zero(), scene);\n});\n/**\n * A point light is a light defined by an unique point in world space.\n * The light is emitted in every direction from this point.\n * A good example of a point light is a standard light bulb.\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n */\nexport class PointLight extends ShadowLight {\n    /**\n     * Getter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\n     * This specifies what angle the shadow will use to be created.\n     *\n     * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.\n     */\n    get shadowAngle() {\n        return this._shadowAngle;\n    }\n    /**\n     * Setter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\n     * This specifies what angle the shadow will use to be created.\n     *\n     * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.\n     */\n    set shadowAngle(value) {\n        this._shadowAngle = value;\n        this.forceProjectionMatrixCompute();\n    }\n    /**\n     * Gets the direction if it has been set.\n     * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\n     */\n    get direction() {\n        return this._direction;\n    }\n    /**\n     * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\n     */\n    set direction(value) {\n        const previousNeedCube = this.needCube();\n        this._direction = value;\n        if (this.needCube() !== previousNeedCube && this._shadowGenerators) {\n            const iterator = this._shadowGenerators.values();\n            for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n                const shadowGenerator = key.value;\n                shadowGenerator.recreateShadowMap();\n            }\n        }\n    }\n    /**\n     * Creates a PointLight object from the passed name and position (Vector3) and adds it in the scene.\n     * A PointLight emits the light in every direction.\n     * It can cast shadows.\n     * If the scene camera is already defined and you want to set your PointLight at the camera position, just set it :\n     * ```javascript\n     * var pointLight = new PointLight(\"pl\", camera.position, scene);\n     * ```\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n     * @param name The light friendly name\n     * @param position The position of the point light in the scene\n     * @param scene The scene the lights belongs to\n     */\n    constructor(name, position, scene) {\n        super(name, scene);\n        this._shadowAngle = Math.PI / 2;\n        this.position = position;\n    }\n    /**\n     * Returns the string \"PointLight\"\n     * @returns the class name\n     */\n    getClassName() {\n        return \"PointLight\";\n    }\n    /**\n     * Returns the integer 0.\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    getTypeID() {\n        return Light.LIGHTTYPEID_POINTLIGHT;\n    }\n    /**\n     * Specifies whether or not the shadowmap should be a cube texture.\n     * @returns true if the shadowmap needs to be a cube texture.\n     */\n    needCube() {\n        return !this.direction;\n    }\n    /**\n     * Returns a new Vector3 aligned with the PointLight cube system according to the passed cube face index (integer).\n     * @param faceIndex The index of the face we are computed the direction to generate shadow\n     * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true\n     */\n    getShadowDirection(faceIndex) {\n        if (this.direction) {\n            return super.getShadowDirection(faceIndex);\n        }\n        else {\n            switch (faceIndex) {\n                case 0:\n                    return new Vector3(1.0, 0.0, 0.0);\n                case 1:\n                    return new Vector3(-1.0, 0.0, 0.0);\n                case 2:\n                    return new Vector3(0.0, -1.0, 0.0);\n                case 3:\n                    return new Vector3(0.0, 1.0, 0.0);\n                case 4:\n                    return new Vector3(0.0, 0.0, 1.0);\n                case 5:\n                    return new Vector3(0.0, 0.0, -1.0);\n            }\n        }\n        return Vector3.Zero();\n    }\n    /**\n     * Sets the passed matrix \"matrix\" as a left-handed perspective projection matrix with the following settings :\n     * - fov = PI / 2\n     * - aspect ratio : 1.0\n     * - z-near and far equal to the active camera minZ and maxZ.\n     * Returns the PointLight.\n     * @param matrix\n     * @param viewMatrix\n     * @param renderList\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {\n        const activeCamera = this.getScene().activeCamera;\n        if (!activeCamera) {\n            return;\n        }\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\n        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\n        Matrix.PerspectiveFovLHToRef(this.shadowAngle, 1.0, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, true, this._scene.getEngine().isNDCHalfZRange, undefined, useReverseDepthBuffer);\n    }\n    _buildUniformLayout() {\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\n        this._uniformBuffer.addUniform(\"vLightFalloff\", 4);\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\n        this._uniformBuffer.create();\n    }\n    /**\n     * Sets the passed Effect \"effect\" with the PointLight transformed position (or position, if none) and passed name (string).\n     * @param effect The effect to update\n     * @param lightIndex The index of the light in the effect to update\n     * @returns The point light\n     */\n    transferToEffect(effect, lightIndex) {\n        if (this.computeTransformedInformation()) {\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedPosition.x - this._scene.floatingOriginOffset.x, this.transformedPosition.y - this._scene.floatingOriginOffset.y, this.transformedPosition.z - this._scene.floatingOriginOffset.z, 0.0, lightIndex);\n        }\n        else {\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.position.x - this._scene.floatingOriginOffset.x, this.position.y - this._scene.floatingOriginOffset.y, this.position.z - this._scene.floatingOriginOffset.z, 0, lightIndex);\n        }\n        this._uniformBuffer.updateFloat4(\"vLightFalloff\", this.range, this._inverseSquaredRange, 0, 0, lightIndex);\n        return this;\n    }\n    transferToNodeMaterialEffect(effect, lightDataUniformName) {\n        if (this.computeTransformedInformation()) {\n            effect.setFloat3(lightDataUniformName, this.transformedPosition.x - this._scene.floatingOriginOffset.x, this.transformedPosition.y - this._scene.floatingOriginOffset.y, this.transformedPosition.z - this._scene.floatingOriginOffset.z);\n        }\n        else {\n            effect.setFloat3(lightDataUniformName, this.position.x - this._scene.floatingOriginOffset.x, this.position.y - this._scene.floatingOriginOffset.y, this.position.z - this._scene.floatingOriginOffset.z);\n        }\n        return this;\n    }\n    /**\n     * Prepares the list of defines specific to the light type.\n     * @param defines the list of defines\n     * @param lightIndex defines the index of the light for the effect\n     */\n    prepareLightSpecificDefines(defines, lightIndex) {\n        defines[\"POINTLIGHT\" + lightIndex] = true;\n    }\n}\n__decorate([\n    serialize()\n], PointLight.prototype, \"shadowAngle\", null);\n// Register Class Name\nRegisterClass(\"BABYLON.PointLight\", PointLight);\n//# sourceMappingURL=pointLight.js.map","import { Vector3 } from \"core/Maths/math.vector\";\nimport { Color3 } from \"core/Maths/math.color\";\nimport { DirectionalLight } from \"core/Lights/directionalLight\";\nimport { PointLight } from \"core/Lights/pointLight\";\nimport { SpotLight } from \"core/Lights/spotLight\";\nimport { Light } from \"core/Lights/light\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\nconst NAME = \"KHR_lights_punctual\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_lights_punctual/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_lights {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n        delete this._lights;\n    }\n    /** @internal */\n    onLoading() {\n        const extensions = this._loader.gltf.extensions;\n        if (extensions && extensions[this.name]) {\n            const extension = extensions[this.name];\n            this._lights = extension.lights;\n            ArrayItem.Assign(this._lights);\n        }\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadNodeAsync(context, node, assign) {\n        return GLTFLoader.LoadExtensionAsync(context, node, this.name, async (extensionContext, extension) => {\n            this._loader._allMaterialsDirtyRequired = true;\n            return await this._loader.loadNodeAsync(context, node, (babylonMesh) => {\n                let babylonLight;\n                const light = ArrayItem.Get(extensionContext, this._lights, extension.light);\n                const name = light.name || babylonMesh.name;\n                this._loader.babylonScene._blockEntityCollection = !!this._loader._assetContainer;\n                switch (light.type) {\n                    case \"directional\" /* KHRLightsPunctual_LightType.DIRECTIONAL */: {\n                        const babylonDirectionalLight = new DirectionalLight(name, Vector3.Backward(), this._loader.babylonScene);\n                        babylonDirectionalLight.position.setAll(0);\n                        babylonLight = babylonDirectionalLight;\n                        break;\n                    }\n                    case \"point\" /* KHRLightsPunctual_LightType.POINT */: {\n                        babylonLight = new PointLight(name, Vector3.Zero(), this._loader.babylonScene);\n                        break;\n                    }\n                    case \"spot\" /* KHRLightsPunctual_LightType.SPOT */: {\n                        const babylonSpotLight = new SpotLight(name, Vector3.Zero(), Vector3.Backward(), 0, 1, this._loader.babylonScene);\n                        babylonSpotLight.angle = ((light.spot && light.spot.outerConeAngle) || Math.PI / 4) * 2;\n                        babylonSpotLight.innerAngle = ((light.spot && light.spot.innerConeAngle) || 0) * 2;\n                        babylonLight = babylonSpotLight;\n                        break;\n                    }\n                    default: {\n                        this._loader.babylonScene._blockEntityCollection = false;\n                        throw new Error(`${extensionContext}: Invalid light type (${light.type})`);\n                    }\n                }\n                babylonLight._parentContainer = this._loader._assetContainer;\n                this._loader.babylonScene._blockEntityCollection = false;\n                light._babylonLight = babylonLight;\n                babylonLight.falloffType = Light.FALLOFF_GLTF;\n                babylonLight.diffuse = light.color ? Color3.FromArray(light.color) : Color3.White();\n                babylonLight.intensity = light.intensity == undefined ? 1 : light.intensity;\n                babylonLight.range = light.range == undefined ? Number.MAX_VALUE : light.range;\n                babylonLight.parent = babylonMesh;\n                this._loader._babylonLights.push(babylonLight);\n                GLTFLoader.AddPointerMetadata(babylonLight, extensionContext);\n                assign(babylonMesh);\n            });\n        });\n    }\n}\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new KHR_lights(loader));\n//# sourceMappingURL=KHR_lights_punctual.js.map"],"names":["Node","AddNodeConstructor","name","scene","PointLight","Vector3","Zero","ShadowLight","shadowAngle","this","_shadowAngle","value","forceProjectionMatrixCompute","direction","_direction","previousNeedCube","needCube","_shadowGenerators","iterator","values","key","next","done","recreateShadowMap","constructor","position","super","Math","PI","getClassName","getTypeID","Light","LIGHTTYPEID_POINTLIGHT","getShadowDirection","faceIndex","_setDefaultShadowProjectionMatrix","matrix","viewMatrix","renderList","activeCamera","getScene","minZ","undefined","shadowMinZ","maxZ","shadowMaxZ","useReverseDepthBuffer","getEngine","Matrix","PerspectiveFovLHToRef","_scene","isNDCHalfZRange","_buildUniformLayout","_uniformBuffer","addUniform","create","transferToEffect","effect","lightIndex","computeTransformedInformation","updateFloat4","transformedPosition","x","floatingOriginOffset","y","z","range","_inverseSquaredRange","transferToNodeMaterialEffect","lightDataUniformName","setFloat3","prepareLightSpecificDefines","defines","__decorate","serialize","prototype","RegisterClass","NAME","KHR_lights","loader","_loader","enabled","isExtensionUsed","dispose","_lights","onLoading","extensions","gltf","extension","lights","ArrayItem","Assign","loadNodeAsync","context","node","assign","GLTFLoader","LoadExtensionAsync","async","extensionContext","_allMaterialsDirtyRequired","babylonMesh","babylonLight","light","Get","babylonScene","_blockEntityCollection","_assetContainer","type","babylonDirectionalLight","DirectionalLight","Backward","setAll","babylonSpotLight","SpotLight","angle","spot","outerConeAngle","innerAngle","innerConeAngle","Error","_parentContainer","_babylonLight","falloffType","FALLOFF_GLTF","diffuse","color","Color3","FromArray","White","intensity","Number","MAX_VALUE","parent","_babylonLights","push","AddPointerMetadata","unregisterGLTFExtension","registerGLTFExtension"],"mappings":"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"}