{"version":3,"file":"animationGroup-DGctiNA1.esm.min.js","sources":["../../../../../dev/core/dist/Animations/runtimeAnimation.js","../../../../../dev/core/dist/Animations/animatable.core.js","../../../../../dev/core/dist/Animations/animatable.js","../../../../../dev/core/dist/Animations/animationGroup.js"],"sourcesContent":["import { Matrix } from \"../Maths/math.vector\";\nimport { Animation, _StaticOffsetValueColor3, _StaticOffsetValueColor4, _StaticOffsetValueQuaternion, _StaticOffsetValueSize, _StaticOffsetValueVector2, _StaticOffsetValueVector3, } from \"./animation\";\n/**\n * Defines a runtime animation\n */\nexport class RuntimeAnimation {\n    /**\n     * Gets the current frame of the runtime animation\n     */\n    get currentFrame() {\n        return this._currentFrame;\n    }\n    /**\n     * Gets the weight of the runtime animation\n     */\n    get weight() {\n        return this._weight;\n    }\n    /**\n     * Gets the current value of the runtime animation\n     */\n    get currentValue() {\n        return this._currentValue;\n    }\n    /**\n     * Gets or sets the target path of the runtime animation\n     */\n    get targetPath() {\n        return this._targetPath;\n    }\n    /**\n     * Gets the actual target of the runtime animation\n     */\n    get target() {\n        return this._currentActiveTarget;\n    }\n    /**\n     * Gets the additive state of the runtime animation\n     */\n    get isAdditive() {\n        return this._host && this._host.isAdditive;\n    }\n    /**\n     * Create a new RuntimeAnimation object\n     * @param target defines the target of the animation\n     * @param animation defines the source animation object\n     * @param scene defines the hosting scene\n     * @param host defines the initiating Animatable\n     */\n    constructor(target, animation, scene, host) {\n        this._events = new Array();\n        /**\n         * The current frame of the runtime animation\n         */\n        this._currentFrame = 0;\n        /**\n         * The original value of the runtime animation\n         */\n        this._originalValue = new Array();\n        /**\n         * The original blend value of the runtime animation\n         */\n        this._originalBlendValue = null;\n        /**\n         * The offsets cache of the runtime animation\n         */\n        this._offsetsCache = {};\n        /**\n         * The high limits cache of the runtime animation\n         */\n        this._highLimitsCache = {};\n        /**\n         * Specifies if the runtime animation has been stopped\n         */\n        this._stopped = false;\n        /**\n         * The blending factor of the runtime animation\n         */\n        this._blendingFactor = 0;\n        /**\n         * The current value of the runtime animation\n         */\n        this._currentValue = null;\n        this._currentActiveTarget = null;\n        this._directTarget = null;\n        /**\n         * The target path of the runtime animation\n         */\n        this._targetPath = \"\";\n        /**\n         * The weight of the runtime animation\n         */\n        this._weight = 1.0;\n        /**\n         * The absolute frame offset of the runtime animation\n         */\n        this._absoluteFrameOffset = 0;\n        /**\n         * The previous elapsed time (since start of animation) of the runtime animation\n         */\n        this._previousElapsedTime = 0;\n        this._yoyoDirection = 1;\n        /**\n         * The previous absolute frame of the runtime animation (meaning, without taking into account the from/to values, only the elapsed time and the fps)\n         */\n        this._previousAbsoluteFrame = 0;\n        this._targetIsArray = false;\n        /** @internal */\n        this._coreRuntimeAnimation = null;\n        this._animation = animation;\n        this._target = target;\n        this._scene = scene;\n        this._host = host;\n        this._activeTargets = [];\n        animation._runtimeAnimations.push(this);\n        // State\n        this._animationState = {\n            key: 0,\n            repeatCount: 0,\n            loopMode: this._getCorrectLoopMode(),\n        };\n        if (this._animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\n            this._animationState.workValue = Matrix.Zero();\n        }\n        // Limits\n        this._keys = this._animation.getKeys();\n        this._minFrame = this._keys[0].frame;\n        this._maxFrame = this._keys[this._keys.length - 1].frame;\n        this._minValue = this._keys[0].value;\n        this._maxValue = this._keys[this._keys.length - 1].value;\n        // Add a start key at frame 0 if missing\n        if (this._minFrame !== 0) {\n            const newKey = { frame: 0, value: this._minValue };\n            this._keys.splice(0, 0, newKey);\n        }\n        // Check data\n        if (this._target instanceof Array) {\n            let index = 0;\n            for (const target of this._target) {\n                this._preparePath(target, index);\n                this._getOriginalValues(index);\n                index++;\n            }\n            this._targetIsArray = true;\n        }\n        else {\n            this._preparePath(this._target);\n            this._getOriginalValues();\n            this._targetIsArray = false;\n            this._directTarget = this._activeTargets[0];\n        }\n        // Cloning events locally\n        const events = animation.getEvents();\n        if (events && events.length > 0) {\n            for (const e of events) {\n                this._events.push(e._clone());\n            }\n        }\n        this._enableBlending = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.enableBlending : this._animation.enableBlending;\n    }\n    _preparePath(target, targetIndex = 0) {\n        const targetPropertyPath = this._animation.targetPropertyPath;\n        if (targetPropertyPath.length > 1) {\n            let property = target;\n            for (let index = 0; index < targetPropertyPath.length - 1; index++) {\n                const name = targetPropertyPath[index];\n                property = property[name];\n                if (property === undefined) {\n                    throw new Error(`Invalid property (${name}) in property path (${targetPropertyPath.join(\".\")})`);\n                }\n            }\n            this._targetPath = targetPropertyPath[targetPropertyPath.length - 1];\n            this._activeTargets[targetIndex] = property;\n        }\n        else {\n            this._targetPath = targetPropertyPath[0];\n            this._activeTargets[targetIndex] = target;\n        }\n        if (this._activeTargets[targetIndex][this._targetPath] === undefined) {\n            throw new Error(`Invalid property (${this._targetPath}) in property path (${targetPropertyPath.join(\".\")})`);\n        }\n    }\n    /**\n     * Gets the animation from the runtime animation\n     */\n    get animation() {\n        return this._animation;\n    }\n    /**\n     * Resets the runtime animation to the beginning\n     * @param restoreOriginal defines whether to restore the target property to the original value\n     */\n    reset(restoreOriginal = false) {\n        if (restoreOriginal) {\n            if (this._target instanceof Array) {\n                let index = 0;\n                for (const target of this._target) {\n                    if (this._originalValue[index] !== undefined) {\n                        this._setValue(target, this._activeTargets[index], this._originalValue[index], -1, index);\n                    }\n                    index++;\n                }\n            }\n            else {\n                if (this._originalValue[0] !== undefined) {\n                    this._setValue(this._target, this._directTarget, this._originalValue[0], -1, 0);\n                }\n            }\n        }\n        this._offsetsCache = {};\n        this._highLimitsCache = {};\n        this._currentFrame = 0;\n        this._blendingFactor = 0;\n        // Events\n        for (let index = 0; index < this._events.length; index++) {\n            this._events[index].isDone = false;\n        }\n    }\n    /**\n     * Specifies if the runtime animation is stopped\n     * @returns Boolean specifying if the runtime animation is stopped\n     */\n    isStopped() {\n        return this._stopped;\n    }\n    /**\n     * Disposes of the runtime animation\n     */\n    dispose() {\n        const index = this._animation.runtimeAnimations.indexOf(this);\n        if (index > -1) {\n            this._animation.runtimeAnimations.splice(index, 1);\n        }\n    }\n    /**\n     * Apply the interpolated value to the target\n     * @param currentValue defines the value computed by the animation\n     * @param weight defines the weight to apply to this value (Defaults to 1.0)\n     */\n    setValue(currentValue, weight) {\n        if (this._targetIsArray) {\n            for (let index = 0; index < this._target.length; index++) {\n                const target = this._target[index];\n                this._setValue(target, this._activeTargets[index], currentValue, weight, index);\n            }\n            return;\n        }\n        this._setValue(this._target, this._directTarget, currentValue, weight, 0);\n    }\n    _getOriginalValues(targetIndex = 0) {\n        let originalValue;\n        const target = this._activeTargets[targetIndex];\n        if (target.getLocalMatrix && this._targetPath === \"_matrix\") {\n            // For bones\n            originalValue = target.getLocalMatrix();\n        }\n        else {\n            originalValue = target[this._targetPath];\n        }\n        if (originalValue && originalValue.clone) {\n            this._originalValue[targetIndex] = originalValue.clone();\n        }\n        else {\n            this._originalValue[targetIndex] = originalValue;\n        }\n    }\n    _registerTargetForLateAnimationBinding(runtimeAnimation, originalValue) {\n        const target = runtimeAnimation.target;\n        this._scene._registeredForLateAnimationBindings.pushNoDuplicate(target);\n        if (!target._lateAnimationHolders) {\n            target._lateAnimationHolders = {};\n        }\n        if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\n            target._lateAnimationHolders[runtimeAnimation.targetPath] = {\n                totalWeight: 0,\n                totalAdditiveWeight: 0,\n                animations: [],\n                additiveAnimations: [],\n                originalValue: originalValue,\n            };\n        }\n        if (runtimeAnimation.isAdditive) {\n            target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\n            target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\n        }\n        else {\n            target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\n            target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\n        }\n    }\n    _setValue(target, destination, currentValue, weight, targetIndex) {\n        // Set value\n        this._currentActiveTarget = destination;\n        this._weight = weight;\n        if (this._enableBlending && this._blendingFactor <= 1.0) {\n            if (!this._originalBlendValue) {\n                const originalValue = destination[this._targetPath];\n                if (originalValue.clone) {\n                    this._originalBlendValue = originalValue.clone();\n                }\n                else {\n                    this._originalBlendValue = originalValue;\n                }\n            }\n            if (this._originalBlendValue.m) {\n                // Matrix\n                if (Animation.AllowMatrixDecomposeForInterpolation) {\n                    if (this._currentValue) {\n                        Matrix.DecomposeLerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\n                    }\n                    else {\n                        this._currentValue = Matrix.DecomposeLerp(this._originalBlendValue, currentValue, this._blendingFactor);\n                    }\n                }\n                else {\n                    if (this._currentValue) {\n                        Matrix.LerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\n                    }\n                    else {\n                        this._currentValue = Matrix.Lerp(this._originalBlendValue, currentValue, this._blendingFactor);\n                    }\n                }\n            }\n            else {\n                this._currentValue = Animation._UniversalLerp(this._originalBlendValue, currentValue, this._blendingFactor);\n            }\n            const blendingSpeed = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.blendingSpeed : this._animation.blendingSpeed;\n            this._blendingFactor += blendingSpeed;\n        }\n        else {\n            if (!this._currentValue) {\n                if (currentValue?.clone) {\n                    this._currentValue = currentValue.clone();\n                }\n                else {\n                    this._currentValue = currentValue;\n                }\n            }\n            else if (this._currentValue.copyFrom) {\n                this._currentValue.copyFrom(currentValue);\n            }\n            else {\n                this._currentValue = currentValue;\n            }\n        }\n        if (weight !== -1.0) {\n            this._registerTargetForLateAnimationBinding(this, this._originalValue[targetIndex]);\n        }\n        else {\n            if (this._animationState.loopMode === Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT) {\n                if (this._currentValue.addToRef) {\n                    this._currentValue.addToRef(this._originalValue[targetIndex], destination[this._targetPath]);\n                }\n                else {\n                    destination[this._targetPath] = this._originalValue[targetIndex] + this._currentValue;\n                }\n            }\n            else {\n                destination[this._targetPath] = this._currentValue;\n            }\n        }\n        if (target.markAsDirty) {\n            target.markAsDirty(this._animation.targetProperty);\n        }\n    }\n    /**\n     * Gets the loop pmode of the runtime animation\n     * @returns Loop Mode\n     */\n    _getCorrectLoopMode() {\n        if (this._target && this._target.animationPropertiesOverride) {\n            return this._target.animationPropertiesOverride.loopMode;\n        }\n        return this._animation.loopMode;\n    }\n    /**\n     * Move the current animation to a given frame\n     * @param frame defines the frame to move to\n     * @param weight defines the weight to apply to the animation (-1.0 by default)\n     */\n    goToFrame(frame, weight = -1) {\n        const keys = this._animation.getKeys();\n        if (frame < keys[0].frame) {\n            frame = keys[0].frame;\n        }\n        else if (frame > keys[keys.length - 1].frame) {\n            frame = keys[keys.length - 1].frame;\n        }\n        // Need to reset animation events\n        const events = this._events;\n        if (events.length) {\n            for (let index = 0; index < events.length; index++) {\n                if (!events[index].onlyOnce) {\n                    // reset events in the future\n                    events[index].isDone = events[index].frame < frame;\n                }\n            }\n        }\n        this._currentFrame = frame;\n        const currentValue = this._animation._interpolate(frame, this._animationState);\n        this.setValue(currentValue, weight);\n    }\n    /**\n     * @internal Internal use only\n     */\n    _prepareForSpeedRatioChange(newSpeedRatio) {\n        const newAbsoluteFrame = (this._previousElapsedTime * (this._animation.framePerSecond * newSpeedRatio)) / 1000.0;\n        this._absoluteFrameOffset = this._previousAbsoluteFrame - newAbsoluteFrame;\n    }\n    /**\n     * Execute the current animation\n     * @param elapsedTimeSinceAnimationStart defines the elapsed time (in milliseconds) since the animation was started\n     * @param from defines the lower frame of the animation range\n     * @param to defines the upper frame of the animation range\n     * @param loop defines if the current animation must loop\n     * @param speedRatio defines the current speed ratio\n     * @param weight defines the weight of the animation (default is -1 so no weight)\n     * @returns a boolean indicating if the animation is running\n     */\n    animate(elapsedTimeSinceAnimationStart, from, to, loop, speedRatio, weight = -1.0) {\n        const animation = this._animation;\n        const targetPropertyPath = animation.targetPropertyPath;\n        if (!targetPropertyPath || targetPropertyPath.length < 1) {\n            this._stopped = true;\n            return false;\n        }\n        let returnValue = true;\n        let currentFrame;\n        const events = this._events;\n        let frameRange = 0;\n        if (!this._coreRuntimeAnimation) {\n            // Check limits\n            if (from < this._minFrame || from > this._maxFrame) {\n                from = this._minFrame;\n            }\n            if (to < this._minFrame || to > this._maxFrame) {\n                to = this._maxFrame;\n            }\n            frameRange = to - from;\n            let offsetValue;\n            // Compute the frame according to the elapsed time and the fps of the animation (\"from\" and \"to\" are not factored in!)\n            let absoluteFrame = (elapsedTimeSinceAnimationStart * (animation.framePerSecond * speedRatio)) / 1000.0 + this._absoluteFrameOffset;\n            let highLimitValue = 0;\n            // Apply the yoyo function if required\n            let yoyoLoop = false;\n            const yoyoMode = loop && this._animationState.loopMode === Animation.ANIMATIONLOOPMODE_YOYO;\n            if (yoyoMode) {\n                const position = (absoluteFrame - from) / frameRange;\n                // Apply the yoyo curve\n                const sin = Math.sin(position * Math.PI);\n                const yoyoPosition = Math.abs(sin);\n                // Map the yoyo position back to the range\n                absoluteFrame = yoyoPosition * frameRange + from;\n                const direction = sin >= 0 ? 1 : -1;\n                if (this._yoyoDirection !== direction) {\n                    yoyoLoop = true;\n                }\n                this._yoyoDirection = direction;\n            }\n            this._previousElapsedTime = elapsedTimeSinceAnimationStart;\n            this._previousAbsoluteFrame = absoluteFrame;\n            if (!loop && to >= from && ((absoluteFrame >= frameRange && speedRatio > 0) || (absoluteFrame <= 0 && speedRatio < 0))) {\n                // If we are out of range and not looping get back to caller\n                returnValue = false;\n                highLimitValue = animation._getKeyValue(this._maxValue);\n            }\n            else if (!loop && from >= to && ((absoluteFrame <= frameRange && speedRatio < 0) || (absoluteFrame >= 0 && speedRatio > 0))) {\n                returnValue = false;\n                highLimitValue = animation._getKeyValue(this._minValue);\n            }\n            else if (this._animationState.loopMode !== Animation.ANIMATIONLOOPMODE_CYCLE) {\n                const keyOffset = to.toString() + from.toString();\n                if (!this._offsetsCache[keyOffset]) {\n                    this._animationState.repeatCount = 0;\n                    this._animationState.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE; // force a specific codepath in animation._interpolate()!\n                    const fromValue = animation._interpolate(from, this._animationState);\n                    const toValue = animation._interpolate(to, this._animationState);\n                    this._animationState.loopMode = this._getCorrectLoopMode();\n                    switch (animation.dataType) {\n                        // Float\n                        case Animation.ANIMATIONTYPE_FLOAT:\n                            this._offsetsCache[keyOffset] = toValue - fromValue;\n                            break;\n                        // Quaternion\n                        case Animation.ANIMATIONTYPE_QUATERNION:\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                            break;\n                        // Vector3\n                        case Animation.ANIMATIONTYPE_VECTOR3:\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                            break;\n                        // Vector2\n                        case Animation.ANIMATIONTYPE_VECTOR2:\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                            break;\n                        // Size\n                        case Animation.ANIMATIONTYPE_SIZE:\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                            break;\n                        // Color3\n                        case Animation.ANIMATIONTYPE_COLOR3:\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                            break;\n                        default:\n                            break;\n                    }\n                    this._highLimitsCache[keyOffset] = toValue;\n                }\n                highLimitValue = this._highLimitsCache[keyOffset];\n                offsetValue = this._offsetsCache[keyOffset];\n            }\n            if (offsetValue === undefined) {\n                switch (animation.dataType) {\n                    // Float\n                    case Animation.ANIMATIONTYPE_FLOAT:\n                        offsetValue = 0;\n                        break;\n                    // Quaternion\n                    case Animation.ANIMATIONTYPE_QUATERNION:\n                        offsetValue = _StaticOffsetValueQuaternion;\n                        break;\n                    // Vector3\n                    case Animation.ANIMATIONTYPE_VECTOR3:\n                        offsetValue = _StaticOffsetValueVector3;\n                        break;\n                    // Vector2\n                    case Animation.ANIMATIONTYPE_VECTOR2:\n                        offsetValue = _StaticOffsetValueVector2;\n                        break;\n                    // Size\n                    case Animation.ANIMATIONTYPE_SIZE:\n                        offsetValue = _StaticOffsetValueSize;\n                        break;\n                    // Color3\n                    case Animation.ANIMATIONTYPE_COLOR3:\n                        offsetValue = _StaticOffsetValueColor3;\n                        break;\n                    case Animation.ANIMATIONTYPE_COLOR4:\n                        offsetValue = _StaticOffsetValueColor4;\n                        break;\n                }\n            }\n            // Compute value\n            if (this._host && this._host.syncRoot) {\n                // If we must sync with an animatable, calculate the current frame based on the frame of the root animatable\n                const syncRoot = this._host.syncRoot;\n                const hostNormalizedFrame = (syncRoot.masterFrame - syncRoot.fromFrame) / (syncRoot.toFrame - syncRoot.fromFrame);\n                currentFrame = from + frameRange * hostNormalizedFrame;\n            }\n            else {\n                if ((absoluteFrame > 0 && from > to) || (absoluteFrame < 0 && from < to)) {\n                    currentFrame = returnValue && frameRange !== 0 ? to + (absoluteFrame % frameRange) : from;\n                }\n                else {\n                    currentFrame = returnValue && frameRange !== 0 ? from + (absoluteFrame % frameRange) : to;\n                }\n            }\n            // Reset event/state if looping\n            if ((!yoyoMode && ((speedRatio > 0 && this.currentFrame > currentFrame) || (speedRatio < 0 && this.currentFrame < currentFrame))) || (yoyoMode && yoyoLoop)) {\n                this._onLoop();\n                // Need to reset animation events\n                for (let index = 0; index < events.length; index++) {\n                    if (!events[index].onlyOnce) {\n                        // reset event, the animation is looping\n                        events[index].isDone = false;\n                    }\n                }\n                this._animationState.key = speedRatio > 0 ? 0 : animation.getKeys().length - 1;\n            }\n            this._currentFrame = currentFrame;\n            this._animationState.repeatCount = frameRange === 0 ? 0 : (absoluteFrame / frameRange) >> 0;\n            this._animationState.highLimitValue = highLimitValue;\n            this._animationState.offsetValue = offsetValue;\n        }\n        else {\n            frameRange = to - from;\n            currentFrame = this._coreRuntimeAnimation.currentFrame;\n            this._currentFrame = currentFrame;\n            this._animationState.repeatCount = this._coreRuntimeAnimation._animationState.repeatCount;\n            this._animationState.highLimitValue = this._coreRuntimeAnimation._animationState.highLimitValue;\n            this._animationState.offsetValue = this._coreRuntimeAnimation._animationState.offsetValue;\n        }\n        const currentValue = animation._interpolate(currentFrame, this._animationState);\n        // Set value\n        this.setValue(currentValue, weight);\n        // Check events\n        if (events.length) {\n            for (let index = 0; index < events.length; index++) {\n                // Make sure current frame has passed event frame and that event frame is within the current range\n                // Also, handle both forward and reverse animations\n                if ((frameRange >= 0 && currentFrame >= events[index].frame && events[index].frame >= from) ||\n                    (frameRange < 0 && currentFrame <= events[index].frame && events[index].frame <= from)) {\n                    const event = events[index];\n                    if (!event.isDone) {\n                        // If event should be done only once, remove it.\n                        if (event.onlyOnce) {\n                            events.splice(index, 1);\n                            index--;\n                        }\n                        event.isDone = true;\n                        event.action(currentFrame);\n                    } // Don't do anything if the event has already been done.\n                }\n            }\n        }\n        if (!returnValue) {\n            this._stopped = true;\n        }\n        return returnValue;\n    }\n}\n//# sourceMappingURL=runtimeAnimation.js.map","import { Observable } from \"core/Misc/observable\";\nimport { RuntimeAnimation } from \"./runtimeAnimation\";\nimport { Animation } from \"./animation\";\nimport { PrecisionDate } from \"core/Misc/precisionDate\";\nimport { Matrix, Quaternion, TmpVectors, Vector3 } from \"core/Maths/math.vector\";\n/**\n * Class used to store an actual running animation\n */\nexport class Animatable {\n    /**\n     * Gets the root Animatable used to synchronize and normalize animations\n     */\n    get syncRoot() {\n        return this._syncRoot;\n    }\n    /**\n     * Gets the current frame of the first RuntimeAnimation\n     * Used to synchronize Animatables\n     */\n    get masterFrame() {\n        if (this._runtimeAnimations.length === 0) {\n            return 0;\n        }\n        return this._runtimeAnimations[0].currentFrame;\n    }\n    /**\n     * Gets or sets the animatable weight (-1.0 by default meaning not weighted)\n     */\n    get weight() {\n        return this._weight;\n    }\n    set weight(value) {\n        if (value === -1) {\n            // -1 is ok and means no weight\n            this._weight = -1;\n            return;\n        }\n        // Else weight must be in [0, 1] range\n        this._weight = Math.min(Math.max(value, 0), 1.0);\n    }\n    /**\n     * Gets or sets the speed ratio to apply to the animatable (1.0 by default)\n     */\n    get speedRatio() {\n        return this._speedRatio;\n    }\n    set speedRatio(value) {\n        for (let index = 0; index < this._runtimeAnimations.length; index++) {\n            const animation = this._runtimeAnimations[index];\n            animation._prepareForSpeedRatioChange(value);\n        }\n        this._speedRatio = value;\n        // Resync _manualJumpDelay in case goToFrame was called before speedRatio was set.\n        if (this._goToFrame !== null) {\n            this.goToFrame(this._goToFrame);\n        }\n    }\n    /**\n     * Gets the elapsed time since the animatable started in milliseconds\n     */\n    get elapsedTime() {\n        return this._localDelayOffset === null ? 0 : this._scene._animationTime - this._localDelayOffset;\n    }\n    /**\n     * Creates a new Animatable\n     * @param scene defines the hosting scene\n     * @param target defines the target object\n     * @param fromFrame defines the starting frame number (default is 0)\n     * @param toFrame defines the ending frame number (default is 100)\n     * @param loopAnimation defines if the animation must loop (default is false)\n     * @param speedRatio defines the factor to apply to animation speed (default is 1)\n     * @param onAnimationEnd defines a callback to call when animation ends if it is not looping\n     * @param animations defines a group of animation to add to the new Animatable\n     * @param onAnimationLoop defines a callback to call when animation loops\n     * @param isAdditive defines whether the animation should be evaluated additively\n     * @param playOrder defines the order in which this animatable should be processed in the list of active animatables (default: 0)\n     */\n    constructor(scene, \n    /** defines the target object */\n    target, \n    /** [0] defines the starting frame number (default is 0) */\n    fromFrame = 0, \n    /** [100] defines the ending frame number (default is 100) */\n    toFrame = 100, \n    /** [false] defines if the animation must loop (default is false)  */\n    loopAnimation = false, speedRatio = 1.0, \n    /** defines a callback to call when animation ends if it is not looping */\n    onAnimationEnd, animations, \n    /** defines a callback to call when animation loops */\n    onAnimationLoop, \n    /** [false] defines whether the animation should be evaluated additively */\n    isAdditive = false, \n    /** [0] defines the order in which this animatable should be processed in the list of active animatables (default: 0) */\n    playOrder = 0) {\n        this.target = target;\n        this.fromFrame = fromFrame;\n        this.toFrame = toFrame;\n        this.loopAnimation = loopAnimation;\n        this.onAnimationEnd = onAnimationEnd;\n        this.onAnimationLoop = onAnimationLoop;\n        this.isAdditive = isAdditive;\n        this.playOrder = playOrder;\n        this._localDelayOffset = null;\n        this._pausedDelay = null;\n        this._manualJumpDelay = null;\n        /** @hidden */\n        this._runtimeAnimations = new Array();\n        this._paused = false;\n        this._speedRatio = 1;\n        this._weight = -1.0;\n        this._previousWeight = -1.0;\n        this._syncRoot = null;\n        this._frameToSyncFromJump = null;\n        this._goToFrame = null;\n        /**\n         * Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.\n         * This will only apply for non looping animation (default is true)\n         */\n        this.disposeOnEnd = true;\n        /**\n         * Gets a boolean indicating if the animation has started\n         */\n        this.animationStarted = false;\n        /**\n         * Observer raised when the animation ends\n         */\n        this.onAnimationEndObservable = new Observable();\n        /**\n         * Observer raised when the animation loops\n         */\n        this.onAnimationLoopObservable = new Observable();\n        this._scene = scene;\n        if (animations) {\n            this.appendAnimations(target, animations);\n        }\n        this._speedRatio = speedRatio;\n        scene._activeAnimatables.push(this);\n    }\n    // Methods\n    /**\n     * Synchronize and normalize current Animatable with a source Animatable\n     * This is useful when using animation weights and when animations are not of the same length\n     * @param root defines the root Animatable to synchronize with (null to stop synchronizing)\n     * @returns the current Animatable\n     */\n    syncWith(root) {\n        this._syncRoot = root;\n        if (root) {\n            // Make sure this animatable will animate after the root\n            const index = this._scene._activeAnimatables.indexOf(this);\n            if (index > -1) {\n                this._scene._activeAnimatables.splice(index, 1);\n                this._scene._activeAnimatables.push(this);\n            }\n        }\n        return this;\n    }\n    /**\n     * Gets the list of runtime animations\n     * @returns an array of RuntimeAnimation\n     */\n    getAnimations() {\n        return this._runtimeAnimations;\n    }\n    /**\n     * Adds more animations to the current animatable\n     * @param target defines the target of the animations\n     * @param animations defines the new animations to add\n     */\n    appendAnimations(target, animations) {\n        for (let index = 0; index < animations.length; index++) {\n            const animation = animations[index];\n            const newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);\n            newRuntimeAnimation._onLoop = () => {\n                this.onAnimationLoopObservable.notifyObservers(this);\n                if (this.onAnimationLoop) {\n                    this.onAnimationLoop();\n                }\n            };\n            this._runtimeAnimations.push(newRuntimeAnimation);\n        }\n    }\n    /**\n     * Gets the source animation for a specific property\n     * @param property defines the property to look for\n     * @returns null or the source animation for the given property\n     */\n    getAnimationByTargetProperty(property) {\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n            if (runtimeAnimations[index].animation.targetProperty === property) {\n                return runtimeAnimations[index].animation;\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets the runtime animation for a specific property\n     * @param property defines the property to look for\n     * @returns null or the runtime animation for the given property\n     */\n    getRuntimeAnimationByTargetProperty(property) {\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n            if (runtimeAnimations[index].animation.targetProperty === property) {\n                return runtimeAnimations[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Resets the animatable to its original state\n     */\n    reset() {\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n            runtimeAnimations[index].reset(true);\n        }\n        this._localDelayOffset = null;\n        this._pausedDelay = null;\n    }\n    /**\n     * Allows the animatable to blend with current running animations\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\n     * @param blendingSpeed defines the blending speed to use\n     */\n    enableBlending(blendingSpeed) {\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n            runtimeAnimations[index].animation.enableBlending = true;\n            runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;\n        }\n    }\n    /**\n     * Disable animation blending\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\n     */\n    disableBlending() {\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n            runtimeAnimations[index].animation.enableBlending = false;\n        }\n    }\n    /**\n     * Jump directly to a given frame\n     * @param frame defines the frame to jump to\n     * @param useWeight defines whether the animation weight should be applied to the image to be jumped to (false by default)\n     */\n    goToFrame(frame, useWeight = false) {\n        const runtimeAnimations = this._runtimeAnimations;\n        if (runtimeAnimations[0]) {\n            const fps = runtimeAnimations[0].animation.framePerSecond;\n            this._frameToSyncFromJump = this._frameToSyncFromJump ?? runtimeAnimations[0].currentFrame;\n            const delay = this.speedRatio === 0 ? 0 : (((frame - this._frameToSyncFromJump) / fps) * 1000) / this.speedRatio;\n            this._manualJumpDelay = -delay;\n        }\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n            runtimeAnimations[index].goToFrame(frame, useWeight ? this._weight : -1);\n        }\n        this._goToFrame = frame;\n    }\n    /**\n     * Returns true if the animations for this animatable are paused\n     */\n    get paused() {\n        return this._paused;\n    }\n    /**\n     * Pause the animation\n     */\n    pause() {\n        if (this._paused) {\n            return;\n        }\n        this._paused = true;\n    }\n    /**\n     * Restart the animation\n     */\n    restart() {\n        this._paused = false;\n    }\n    _raiseOnAnimationEnd() {\n        if (this.onAnimationEnd) {\n            this.onAnimationEnd();\n        }\n        this.onAnimationEndObservable.notifyObservers(this);\n    }\n    /**\n     * Stop and delete the current animation\n     * @param animationName defines a string used to only stop some of the runtime animations instead of all\n     * @param targetMask a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\n     * @param useGlobalSplice if true, the animatables will be removed by the caller of this function (false by default)\n     * @param skipOnAnimationEnd defines if the system should not raise onAnimationEnd. Default is false\n     */\n    stop(animationName, targetMask, useGlobalSplice = false, skipOnAnimationEnd = false) {\n        if (animationName || targetMask) {\n            const idx = this._scene._activeAnimatables.indexOf(this);\n            if (idx > -1) {\n                const runtimeAnimations = this._runtimeAnimations;\n                for (let index = runtimeAnimations.length - 1; index >= 0; index--) {\n                    const runtimeAnimation = runtimeAnimations[index];\n                    if (animationName && runtimeAnimation.animation.name != animationName) {\n                        continue;\n                    }\n                    if (targetMask && !targetMask(runtimeAnimation.target)) {\n                        continue;\n                    }\n                    runtimeAnimation.dispose();\n                    runtimeAnimations.splice(index, 1);\n                }\n                if (runtimeAnimations.length == 0) {\n                    if (!useGlobalSplice) {\n                        this._scene._activeAnimatables.splice(idx, 1);\n                    }\n                    if (!skipOnAnimationEnd) {\n                        this._raiseOnAnimationEnd();\n                    }\n                }\n            }\n        }\n        else {\n            const index = this._scene._activeAnimatables.indexOf(this);\n            if (index > -1) {\n                if (!useGlobalSplice) {\n                    this._scene._activeAnimatables.splice(index, 1);\n                }\n                const runtimeAnimations = this._runtimeAnimations;\n                for (let index = 0; index < runtimeAnimations.length; index++) {\n                    runtimeAnimations[index].dispose();\n                }\n                this._runtimeAnimations.length = 0;\n                if (!skipOnAnimationEnd) {\n                    this._raiseOnAnimationEnd();\n                }\n            }\n        }\n    }\n    /**\n     * Wait asynchronously for the animation to end\n     * @returns a promise which will be fulfilled when the animation ends\n     */\n    async waitAsync() {\n        return await new Promise((resolve) => {\n            this.onAnimationEndObservable.add(() => {\n                resolve(this);\n            }, undefined, undefined, this, true);\n        });\n    }\n    /**\n     * @internal\n     */\n    _animate(delay) {\n        if (this._paused) {\n            this.animationStarted = false;\n            if (this._pausedDelay === null) {\n                this._pausedDelay = delay;\n            }\n            return true;\n        }\n        if (this._localDelayOffset === null) {\n            this._localDelayOffset = delay;\n            this._pausedDelay = null;\n        }\n        else if (this._pausedDelay !== null) {\n            this._localDelayOffset += delay - this._pausedDelay;\n            this._pausedDelay = null;\n        }\n        if (this._manualJumpDelay !== null) {\n            this._localDelayOffset += this.speedRatio < 0 ? -this._manualJumpDelay : this._manualJumpDelay;\n            this._manualJumpDelay = null;\n            this._frameToSyncFromJump = null;\n        }\n        this._goToFrame = null;\n        if (!Animatable.ProcessPausedAnimatables && this._weight === 0 && this._previousWeight === 0) {\n            // We consider that an animatable with a weight === 0 is \"actively\" paused\n            return true;\n        }\n        this._previousWeight = this._weight;\n        // Animating\n        let running = false;\n        const runtimeAnimations = this._runtimeAnimations;\n        let index;\n        for (index = 0; index < runtimeAnimations.length; index++) {\n            const animation = runtimeAnimations[index];\n            const isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);\n            running = running || isRunning;\n        }\n        this.animationStarted = running;\n        if (!running) {\n            if (this.disposeOnEnd) {\n                // Remove from active animatables\n                index = this._scene._activeAnimatables.indexOf(this);\n                this._scene._activeAnimatables.splice(index, 1);\n                // Dispose all runtime animations\n                for (index = 0; index < runtimeAnimations.length; index++) {\n                    runtimeAnimations[index].dispose();\n                }\n            }\n            this._raiseOnAnimationEnd();\n            if (this.disposeOnEnd) {\n                this.onAnimationEnd = null;\n                this.onAnimationLoop = null;\n                this.onAnimationLoopObservable.clear();\n                this.onAnimationEndObservable.clear();\n            }\n        }\n        return running;\n    }\n}\n/**\n * If true, the animatable will be processed even if it is considered actively paused (weight of 0 and previous weight of 0).\n * This can be used to force the full processing of paused animatables in the animation engine.\n * Default is false.\n */\nAnimatable.ProcessPausedAnimatables = false;\n/** @internal */\nfunction ProcessLateAnimationBindingsForMatrices(holder) {\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\n        return holder.originalValue;\n    }\n    let normalizer = 1.0;\n    const finalPosition = TmpVectors.Vector3[0];\n    const finalScaling = TmpVectors.Vector3[1];\n    const finalQuaternion = TmpVectors.Quaternion[0];\n    let startIndex = 0;\n    const originalAnimation = holder.animations[0];\n    const originalValue = holder.originalValue;\n    let scale = 1;\n    let skipOverride = false;\n    if (holder.totalWeight < 1.0) {\n        // We need to mix the original value in\n        scale = 1.0 - holder.totalWeight;\n        originalValue.decompose(finalScaling, finalQuaternion, finalPosition);\n    }\n    else {\n        startIndex = 1;\n        // We need to normalize the weights\n        normalizer = holder.totalWeight;\n        scale = originalAnimation.weight / normalizer;\n        if (scale == 1) {\n            if (holder.totalAdditiveWeight) {\n                skipOverride = true;\n            }\n            else {\n                return originalAnimation.currentValue;\n            }\n        }\n        originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);\n    }\n    // Add up the override animations\n    if (!skipOverride) {\n        finalScaling.scaleInPlace(scale);\n        finalPosition.scaleInPlace(scale);\n        finalQuaternion.scaleInPlace(scale);\n        for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\n            const runtimeAnimation = holder.animations[animIndex];\n            if (runtimeAnimation.weight === 0) {\n                continue;\n            }\n            scale = runtimeAnimation.weight / normalizer;\n            const currentPosition = TmpVectors.Vector3[2];\n            const currentScaling = TmpVectors.Vector3[3];\n            const currentQuaternion = TmpVectors.Quaternion[1];\n            runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\n            currentScaling.scaleAndAddToRef(scale, finalScaling);\n            currentQuaternion.scaleAndAddToRef(Quaternion.Dot(finalQuaternion, currentQuaternion) > 0 ? scale : -scale, finalQuaternion);\n            currentPosition.scaleAndAddToRef(scale, finalPosition);\n        }\n        finalQuaternion.normalize();\n    }\n    // Add up the additive animations\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\n        const runtimeAnimation = holder.additiveAnimations[animIndex];\n        if (runtimeAnimation.weight === 0) {\n            continue;\n        }\n        const currentPosition = TmpVectors.Vector3[2];\n        const currentScaling = TmpVectors.Vector3[3];\n        const currentQuaternion = TmpVectors.Quaternion[1];\n        runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\n        currentScaling.multiplyToRef(finalScaling, currentScaling);\n        Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);\n        finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);\n        Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);\n        currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);\n    }\n    const workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();\n    Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);\n    return workValue;\n}\n/** @internal */\nfunction ProcessLateAnimationBindingsForQuaternions(holder, refQuaternion) {\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\n        return refQuaternion;\n    }\n    const originalAnimation = holder.animations[0];\n    const originalValue = holder.originalValue;\n    let cumulativeQuaternion = refQuaternion;\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {\n        cumulativeQuaternion.copyFrom(originalValue);\n    }\n    else if (holder.animations.length === 1) {\n        Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1.0, holder.totalWeight), cumulativeQuaternion);\n        if (holder.totalAdditiveWeight === 0) {\n            return cumulativeQuaternion;\n        }\n    }\n    else if (holder.animations.length > 1) {\n        // Add up the override animations\n        let normalizer = 1.0;\n        let quaternions;\n        let weights;\n        if (holder.totalWeight < 1.0) {\n            const scale = 1.0 - holder.totalWeight;\n            quaternions = [];\n            weights = [];\n            quaternions.push(originalValue);\n            weights.push(scale);\n        }\n        else {\n            if (holder.animations.length === 2) {\n                // Slerp as soon as we can\n                Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);\n                if (holder.totalAdditiveWeight === 0) {\n                    return refQuaternion;\n                }\n            }\n            quaternions = [];\n            weights = [];\n            normalizer = holder.totalWeight;\n        }\n        for (let animIndex = 0; animIndex < holder.animations.length; animIndex++) {\n            const runtimeAnimation = holder.animations[animIndex];\n            quaternions.push(runtimeAnimation.currentValue);\n            weights.push(runtimeAnimation.weight / normalizer);\n        }\n        // https://gamedev.stackexchange.com/questions/62354/method-for-interpolation-between-3-quaternions\n        let cumulativeAmount = 0;\n        for (let index = 0; index < quaternions.length;) {\n            if (!index) {\n                Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);\n                cumulativeQuaternion = refQuaternion;\n                cumulativeAmount = weights[index] + weights[index + 1];\n                index += 2;\n                continue;\n            }\n            cumulativeAmount += weights[index];\n            Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);\n            index++;\n        }\n    }\n    // Add up the additive animations\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\n        const runtimeAnimation = holder.additiveAnimations[animIndex];\n        if (runtimeAnimation.weight === 0) {\n            continue;\n        }\n        cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);\n        Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);\n    }\n    return cumulativeQuaternion;\n}\n/** @internal */\nfunction ProcessLateAnimationBindings(scene) {\n    if (!scene._registeredForLateAnimationBindings.length) {\n        return;\n    }\n    for (let index = 0; index < scene._registeredForLateAnimationBindings.length; index++) {\n        const target = scene._registeredForLateAnimationBindings.data[index];\n        for (const path in target._lateAnimationHolders) {\n            const holder = target._lateAnimationHolders[path];\n            const originalAnimation = holder.animations[0];\n            const originalValue = holder.originalValue;\n            if (originalValue === undefined || originalValue === null) {\n                continue;\n            }\n            const matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m; // ie. data is matrix\n            let finalValue = target[path];\n            if (matrixDecomposeMode) {\n                finalValue = ProcessLateAnimationBindingsForMatrices(holder);\n            }\n            else {\n                const quaternionMode = originalValue.w !== undefined;\n                if (quaternionMode) {\n                    finalValue = ProcessLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());\n                }\n                else {\n                    let startIndex = 0;\n                    let normalizer = 1.0;\n                    const originalAnimationIsLoopRelativeFromCurrent = originalAnimation && originalAnimation._animationState.loopMode === Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;\n                    if (holder.totalWeight < 1.0) {\n                        // We need to mix the original value in\n                        if (originalAnimationIsLoopRelativeFromCurrent) {\n                            finalValue = originalValue.clone ? originalValue.clone() : originalValue;\n                        }\n                        else if (originalAnimation && originalValue.scale) {\n                            finalValue = originalValue.scale(1.0 - holder.totalWeight);\n                        }\n                        else if (originalAnimation) {\n                            finalValue = originalValue * (1.0 - holder.totalWeight);\n                        }\n                        else if (originalValue.clone) {\n                            finalValue = originalValue.clone();\n                        }\n                        else {\n                            finalValue = originalValue;\n                        }\n                    }\n                    else if (originalAnimation) {\n                        // We need to normalize the weights\n                        normalizer = holder.totalWeight;\n                        const scale = originalAnimation.weight / normalizer;\n                        if (scale !== 1) {\n                            if (originalAnimation.currentValue.scale) {\n                                finalValue = originalAnimation.currentValue.scale(scale);\n                            }\n                            else {\n                                finalValue = originalAnimation.currentValue * scale;\n                            }\n                        }\n                        else {\n                            finalValue = originalAnimation.currentValue;\n                        }\n                        if (originalAnimationIsLoopRelativeFromCurrent) {\n                            if (finalValue.addToRef) {\n                                finalValue.addToRef(originalValue, finalValue);\n                            }\n                            else {\n                                finalValue += originalValue;\n                            }\n                        }\n                        startIndex = 1;\n                    }\n                    // Add up the override animations\n                    for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\n                        const runtimeAnimation = holder.animations[animIndex];\n                        const scale = runtimeAnimation.weight / normalizer;\n                        if (!scale) {\n                            continue;\n                        }\n                        else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\n                        }\n                        else {\n                            finalValue += runtimeAnimation.currentValue * scale;\n                        }\n                    }\n                    // Add up the additive animations\n                    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\n                        const runtimeAnimation = holder.additiveAnimations[animIndex];\n                        const scale = runtimeAnimation.weight;\n                        if (!scale) {\n                            continue;\n                        }\n                        else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\n                        }\n                        else {\n                            finalValue += runtimeAnimation.currentValue * scale;\n                        }\n                    }\n                }\n            }\n            target[path] = finalValue;\n        }\n        target._lateAnimationHolders = {};\n    }\n    scene._registeredForLateAnimationBindings.reset();\n}\n/** @internal */\nexport function RegisterTargetForLateAnimationBinding(scene, runtimeAnimation, originalValue) {\n    const target = runtimeAnimation.target;\n    scene._registeredForLateAnimationBindings.pushNoDuplicate(target);\n    if (!target._lateAnimationHolders) {\n        target._lateAnimationHolders = {};\n    }\n    if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\n        target._lateAnimationHolders[runtimeAnimation.targetPath] = {\n            totalWeight: 0,\n            totalAdditiveWeight: 0,\n            animations: [],\n            additiveAnimations: [],\n            originalValue: originalValue,\n        };\n    }\n    if (runtimeAnimation.isAdditive) {\n        target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\n    }\n    else {\n        target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\n    }\n}\n/**\n * Initialize all the inter dependecies between the animations and Scene and Bone\n * @param sceneClass defines the scene prototype to use\n * @param boneClass defines the bone prototype to use\n */\nexport function AddAnimationExtensions(sceneClass, boneClass) {\n    if (boneClass) {\n        boneClass.prototype.copyAnimationRange = function (source, rangeName, frameOffset, rescaleAsRequired = false, skelDimensionsRatio = null) {\n            // all animation may be coming from a library skeleton, so may need to create animation\n            if (this.animations.length === 0) {\n                this.animations.push(new Animation(this.name, \"_matrix\", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));\n                this.animations[0].setKeys([]);\n            }\n            // get animation info / verify there is such a range from the source bone\n            const sourceRange = source.animations[0].getRange(rangeName);\n            if (!sourceRange) {\n                return false;\n            }\n            const from = sourceRange.from;\n            const to = sourceRange.to;\n            const sourceKeys = source.animations[0].getKeys();\n            // rescaling prep\n            const sourceBoneLength = source.length;\n            const sourceParent = source.getParent();\n            const parent = this.getParent();\n            const parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;\n            const parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;\n            const dimensionsScalingReqd = rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);\n            const destKeys = this.animations[0].getKeys();\n            // loop vars declaration\n            let orig;\n            let origTranslation;\n            let mat;\n            for (let key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {\n                orig = sourceKeys[key];\n                if (orig.frame >= from && orig.frame <= to) {\n                    if (rescaleAsRequired) {\n                        mat = orig.value.clone();\n                        // scale based on parent ratio, when bone has parent\n                        if (parentScalingReqd) {\n                            origTranslation = mat.getTranslation();\n                            mat.setTranslation(origTranslation.scaleInPlace(parentRatio));\n                            // scale based on skeleton dimension ratio when root bone, and value is passed\n                        }\n                        else if (dimensionsScalingReqd && skelDimensionsRatio) {\n                            origTranslation = mat.getTranslation();\n                            mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio));\n                            // use original when root bone, and no data for skelDimensionsRatio\n                        }\n                        else {\n                            mat = orig.value;\n                        }\n                    }\n                    else {\n                        mat = orig.value;\n                    }\n                    destKeys.push({ frame: orig.frame + frameOffset, value: mat });\n                }\n            }\n            this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);\n            return true;\n        };\n    }\n    if (!sceneClass) {\n        return;\n    }\n    sceneClass.prototype._animate = function (customDeltaTime) {\n        if (!this.animationsEnabled) {\n            return;\n        }\n        // Getting time\n        const now = PrecisionDate.Now;\n        if (!this._animationTimeLast) {\n            if (this._pendingData.length > 0) {\n                return;\n            }\n            this._animationTimeLast = now;\n        }\n        this.deltaTime = customDeltaTime !== undefined ? customDeltaTime : this.useConstantAnimationDeltaTime ? 16.0 : (now - this._animationTimeLast) * this.animationTimeScale;\n        this._animationTimeLast = now;\n        const animatables = this._activeAnimatables;\n        if (animatables.length === 0) {\n            return;\n        }\n        this._animationTime += this.deltaTime;\n        const animationTime = this._animationTime;\n        for (let index = 0; index < animatables.length; index++) {\n            const animatable = animatables[index];\n            if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {\n                index--; // Array was updated\n            }\n        }\n        // Late animation bindings\n        ProcessLateAnimationBindings(this);\n    };\n    sceneClass.prototype.sortActiveAnimatables = function () {\n        this._activeAnimatables.sort((a, b) => {\n            return a.playOrder - b.playOrder;\n        });\n    };\n    sceneClass.prototype.beginWeightedAnimation = function (target, from, to, weight = 1.0, loop, speedRatio = 1.0, onAnimationEnd, animatable, targetMask, onAnimationLoop, isAdditive = false) {\n        const returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);\n        returnedAnimatable.weight = weight;\n        return returnedAnimatable;\n    };\n    sceneClass.prototype.beginAnimation = function (target, from, to, loop, speedRatio = 1.0, onAnimationEnd, animatable, stopCurrent = true, targetMask, onAnimationLoop, isAdditive = false) {\n        // get speed speedRatio, to and from, based on the sign and value(s)\n        if (speedRatio < 0) {\n            const tmp = from;\n            from = to;\n            to = tmp;\n            speedRatio = -speedRatio;\n        }\n        // if from > to switch speed ratio\n        if (from > to) {\n            speedRatio = -speedRatio;\n        }\n        if (stopCurrent) {\n            this.stopAnimation(target, undefined, targetMask);\n        }\n        if (!animatable) {\n            animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, undefined, onAnimationLoop, isAdditive);\n        }\n        const shouldRunTargetAnimations = targetMask ? targetMask(target) : true;\n        // Local animations\n        if (target.animations && shouldRunTargetAnimations) {\n            animatable.appendAnimations(target, target.animations);\n        }\n        // Children animations\n        if (target.getAnimatables) {\n            const animatables = target.getAnimatables();\n            for (let index = 0; index < animatables.length; index++) {\n                this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);\n            }\n        }\n        animatable.reset();\n        return animatable;\n    };\n    sceneClass.prototype.beginHierarchyAnimation = function (target, directDescendantsOnly, from, to, loop, speedRatio = 1.0, onAnimationEnd, animatable, stopCurrent = true, targetMask, onAnimationLoop, isAdditive = false) {\n        const children = target.getDescendants(directDescendantsOnly);\n        const result = [];\n        result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\n        for (const child of children) {\n            result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\n        }\n        return result;\n    };\n    sceneClass.prototype.beginDirectAnimation = function (target, animations, from, to, loop, speedRatio = 1.0, onAnimationEnd, onAnimationLoop, isAdditive = false) {\n        // get speed speedRatio, to and from, based on the sign and value(s)\n        if (speedRatio < 0) {\n            const tmp = from;\n            from = to;\n            to = tmp;\n            speedRatio = -speedRatio;\n        }\n        // if from > to switch speed ratio\n        if (from > to) {\n            speedRatio = -speedRatio;\n        }\n        const animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);\n        return animatable;\n    };\n    sceneClass.prototype.beginDirectHierarchyAnimation = function (target, directDescendantsOnly, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive = false) {\n        const children = target.getDescendants(directDescendantsOnly);\n        const result = [];\n        result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\n        for (const child of children) {\n            result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\n        }\n        return result;\n    };\n    sceneClass.prototype.getAnimatableByTarget = function (target) {\n        for (let index = 0; index < this._activeAnimatables.length; index++) {\n            if (this._activeAnimatables[index].target === target) {\n                return this._activeAnimatables[index];\n            }\n        }\n        return null;\n    };\n    sceneClass.prototype.getAllAnimatablesByTarget = function (target) {\n        const result = [];\n        for (let index = 0; index < this._activeAnimatables.length; index++) {\n            if (this._activeAnimatables[index].target === target) {\n                result.push(this._activeAnimatables[index]);\n            }\n        }\n        return result;\n    };\n    sceneClass.prototype.stopAnimation = function (target, animationName, targetMask) {\n        const animatables = this.getAllAnimatablesByTarget(target);\n        for (const animatable of animatables) {\n            animatable.stop(animationName, targetMask);\n        }\n    };\n    sceneClass.prototype.stopAllAnimations = function () {\n        if (this._activeAnimatables) {\n            for (let i = 0; i < this._activeAnimatables.length; i++) {\n                this._activeAnimatables[i].stop(undefined, undefined, true);\n            }\n            this._activeAnimatables.length = 0;\n        }\n        for (const group of this.animationGroups) {\n            group.stop();\n        }\n    };\n}\n//# sourceMappingURL=animatable.core.js.map","import { Bone } from \"../Bones/bone\";\nimport { AddAnimationExtensions } from \"./animatable.core\";\nimport { Scene } from \"core/scene\";\nexport * from \"./animatable.core\";\n// Connect everything!\nAddAnimationExtensions(Scene, Bone);\n//# sourceMappingURL=animatable.js.map","import { Animation } from \"./animation\";\nimport { Observable } from \"../Misc/observable\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { Tags } from \"../Misc/tags\";\nimport \"./animatable\";\nimport { UniqueIdGenerator } from \"core/Misc/uniqueIdGenerator\";\n/**\n * This class defines the direct association between an animation and a target\n */\nexport class TargetedAnimation {\n    /**\n     * Returns the string \"TargetedAnimation\"\n     * @returns \"TargetedAnimation\"\n     */\n    getClassName() {\n        return \"TargetedAnimation\";\n    }\n    /**\n     * Creates a new targeted animation\n     * @param parent The animation group to which the animation belongs\n     */\n    constructor(parent) {\n        this.parent = parent;\n        /**\n         * Gets or sets the unique id of the targeted animation\n         */\n        this.uniqueId = UniqueIdGenerator.UniqueId;\n    }\n    /**\n     * Serialize the object\n     * @returns the JSON object representing the current entity\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.animation = this.animation.serialize();\n        serializationObject.targetId = this.target.id;\n        return serializationObject;\n    }\n}\n/**\n * Use this class to create coordinated animations on multiple targets\n */\nexport class AnimationGroup {\n    /**\n     * Gets or sets the mask associated with this animation group. This mask is used to filter which objects should be animated.\n     */\n    get mask() {\n        return this._mask;\n    }\n    set mask(value) {\n        if (this._mask === value) {\n            return;\n        }\n        this._mask = value;\n        this.syncWithMask(true);\n    }\n    /**\n     * Makes sure that the animations are either played or stopped according to the animation group mask.\n     * Note however that the call won't have any effect if the animation group has not been started yet.\n     * @param forceUpdate If true, forces to loop over the animatables even if no mask is defined (used internally, you shouldn't need to use it). Default: false.\n     */\n    syncWithMask(forceUpdate = false) {\n        if (!this.mask && !forceUpdate) {\n            this._numActiveAnimatables = this._targetedAnimations.length;\n            return;\n        }\n        this._numActiveAnimatables = 0;\n        for (let i = 0; i < this._animatables.length; ++i) {\n            const animatable = this._animatables[i];\n            if (!this.mask || this.mask.disabled || this.mask.retainsTarget(animatable.target.name)) {\n                this._numActiveAnimatables++;\n                if (animatable.paused) {\n                    animatable.restart();\n                }\n            }\n            else {\n                if (!animatable.paused) {\n                    animatable.pause();\n                }\n            }\n        }\n    }\n    /**\n     * Removes all animations for the targets not retained by the animation group mask.\n     * Use this function if you know you won't need those animations anymore and if you want to free memory.\n     */\n    removeUnmaskedAnimations() {\n        if (!this.mask || this.mask.disabled) {\n            return;\n        }\n        // Removes all animatables (in case the animation group has already been started)\n        for (let i = 0; i < this._animatables.length; ++i) {\n            const animatable = this._animatables[i];\n            if (!this.mask.retainsTarget(animatable.target.name)) {\n                animatable.stop();\n                this._animatables.splice(i, 1);\n                --i;\n            }\n        }\n        // Removes the targeted animations\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\n            const targetedAnimation = this._targetedAnimations[index];\n            if (!this.mask.retainsTarget(targetedAnimation.target.name)) {\n                this._targetedAnimations.splice(index, 1);\n                --index;\n            }\n        }\n    }\n    /**\n     * Gets or sets the first frame\n     */\n    get from() {\n        return this._from;\n    }\n    set from(value) {\n        if (this._from === value) {\n            return;\n        }\n        this._from = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.fromFrame = this._from;\n        }\n    }\n    /**\n     * Gets or sets the last frame\n     */\n    get to() {\n        return this._to;\n    }\n    set to(value) {\n        if (this._to === value) {\n            return;\n        }\n        this._to = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.toFrame = this._to;\n        }\n    }\n    /**\n     * Define if the animations are started\n     */\n    get isStarted() {\n        return this._isStarted;\n    }\n    /**\n     * Gets a value indicating that the current group is playing\n     */\n    get isPlaying() {\n        return this._isStarted && !this._isPaused;\n    }\n    /**\n     * Gets or sets the speed ratio to use for all animations\n     */\n    get speedRatio() {\n        return this._speedRatio;\n    }\n    /**\n     * Gets or sets the speed ratio to use for all animations\n     */\n    set speedRatio(value) {\n        if (this._speedRatio === value) {\n            return;\n        }\n        this._speedRatio = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.speedRatio = this._speedRatio;\n        }\n    }\n    /**\n     * Gets or sets if all animations should loop or not\n     */\n    get loopAnimation() {\n        return this._loopAnimation;\n    }\n    set loopAnimation(value) {\n        if (this._loopAnimation === value) {\n            return;\n        }\n        this._loopAnimation = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.loopAnimation = this._loopAnimation;\n        }\n    }\n    /**\n     * Gets or sets if all animations should be evaluated additively\n     */\n    get isAdditive() {\n        return this._isAdditive;\n    }\n    set isAdditive(value) {\n        if (this._isAdditive === value) {\n            return;\n        }\n        this._isAdditive = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.isAdditive = this._isAdditive;\n        }\n    }\n    /**\n     * Gets or sets the weight to apply to all animations of the group\n     */\n    get weight() {\n        return this._weight;\n    }\n    set weight(value) {\n        if (this._weight === value) {\n            return;\n        }\n        this._weight = value;\n        this.setWeightForAllAnimatables(this._weight);\n    }\n    /**\n     * Gets the targeted animations for this animation group\n     */\n    get targetedAnimations() {\n        return this._targetedAnimations;\n    }\n    /**\n     * returning the list of animatables controlled by this animation group.\n     */\n    get animatables() {\n        return this._animatables;\n    }\n    /**\n     * Gets the list of target animations\n     */\n    get children() {\n        return this._targetedAnimations;\n    }\n    /**\n     * Gets or sets the order of play of the animation group (default: 0)\n     */\n    get playOrder() {\n        return this._playOrder;\n    }\n    set playOrder(value) {\n        if (this._playOrder === value) {\n            return;\n        }\n        this._playOrder = value;\n        if (this._animatables.length > 0) {\n            for (let i = 0; i < this._animatables.length; i++) {\n                this._animatables[i].playOrder = this._playOrder;\n            }\n            this._scene.sortActiveAnimatables();\n        }\n    }\n    /**\n     * Allows the animations of the animation group to blend with current running animations\n     * Note that a null value means that each animation will use their own existing blending configuration (Animation.enableBlending)\n     */\n    get enableBlending() {\n        return this._enableBlending;\n    }\n    set enableBlending(value) {\n        if (this._enableBlending === value) {\n            return;\n        }\n        this._enableBlending = value;\n        if (value !== null) {\n            for (let i = 0; i < this._targetedAnimations.length; ++i) {\n                this._targetedAnimations[i].animation.enableBlending = value;\n            }\n        }\n    }\n    /**\n     * Gets or sets the animation blending speed\n     * Note that a null value means that each animation will use their own existing blending configuration (Animation.blendingSpeed)\n     */\n    get blendingSpeed() {\n        return this._blendingSpeed;\n    }\n    set blendingSpeed(value) {\n        if (this._blendingSpeed === value) {\n            return;\n        }\n        this._blendingSpeed = value;\n        if (value !== null) {\n            for (let i = 0; i < this._targetedAnimations.length; ++i) {\n                this._targetedAnimations[i].animation.blendingSpeed = value;\n            }\n        }\n    }\n    /**\n     * Gets the length (in seconds) of the animation group\n     * This function assumes that all animations are played at the same framePerSecond speed!\n     * Note: you can only call this method after you've added at least one targeted animation!\n     * @param from Starting frame range (default is AnimationGroup.from)\n     * @param to Ending frame range (default is AnimationGroup.to)\n     * @returns The length in seconds\n     */\n    getLength(from, to) {\n        from = from ?? this._from;\n        to = to ?? this._to;\n        const fps = this.targetedAnimations[0].animation.framePerSecond * this._speedRatio;\n        return (to - from) / fps;\n    }\n    /**\n     * Merge the array of animation groups into a new animation group\n     * @param animationGroups List of animation groups to merge\n     * @param disposeSource If true, animation groups will be disposed after being merged (default: true)\n     * @param normalize If true, animation groups will be normalized before being merged, so that all animations have the same \"from\" and \"to\" frame (default: false)\n     * @param weight Weight for the new animation group. If not provided, it will inherit the weight from the first animation group of the array\n     * @returns The new animation group or null if no animation groups were passed\n     */\n    static MergeAnimationGroups(animationGroups, disposeSource = true, normalize = false, weight) {\n        if (animationGroups.length === 0) {\n            return null;\n        }\n        weight = weight ?? animationGroups[0].weight;\n        let beginFrame = Number.MAX_VALUE;\n        let endFrame = -Number.MAX_VALUE;\n        if (normalize) {\n            for (const animationGroup of animationGroups) {\n                if (animationGroup.from < beginFrame) {\n                    beginFrame = animationGroup.from;\n                }\n                if (animationGroup.to > endFrame) {\n                    endFrame = animationGroup.to;\n                }\n            }\n        }\n        const mergedAnimationGroup = new AnimationGroup(animationGroups[0].name + \"_merged\", animationGroups[0]._scene, weight);\n        for (const animationGroup of animationGroups) {\n            if (normalize) {\n                animationGroup.normalize(beginFrame, endFrame);\n            }\n            for (const targetedAnimation of animationGroup.targetedAnimations) {\n                mergedAnimationGroup.addTargetedAnimation(targetedAnimation.animation, targetedAnimation.target);\n            }\n            if (disposeSource) {\n                animationGroup.dispose();\n            }\n        }\n        return mergedAnimationGroup;\n    }\n    /**\n     * Gets the scene the animation group belongs to\n     * @returns The scene the animation group belongs to\n     */\n    getScene() {\n        return this._scene;\n    }\n    /**\n     * Instantiates a new Animation Group.\n     * This helps managing several animations at once.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/groupAnimations\n     * @param name Defines the name of the group\n     * @param scene Defines the scene the group belongs to\n     * @param weight Defines the weight to use for animations in the group (-1.0 by default, meaning \"no weight\")\n     * @param playOrder Defines the order of play of the animation group (default is 0)\n     */\n    constructor(\n    /** The name of the animation group */\n    name, scene = null, weight = -1, playOrder = 0) {\n        this.name = name;\n        this._targetedAnimations = new Array();\n        this._animatables = new Array();\n        this._from = Number.MAX_VALUE;\n        this._to = -Number.MAX_VALUE;\n        this._speedRatio = 1;\n        this._loopAnimation = false;\n        this._isAdditive = false;\n        this._weight = -1;\n        this._playOrder = 0;\n        this._enableBlending = null;\n        this._blendingSpeed = null;\n        this._numActiveAnimatables = 0;\n        this._shouldStart = true;\n        /** @internal */\n        this._parentContainer = null;\n        /**\n         * This observable will notify when one animation have ended\n         */\n        this.onAnimationEndObservable = new Observable();\n        /**\n         * Observer raised when one animation loops\n         */\n        this.onAnimationLoopObservable = new Observable();\n        /**\n         * Observer raised when all animations have looped\n         */\n        this.onAnimationGroupLoopObservable = new Observable();\n        /**\n         * This observable will notify when all animations have ended.\n         */\n        this.onAnimationGroupEndObservable = new Observable();\n        /**\n         * This observable will notify when all animations have paused.\n         */\n        this.onAnimationGroupPauseObservable = new Observable();\n        /**\n         * This observable will notify when all animations are playing.\n         */\n        this.onAnimationGroupPlayObservable = new Observable();\n        /**\n         * Gets or sets an object used to store user defined information for the node\n         */\n        this.metadata = null;\n        this._mask = null;\n        this._animationLoopFlags = [];\n        this._scene = scene || EngineStore.LastCreatedScene;\n        this._weight = weight;\n        this._playOrder = playOrder;\n        this.uniqueId = this._scene.getUniqueId();\n        this._scene.addAnimationGroup(this);\n    }\n    /**\n     * Add an animation (with its target) in the group\n     * @param animation defines the animation we want to add\n     * @param target defines the target of the animation\n     * @returns the TargetedAnimation object\n     */\n    addTargetedAnimation(animation, target) {\n        const targetedAnimation = new TargetedAnimation(this);\n        targetedAnimation.animation = animation;\n        targetedAnimation.target = target;\n        const keys = animation.getKeys();\n        if (this._from > keys[0].frame) {\n            this._from = keys[0].frame;\n        }\n        if (this._to < keys[keys.length - 1].frame) {\n            this._to = keys[keys.length - 1].frame;\n        }\n        if (this._enableBlending !== null) {\n            animation.enableBlending = this._enableBlending;\n        }\n        if (this._blendingSpeed !== null) {\n            animation.blendingSpeed = this._blendingSpeed;\n        }\n        this._targetedAnimations.push(targetedAnimation);\n        this._shouldStart = true;\n        return targetedAnimation;\n    }\n    /**\n     * Remove an animation from the group\n     * @param animation defines the animation we want to remove\n     */\n    removeTargetedAnimation(animation) {\n        for (let index = this._targetedAnimations.length - 1; index > -1; index--) {\n            const targetedAnimation = this._targetedAnimations[index];\n            if (targetedAnimation.animation === animation) {\n                this._targetedAnimations.splice(index, 1);\n            }\n        }\n    }\n    /**\n     * This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame\n     * It can add constant keys at begin or end\n     * @param beginFrame defines the new begin frame for all animations or the smallest begin frame of all animations if null (defaults to null)\n     * @param endFrame defines the new end frame for all animations or the largest end frame of all animations if null (defaults to null)\n     * @returns the animation group\n     */\n    normalize(beginFrame = null, endFrame = null) {\n        if (beginFrame == null) {\n            beginFrame = this._from;\n        }\n        if (endFrame == null) {\n            endFrame = this._to;\n        }\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\n            const targetedAnimation = this._targetedAnimations[index];\n            const keys = targetedAnimation.animation.getKeys();\n            const startKey = keys[0];\n            const endKey = keys[keys.length - 1];\n            if (startKey.frame > beginFrame) {\n                const newKey = {\n                    frame: beginFrame,\n                    value: startKey.value,\n                    inTangent: startKey.inTangent,\n                    outTangent: startKey.outTangent,\n                    interpolation: startKey.interpolation,\n                };\n                keys.splice(0, 0, newKey);\n            }\n            if (endKey.frame < endFrame) {\n                const newKey = {\n                    frame: endFrame,\n                    value: endKey.value,\n                    inTangent: endKey.inTangent,\n                    outTangent: endKey.outTangent,\n                    interpolation: endKey.interpolation,\n                };\n                keys.push(newKey);\n            }\n        }\n        this._from = beginFrame;\n        this._to = endFrame;\n        return this;\n    }\n    _processLoop(animatable, targetedAnimation, index) {\n        animatable.onAnimationLoop = () => {\n            this.onAnimationLoopObservable.notifyObservers(targetedAnimation);\n            if (this._animationLoopFlags[index]) {\n                return;\n            }\n            this._animationLoopFlags[index] = true;\n            this._animationLoopCount++;\n            if (this._animationLoopCount === this._numActiveAnimatables) {\n                this.onAnimationGroupLoopObservable.notifyObservers(this);\n                this._animationLoopCount = 0;\n                this._animationLoopFlags.length = 0;\n            }\n        };\n    }\n    /**\n     * Start all animations on given targets\n     * @param loop defines if animations must loop\n     * @param speedRatio defines the ratio to apply to animation speed (1 by default)\n     * @param from defines the from key (optional)\n     * @param to defines the to key (optional)\n     * @param isAdditive defines the additive state for the resulting animatables (optional)\n     * @returns the current animation group\n     */\n    start(loop = false, speedRatio = 1, from, to, isAdditive) {\n        if (this._isStarted || this._targetedAnimations.length === 0) {\n            return this;\n        }\n        this._loopAnimation = loop;\n        this._shouldStart = false;\n        this._animationLoopCount = 0;\n        this._animationLoopFlags.length = 0;\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\n            const targetedAnimation = this._targetedAnimations[index];\n            const animatable = this._scene.beginDirectAnimation(targetedAnimation.target, [targetedAnimation.animation], from !== undefined ? from : this._from, to !== undefined ? to : this._to, loop, speedRatio, undefined, undefined, isAdditive !== undefined ? isAdditive : this._isAdditive);\n            animatable.weight = this._weight;\n            animatable.playOrder = this._playOrder;\n            animatable.onAnimationEnd = () => {\n                this.onAnimationEndObservable.notifyObservers(targetedAnimation);\n                this._checkAnimationGroupEnded(animatable);\n            };\n            this._processLoop(animatable, targetedAnimation, index);\n            this._animatables.push(animatable);\n        }\n        this.syncWithMask();\n        this._scene.sortActiveAnimatables();\n        this._speedRatio = speedRatio;\n        this._isStarted = true;\n        this._isPaused = false;\n        this.onAnimationGroupPlayObservable.notifyObservers(this);\n        return this;\n    }\n    /**\n     * Pause all animations\n     * @returns the animation group\n     */\n    pause() {\n        if (!this._isStarted) {\n            return this;\n        }\n        this._isPaused = true;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.pause();\n        }\n        this.onAnimationGroupPauseObservable.notifyObservers(this);\n        return this;\n    }\n    /**\n     * Play all animations to initial state\n     * This function will start() the animations if they were not started or will restart() them if they were paused\n     * @param loop defines if animations must loop\n     * @returns the animation group\n     */\n    play(loop) {\n        // only if there are animatable available\n        if (this.isStarted && this._animatables.length && !this._shouldStart) {\n            if (loop !== undefined) {\n                this.loopAnimation = loop;\n            }\n            this.restart();\n        }\n        else {\n            this.stop();\n            this.start(loop, this._speedRatio);\n        }\n        return this;\n    }\n    /**\n     * Reset all animations to initial state\n     * @returns the animation group\n     */\n    reset() {\n        if (!this._isStarted) {\n            this.play();\n            this.goToFrame(0);\n            this.stop(true);\n            return this;\n        }\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.reset();\n        }\n        return this;\n    }\n    /**\n     * Restart animations from after pausing it\n     * @returns the animation group\n     */\n    restart() {\n        if (!this._isStarted) {\n            return this;\n        }\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.restart();\n        }\n        this.syncWithMask();\n        this._isPaused = false;\n        this.onAnimationGroupPlayObservable.notifyObservers(this);\n        return this;\n    }\n    /**\n     * Stop all animations\n     * @param skipOnAnimationEnd defines if the system should not raise onAnimationEnd. Default is false\n     * @returns the animation group\n     */\n    stop(skipOnAnimationEnd = false) {\n        if (!this._isStarted) {\n            return this;\n        }\n        const list = this._animatables.slice();\n        for (let index = 0; index < list.length; index++) {\n            list[index].stop(undefined, undefined, true, skipOnAnimationEnd);\n        }\n        // We will take care of removing all stopped animatables\n        let curIndex = 0;\n        for (let index = 0; index < this._scene._activeAnimatables.length; index++) {\n            const animatable = this._scene._activeAnimatables[index];\n            if (animatable._runtimeAnimations.length > 0) {\n                this._scene._activeAnimatables[curIndex++] = animatable;\n            }\n            else if (skipOnAnimationEnd) {\n                // We normally rely on the onAnimationEnd callback (assigned in the start function) to be notified when an animatable\n                // ends and should be removed from the active animatables array. However, if the animatable is stopped with the skipOnAnimationEnd\n                // flag set to true, then we need to explicitly remove it from the active animatables array.\n                this._checkAnimationGroupEnded(animatable, skipOnAnimationEnd);\n            }\n        }\n        this._scene._activeAnimatables.length = curIndex;\n        this._isStarted = false;\n        return this;\n    }\n    /**\n     * Set animation weight for all animatables\n     *\n     * @since 6.12.4\n     *  You can pass the weight to the AnimationGroup constructor, or use the weight property to set it after the group has been created,\n     *  making it easier to define the overall animation weight than calling setWeightForAllAnimatables() after the animation group has been started\n     * @param weight defines the weight to use\n     * @returns the animationGroup\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights\n     */\n    setWeightForAllAnimatables(weight) {\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.weight = weight;\n        }\n        return this;\n    }\n    /**\n     * Synchronize and normalize all animatables with a source animatable\n     * @param root defines the root animatable to synchronize with (null to stop synchronizing)\n     * @returns the animationGroup\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights\n     */\n    syncAllAnimationsWith(root) {\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.syncWith(root);\n        }\n        return this;\n    }\n    /**\n     * Goes to a specific frame in this animation group. Note that the animation group must be in playing or paused status\n     * @param frame the frame number to go to\n     * @param useWeight defines whether the animation weight should be applied to the image to be jumped to (false by default)\n     * @returns the animationGroup\n     */\n    goToFrame(frame, useWeight = false) {\n        if (!this._isStarted) {\n            return this;\n        }\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.goToFrame(frame, useWeight);\n        }\n        return this;\n    }\n    /**\n     * Helper to get the current frame. This will return 0 if the AnimationGroup is not running, and it might return wrong results if multiple animations are running in different frames.\n     * @returns current animation frame.\n     */\n    getCurrentFrame() {\n        return this.animatables[0]?.masterFrame || 0;\n    }\n    /**\n     * Dispose all associated resources\n     */\n    dispose() {\n        if (this.isStarted) {\n            this.stop();\n        }\n        this._targetedAnimations.length = 0;\n        this._animatables.length = 0;\n        // Remove from scene\n        const index = this._scene.animationGroups.indexOf(this);\n        if (index > -1) {\n            this._scene.animationGroups.splice(index, 1);\n        }\n        if (this._parentContainer) {\n            const index = this._parentContainer.animationGroups.indexOf(this);\n            if (index > -1) {\n                this._parentContainer.animationGroups.splice(index, 1);\n            }\n            this._parentContainer = null;\n        }\n        this.onAnimationEndObservable.clear();\n        this.onAnimationGroupEndObservable.clear();\n        this.onAnimationGroupPauseObservable.clear();\n        this.onAnimationGroupPlayObservable.clear();\n        this.onAnimationLoopObservable.clear();\n        this.onAnimationGroupLoopObservable.clear();\n    }\n    _checkAnimationGroupEnded(animatable, skipOnAnimationEnd = false) {\n        // animatable should be taken out of the array\n        const idx = this._animatables.indexOf(animatable);\n        if (idx > -1) {\n            this._animatables.splice(idx, 1);\n        }\n        // all animatables were removed? animation group ended!\n        if (this._animatables.length === this._targetedAnimations.length - this._numActiveAnimatables) {\n            this._isStarted = false;\n            if (!skipOnAnimationEnd) {\n                this.onAnimationGroupEndObservable.notifyObservers(this);\n            }\n            this._animatables.length = 0;\n        }\n    }\n    /**\n     * Clone the current animation group and returns a copy\n     * @param newName defines the name of the new group\n     * @param targetConverter defines an optional function used to convert current animation targets to new ones\n     * @param cloneAnimations defines if the animations should be cloned or referenced\n     * @returns the new animation group\n     */\n    clone(newName, targetConverter, cloneAnimations = false) {\n        const newGroup = new AnimationGroup(newName || this.name, this._scene, this._weight, this._playOrder);\n        newGroup._from = this.from;\n        newGroup._to = this.to;\n        newGroup._speedRatio = this.speedRatio;\n        newGroup._loopAnimation = this.loopAnimation;\n        newGroup._isAdditive = this.isAdditive;\n        newGroup._enableBlending = this.enableBlending;\n        newGroup._blendingSpeed = this.blendingSpeed;\n        newGroup.metadata = this.metadata;\n        newGroup.mask = this.mask;\n        for (const targetAnimation of this._targetedAnimations) {\n            newGroup.addTargetedAnimation(cloneAnimations ? targetAnimation.animation.clone() : targetAnimation.animation, targetConverter ? targetConverter(targetAnimation.target) : targetAnimation.target);\n        }\n        return newGroup;\n    }\n    /**\n     * Serializes the animationGroup to an object\n     * @returns Serialized object\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.name = this.name;\n        serializationObject.from = this.from;\n        serializationObject.to = this.to;\n        serializationObject.speedRatio = this.speedRatio;\n        serializationObject.loopAnimation = this.loopAnimation;\n        serializationObject.isAdditive = this.isAdditive;\n        serializationObject.weight = this.weight;\n        serializationObject.playOrder = this.playOrder;\n        serializationObject.enableBlending = this.enableBlending;\n        serializationObject.blendingSpeed = this.blendingSpeed;\n        serializationObject.targetedAnimations = [];\n        for (let targetedAnimationIndex = 0; targetedAnimationIndex < this.targetedAnimations.length; targetedAnimationIndex++) {\n            const targetedAnimation = this.targetedAnimations[targetedAnimationIndex];\n            serializationObject.targetedAnimations[targetedAnimationIndex] = targetedAnimation.serialize();\n        }\n        if (Tags && Tags.HasTags(this)) {\n            serializationObject.tags = Tags.GetTags(this);\n        }\n        // Metadata\n        if (this.metadata) {\n            serializationObject.metadata = this.metadata;\n        }\n        return serializationObject;\n    }\n    // Statics\n    /**\n     * Returns a new AnimationGroup object parsed from the source provided.\n     * @param parsedAnimationGroup defines the source\n     * @param scene defines the scene that will receive the animationGroup\n     * @param nodeMap a map of node.id to node in this scene, to accelerate node lookup\n     * @returns a new AnimationGroup\n     */\n    static Parse(parsedAnimationGroup, scene, nodeMap) {\n        const animationGroup = new AnimationGroup(parsedAnimationGroup.name, scene, parsedAnimationGroup.weight, parsedAnimationGroup.playOrder);\n        for (let i = 0; i < parsedAnimationGroup.targetedAnimations.length; i++) {\n            const targetedAnimation = parsedAnimationGroup.targetedAnimations[i];\n            const animation = Animation.Parse(targetedAnimation.animation);\n            const id = targetedAnimation.targetId;\n            if (targetedAnimation.animation.property === \"influence\") {\n                // morph target animation\n                const morphTarget = scene.getMorphTargetById(id);\n                if (morphTarget) {\n                    animationGroup.addTargetedAnimation(animation, morphTarget);\n                }\n            }\n            else {\n                const targetNode = nodeMap ? nodeMap.get(id) : scene.getNodeById(id);\n                if (targetNode != null) {\n                    animationGroup.addTargetedAnimation(animation, targetNode);\n                }\n            }\n        }\n        if (Tags) {\n            Tags.AddTagsTo(animationGroup, parsedAnimationGroup.tags);\n        }\n        if (parsedAnimationGroup.from !== null && parsedAnimationGroup.to !== null) {\n            animationGroup.normalize(parsedAnimationGroup.from, parsedAnimationGroup.to);\n        }\n        if (parsedAnimationGroup.speedRatio !== undefined) {\n            animationGroup._speedRatio = parsedAnimationGroup.speedRatio;\n        }\n        if (parsedAnimationGroup.loopAnimation !== undefined) {\n            animationGroup._loopAnimation = parsedAnimationGroup.loopAnimation;\n        }\n        if (parsedAnimationGroup.isAdditive !== undefined) {\n            animationGroup._isAdditive = parsedAnimationGroup.isAdditive;\n        }\n        if (parsedAnimationGroup.weight !== undefined) {\n            animationGroup._weight = parsedAnimationGroup.weight;\n        }\n        if (parsedAnimationGroup.playOrder !== undefined) {\n            animationGroup._playOrder = parsedAnimationGroup.playOrder;\n        }\n        if (parsedAnimationGroup.enableBlending !== undefined) {\n            animationGroup._enableBlending = parsedAnimationGroup.enableBlending;\n        }\n        if (parsedAnimationGroup.blendingSpeed !== undefined) {\n            animationGroup._blendingSpeed = parsedAnimationGroup.blendingSpeed;\n        }\n        if (parsedAnimationGroup.metadata !== undefined) {\n            animationGroup.metadata = parsedAnimationGroup.metadata;\n        }\n        return animationGroup;\n    }\n    /** @internal */\n    static MakeAnimationAdditive(sourceAnimationGroup, referenceFrameOrOptions, range, cloneOriginal = false, clonedName) {\n        let options;\n        if (typeof referenceFrameOrOptions === \"object\") {\n            options = referenceFrameOrOptions;\n        }\n        else {\n            options = {\n                referenceFrame: referenceFrameOrOptions,\n                range: range,\n                cloneOriginalAnimationGroup: cloneOriginal,\n                clonedAnimationName: clonedName,\n            };\n        }\n        let animationGroup = sourceAnimationGroup;\n        if (options.cloneOriginalAnimationGroup) {\n            animationGroup = sourceAnimationGroup.clone(options.clonedAnimationGroupName || animationGroup.name);\n        }\n        const targetedAnimations = animationGroup.targetedAnimations;\n        for (let index = 0; index < targetedAnimations.length; index++) {\n            const targetedAnimation = targetedAnimations[index];\n            targetedAnimation.animation = Animation.MakeAnimationAdditive(targetedAnimation.animation, options);\n        }\n        animationGroup.isAdditive = true;\n        if (options.clipKeys) {\n            // We need to recalculate the from/to frames for the animation group because some keys may have been removed\n            let from = Number.MAX_VALUE;\n            let to = -Number.MAX_VALUE;\n            const targetedAnimations = animationGroup.targetedAnimations;\n            for (let index = 0; index < targetedAnimations.length; index++) {\n                const targetedAnimation = targetedAnimations[index];\n                const animation = targetedAnimation.animation;\n                const keys = animation.getKeys();\n                if (from > keys[0].frame) {\n                    from = keys[0].frame;\n                }\n                if (to < keys[keys.length - 1].frame) {\n                    to = keys[keys.length - 1].frame;\n                }\n            }\n            animationGroup._from = from;\n            animationGroup._to = to;\n        }\n        return animationGroup;\n    }\n    /**\n     * Creates a new animation, keeping only the keys that are inside a given key range\n     * @param sourceAnimationGroup defines the animation group on which to operate\n     * @param fromKey defines the lower bound of the range\n     * @param toKey defines the upper bound of the range\n     * @param name defines the name of the new animation group. If not provided, use the same name as animationGroup\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\n     * @returns a new animation group stripped from all the keys outside the given range\n     */\n    static ClipKeys(sourceAnimationGroup, fromKey, toKey, name, dontCloneAnimations) {\n        const animationGroup = sourceAnimationGroup.clone(name || sourceAnimationGroup.name);\n        return AnimationGroup.ClipKeysInPlace(animationGroup, fromKey, toKey, dontCloneAnimations);\n    }\n    /**\n     * Updates an existing animation, keeping only the keys that are inside a given key range\n     * @param animationGroup defines the animation group on which to operate\n     * @param fromKey defines the lower bound of the range\n     * @param toKey defines the upper bound of the range\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\n     * @returns the animationGroup stripped from all the keys outside the given range\n     */\n    static ClipKeysInPlace(animationGroup, fromKey, toKey, dontCloneAnimations) {\n        return AnimationGroup.ClipInPlace(animationGroup, fromKey, toKey, dontCloneAnimations, false);\n    }\n    /**\n     * Creates a new animation, keeping only the frames that are inside a given frame range\n     * @param sourceAnimationGroup defines the animation group on which to operate\n     * @param fromFrame defines the lower bound of the range\n     * @param toFrame defines the upper bound of the range\n     * @param name defines the name of the new animation group. If not provided, use the same name as animationGroup\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the frames. Default is false, so animations will be cloned\n     * @returns a new animation group stripped from all the frames outside the given range\n     */\n    static ClipFrames(sourceAnimationGroup, fromFrame, toFrame, name, dontCloneAnimations) {\n        const animationGroup = sourceAnimationGroup.clone(name || sourceAnimationGroup.name);\n        return AnimationGroup.ClipFramesInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations);\n    }\n    /**\n     * Updates an existing animation, keeping only the frames that are inside a given frame range\n     * @param animationGroup defines the animation group on which to operate\n     * @param fromFrame defines the lower bound of the range\n     * @param toFrame defines the upper bound of the range\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the frames. Default is false, so animations will be cloned\n     * @returns the animationGroup stripped from all the frames outside the given range\n     */\n    static ClipFramesInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations) {\n        return AnimationGroup.ClipInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations, true);\n    }\n    /**\n     * Updates an existing animation, keeping only the keys that are inside a given key or frame range\n     * @param animationGroup defines the animation group on which to operate\n     * @param start defines the lower bound of the range\n     * @param end defines the upper bound of the range\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\n     * @param useFrame defines if the range is defined by frame numbers or key indices (default is false which means use key indices)\n     * @returns the animationGroup stripped from all the keys outside the given range\n     */\n    static ClipInPlace(animationGroup, start, end, dontCloneAnimations, useFrame = false) {\n        let from = Number.MAX_VALUE;\n        let to = -Number.MAX_VALUE;\n        const targetedAnimations = animationGroup.targetedAnimations;\n        for (let index = 0; index < targetedAnimations.length; index++) {\n            const targetedAnimation = targetedAnimations[index];\n            const animation = dontCloneAnimations ? targetedAnimation.animation : targetedAnimation.animation.clone();\n            if (useFrame) {\n                // Make sure we have keys corresponding to the bounds of the frame range\n                animation.createKeyForFrame(start);\n                animation.createKeyForFrame(end);\n            }\n            const keys = animation.getKeys();\n            const newKeys = [];\n            let startFrame = Number.MAX_VALUE;\n            for (let k = 0; k < keys.length; k++) {\n                const key = keys[k];\n                if ((!useFrame && k >= start && k <= end) || (useFrame && key.frame >= start && key.frame <= end)) {\n                    const newKey = {\n                        frame: key.frame,\n                        value: key.value.clone ? key.value.clone() : key.value,\n                        inTangent: key.inTangent,\n                        outTangent: key.outTangent,\n                        interpolation: key.interpolation,\n                        lockedTangent: key.lockedTangent,\n                    };\n                    if (startFrame === Number.MAX_VALUE) {\n                        startFrame = newKey.frame;\n                    }\n                    newKey.frame -= startFrame;\n                    newKeys.push(newKey);\n                }\n            }\n            if (newKeys.length === 0) {\n                targetedAnimations.splice(index, 1);\n                index--;\n                continue;\n            }\n            if (from > newKeys[0].frame) {\n                from = newKeys[0].frame;\n            }\n            if (to < newKeys[newKeys.length - 1].frame) {\n                to = newKeys[newKeys.length - 1].frame;\n            }\n            animation.setKeys(newKeys, true);\n            targetedAnimation.animation = animation; // in case the animation has been cloned\n        }\n        animationGroup._from = from;\n        animationGroup._to = to;\n        return animationGroup;\n    }\n    /**\n     * Returns the string \"AnimationGroup\"\n     * @returns \"AnimationGroup\"\n     */\n    getClassName() {\n        return \"AnimationGroup\";\n    }\n    /**\n     * Creates a detailed string about the object\n     * @param fullDetails defines if the output string will support multiple levels of logging within scene loading\n     * @returns a string representing the object\n     */\n    toString(fullDetails) {\n        let ret = \"Name: \" + this.name;\n        ret += \", type: \" + this.getClassName();\n        if (fullDetails) {\n            ret += \", from: \" + this._from;\n            ret += \", to: \" + this._to;\n            ret += \", isStarted: \" + this._isStarted;\n            ret += \", speedRatio: \" + this._speedRatio;\n            ret += \", targetedAnimations length: \" + this._targetedAnimations.length;\n            ret += \", animatables length: \" + this._animatables;\n        }\n        return ret;\n    }\n}\n//# sourceMappingURL=animationGroup.js.map"],"names":["RuntimeAnimation","currentFrame","this","_currentFrame","weight","_weight","currentValue","_currentValue","targetPath","_targetPath","target","_currentActiveTarget","isAdditive","_host","constructor","animation","scene","host","_events","Array","_originalValue","_originalBlendValue","_offsetsCache","_highLimitsCache","_stopped","_blendingFactor","_directTarget","_absoluteFrameOffset","_previousElapsedTime","_yoyoDirection","_previousAbsoluteFrame","_targetIsArray","_coreRuntimeAnimation","_animation","_target","_scene","_activeTargets","_runtimeAnimations","push","_animationState","key","repeatCount","loopMode","_getCorrectLoopMode","dataType","Animation","ANIMATIONTYPE_MATRIX","workValue","Matrix","Zero","_keys","getKeys","_minFrame","frame","_maxFrame","length","_minValue","value","_maxValue","newKey","splice","index","_preparePath","_getOriginalValues","events","getEvents","e","_clone","_enableBlending","animationPropertiesOverride","enableBlending","targetIndex","targetPropertyPath","property","name","undefined","Error","join","reset","restoreOriginal","_setValue","isDone","isStopped","dispose","runtimeAnimations","indexOf","setValue","originalValue","getLocalMatrix","clone","_registerTargetForLateAnimationBinding","runtimeAnimation","_registeredForLateAnimationBindings","pushNoDuplicate","_lateAnimationHolders","totalWeight","totalAdditiveWeight","animations","additiveAnimations","destination","m","AllowMatrixDecomposeForInterpolation","DecomposeLerpToRef","DecomposeLerp","LerpToRef","Lerp","_UniversalLerp","blendingSpeed","copyFrom","ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT","addToRef","markAsDirty","targetProperty","goToFrame","keys","onlyOnce","_interpolate","_prepareForSpeedRatioChange","newSpeedRatio","newAbsoluteFrame","framePerSecond","animate","elapsedTimeSinceAnimationStart","from","to","loop","speedRatio","returnValue","frameRange","highLimitValue","offsetValue","absoluteFrame","yoyoLoop","yoyoMode","ANIMATIONLOOPMODE_YOYO","position","sin","Math","PI","abs","direction","_getKeyValue","ANIMATIONLOOPMODE_CYCLE","keyOffset","toString","fromValue","toValue","ANIMATIONTYPE_FLOAT","ANIMATIONTYPE_QUATERNION","ANIMATIONTYPE_VECTOR3","ANIMATIONTYPE_VECTOR2","ANIMATIONTYPE_SIZE","ANIMATIONTYPE_COLOR3","subtract","_StaticOffsetValueQuaternion","_StaticOffsetValueVector3","_StaticOffsetValueVector2","_StaticOffsetValueSize","_StaticOffsetValueColor3","ANIMATIONTYPE_COLOR4","_StaticOffsetValueColor4","syncRoot","masterFrame","fromFrame","toFrame","_onLoop","event","action","Animatable","_syncRoot","min","max","_speedRatio","_goToFrame","elapsedTime","_localDelayOffset","_animationTime","loopAnimation","onAnimationEnd","onAnimationLoop","playOrder","_pausedDelay","_manualJumpDelay","_paused","_previousWeight","_frameToSyncFromJump","disposeOnEnd","animationStarted","onAnimationEndObservable","Observable","onAnimationLoopObservable","appendAnimations","_activeAnimatables","syncWith","root","getAnimations","newRuntimeAnimation","notifyObservers","getAnimationByTargetProperty","getRuntimeAnimationByTargetProperty","disableBlending","useWeight","fps","delay","paused","pause","restart","_raiseOnAnimationEnd","stop","animationName","targetMask","useGlobalSplice","skipOnAnimationEnd","idx","waitAsync","Promise","resolve","add","_animate","ProcessPausedAnimatables","running","isRunning","clear","ProcessLateAnimationBindingsForMatrices","holder","normalizer","finalPosition","TmpVectors","Vector3","finalScaling","finalQuaternion","Quaternion","startIndex","originalAnimation","scale","skipOverride","decompose","scaleInPlace","animIndex","currentPosition","currentScaling","currentQuaternion","scaleAndAddToRef","Dot","normalize","multiplyToRef","SlerpToRef","ComposeToRef","ProcessLateAnimationBindingsForQuaternions","refQuaternion","cumulativeQuaternion","quaternions","weights","cumulativeAmount","sceneClass","boneClass","Scene","Bone","prototype","copyAnimationRange","source","rangeName","frameOffset","rescaleAsRequired","skelDimensionsRatio","setKeys","sourceRange","getRange","sourceKeys","sourceBoneLength","sourceParent","getParent","parent","parentScalingReqd","parentRatio","dimensionsScalingReqd","x","y","z","destKeys","orig","origTranslation","mat","nKeys","getTranslation","setTranslation","multiplyInPlace","createRange","customDeltaTime","animationsEnabled","now","PrecisionDate","Now","_animationTimeLast","_pendingData","deltaTime","useConstantAnimationDeltaTime","animationTimeScale","animatables","animationTime","animatable","data","path","matrixDecomposeMode","finalValue","w","Identity","originalAnimationIsLoopRelativeFromCurrent","ProcessLateAnimationBindings","sortActiveAnimatables","sort","a","b","beginWeightedAnimation","returnedAnimatable","beginAnimation","stopCurrent","tmp","stopAnimation","shouldRunTargetAnimations","getAnimatables","beginHierarchyAnimation","directDescendantsOnly","children","getDescendants","result","child","beginDirectAnimation","beginDirectHierarchyAnimation","getAnimatableByTarget","getAllAnimatablesByTarget","stopAllAnimations","i","group","animationGroups","TargetedAnimation","getClassName","uniqueId","UniqueIdGenerator","UniqueId","serialize","serializationObject","targetId","id","AnimationGroup","mask","_mask","syncWithMask","forceUpdate","_numActiveAnimatables","_animatables","disabled","retainsTarget","_targetedAnimations","removeUnmaskedAnimations","targetedAnimation","_from","_to","isStarted","_isStarted","isPlaying","_isPaused","_loopAnimation","_isAdditive","setWeightForAllAnimatables","targetedAnimations","_playOrder","_blendingSpeed","getLength","MergeAnimationGroups","disposeSource","beginFrame","Number","MAX_VALUE","endFrame","animationGroup","mergedAnimationGroup","addTargetedAnimation","getScene","_shouldStart","_parentContainer","onAnimationGroupLoopObservable","onAnimationGroupEndObservable","onAnimationGroupPauseObservable","onAnimationGroupPlayObservable","metadata","_animationLoopFlags","EngineStore","LastCreatedScene","getUniqueId","addAnimationGroup","removeTargetedAnimation","startKey","endKey","inTangent","outTangent","interpolation","_processLoop","_animationLoopCount","start","_checkAnimationGroupEnded","play","list","slice","curIndex","syncAllAnimationsWith","getCurrentFrame","newName","targetConverter","cloneAnimations","newGroup","targetAnimation","targetedAnimationIndex","Tags","HasTags","tags","GetTags","Parse","parsedAnimationGroup","nodeMap","morphTarget","getMorphTargetById","targetNode","get","getNodeById","AddTagsTo","MakeAnimationAdditive","sourceAnimationGroup","referenceFrameOrOptions","range","cloneOriginal","clonedName","options","referenceFrame","cloneOriginalAnimationGroup","clonedAnimationName","clonedAnimationGroupName","clipKeys","ClipKeys","fromKey","toKey","dontCloneAnimations","ClipKeysInPlace","ClipInPlace","ClipFrames","ClipFramesInPlace","end","useFrame","createKeyForFrame","newKeys","startFrame","k","lockedTangent","fullDetails","ret"],"mappings":"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"}