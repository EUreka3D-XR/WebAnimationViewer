{"version":3,"file":"skeleton-BM6jc2S2.esm.min.js","sources":["../../../../../dev/core/dist/Bones/skeleton.js"],"sourcesContent":["import { Bone } from \"./bone\";\nimport { Observable } from \"../Misc/observable\";\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\nimport { Animation } from \"../Animations/animation\";\nimport { AnimationRange } from \"../Animations/animationRange\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { Constants } from \"../Engines/constants\";\nimport { Logger } from \"../Misc/logger\";\nimport { DeepCopier } from \"../Misc/deepCopier\";\n/**\n * Class used to handle skinning animations\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\n */\nexport class Skeleton {\n    /**\n     * Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).\n     * Please note that this option is not available if the hardware does not support it\n     */\n    get useTextureToStoreBoneMatrices() {\n        return this._useTextureToStoreBoneMatrices;\n    }\n    set useTextureToStoreBoneMatrices(value) {\n        this._useTextureToStoreBoneMatrices = value;\n        this._markAsDirty();\n    }\n    /**\n     * Gets or sets the animation properties override\n     */\n    get animationPropertiesOverride() {\n        if (!this._animationPropertiesOverride) {\n            return this._scene.animationPropertiesOverride;\n        }\n        return this._animationPropertiesOverride;\n    }\n    set animationPropertiesOverride(value) {\n        this._animationPropertiesOverride = value;\n    }\n    /**\n     * Gets a boolean indicating that the skeleton effectively stores matrices into a texture\n     */\n    get isUsingTextureForMatrices() {\n        return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;\n    }\n    /**\n     * Gets the unique ID of this skeleton\n     */\n    get uniqueId() {\n        return this._uniqueId;\n    }\n    /**\n     * Creates a new skeleton\n     * @param name defines the skeleton name\n     * @param id defines the skeleton Id\n     * @param scene defines the hosting scene\n     */\n    constructor(\n    /** defines the skeleton name */\n    name, \n    /** defines the skeleton Id */\n    id, scene) {\n        this.name = name;\n        this.id = id;\n        /**\n         * Defines the list of child bones\n         */\n        this.bones = [];\n        /**\n         * Defines a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)\n         */\n        this.needInitialSkinMatrix = false;\n        this._isDirty = true;\n        this._meshesWithPoseMatrix = new Array();\n        this._identity = Matrix.Identity();\n        this._currentRenderId = -1;\n        this._ranges = {};\n        this._absoluteTransformIsDirty = true;\n        this._canUseTextureForBones = false;\n        this._uniqueId = 0;\n        /** @internal */\n        this._numBonesWithLinkedTransformNode = 0;\n        /** @internal */\n        this._hasWaitingData = null;\n        /** @internal */\n        this._parentContainer = null;\n        /**\n         * Specifies if the skeleton should be serialized\n         */\n        this.doNotSerialize = false;\n        this._useTextureToStoreBoneMatrices = true;\n        this._animationPropertiesOverride = null;\n        // Events\n        /**\n         * An observable triggered before computing the skeleton's matrices\n         */\n        this.onBeforeComputeObservable = new Observable();\n        /**\n         * Gets or sets an object used to store user defined information for the skeleton\n         */\n        this.metadata = null;\n        this.bones = [];\n        this._scene = scene || EngineStore.LastCreatedScene;\n        this._uniqueId = this._scene.getUniqueId();\n        this._scene.addSkeleton(this);\n        //make sure it will recalculate the matrix next time prepare is called.\n        this._isDirty = true;\n        const engineCaps = this._scene.getEngine().getCaps();\n        this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;\n    }\n    /**\n     * Gets the current object class name.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"Skeleton\";\n    }\n    /**\n     * Returns an array containing the root bones\n     * @returns an array containing the root bones\n     */\n    getChildren() {\n        return this.bones.filter((b) => !b.getParent());\n    }\n    // Members\n    /**\n     * Gets the list of transform matrices to send to shaders (one matrix per bone)\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\n     * @returns a Float32Array containing matrices data\n     */\n    getTransformMatrices(mesh) {\n        if (this.needInitialSkinMatrix) {\n            if (!mesh) {\n                throw new Error(\"getTransformMatrices: When using the needInitialSkinMatrix flag, a mesh must be provided\");\n            }\n            if (!mesh._bonesTransformMatrices) {\n                this.prepare(true);\n            }\n            return mesh._bonesTransformMatrices;\n        }\n        if (!this._transformMatrices || this._isDirty) {\n            this.prepare(!this._transformMatrices);\n        }\n        return this._transformMatrices;\n    }\n    /**\n     * Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\n     * @returns a raw texture containing the data\n     */\n    getTransformMatrixTexture(mesh) {\n        if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {\n            return mesh._transformMatrixTexture;\n        }\n        return this._transformMatrixTexture;\n    }\n    /**\n     * Gets the current hosting scene\n     * @returns a scene object\n     */\n    getScene() {\n        return this._scene;\n    }\n    // Methods\n    /**\n     * Gets a string representing the current skeleton data\n     * @param fullDetails defines a boolean indicating if we want a verbose version\n     * @returns a string representing the current skeleton data\n     */\n    toString(fullDetails) {\n        let ret = `Name: ${this.name}, nBones: ${this.bones.length}`;\n        ret += `, nAnimationRanges: ${this._ranges ? Object.keys(this._ranges).length : \"none\"}`;\n        if (fullDetails) {\n            ret += \", Ranges: {\";\n            let first = true;\n            for (const name in this._ranges) {\n                if (first) {\n                    ret += \", \";\n                    first = false;\n                }\n                ret += name;\n            }\n            ret += \"}\";\n        }\n        return ret;\n    }\n    /**\n     * Get bone's index searching by name\n     * @param name defines bone's name to search for\n     * @returns the indice of the bone. Returns -1 if not found\n     */\n    getBoneIndexByName(name) {\n        for (let boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {\n            if (this.bones[boneIndex].name === name) {\n                return boneIndex;\n            }\n        }\n        return -1;\n    }\n    /**\n     * Create a new animation range\n     * @param name defines the name of the range\n     * @param from defines the start key\n     * @param to defines the end key\n     */\n    createAnimationRange(name, from, to) {\n        // check name not already in use\n        if (!this._ranges[name]) {\n            this._ranges[name] = new AnimationRange(name, from, to);\n            for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n                if (this.bones[i].animations[0]) {\n                    this.bones[i].animations[0].createRange(name, from, to);\n                }\n            }\n        }\n    }\n    /**\n     * Delete a specific animation range\n     * @param name defines the name of the range\n     * @param deleteFrames defines if frames must be removed as well\n     */\n    deleteAnimationRange(name, deleteFrames = true) {\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n            if (this.bones[i].animations[0]) {\n                this.bones[i].animations[0].deleteRange(name, deleteFrames);\n            }\n        }\n        this._ranges[name] = null; // said much faster than 'delete this._range[name]'\n    }\n    /**\n     * Gets a specific animation range\n     * @param name defines the name of the range to look for\n     * @returns the requested animation range or null if not found\n     */\n    getAnimationRange(name) {\n        return this._ranges[name] || null;\n    }\n    /**\n     * Gets the list of all animation ranges defined on this skeleton\n     * @returns an array\n     */\n    getAnimationRanges() {\n        const animationRanges = [];\n        let name;\n        for (name in this._ranges) {\n            animationRanges.push(this._ranges[name]);\n        }\n        return animationRanges;\n    }\n    /**\n     * Copy animation range from a source skeleton.\n     * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences\n     * @param source defines the source skeleton\n     * @param name defines the name of the range to copy\n     * @param rescaleAsRequired defines if rescaling must be applied if required\n     * @returns true if operation was successful\n     */\n    copyAnimationRange(source, name, rescaleAsRequired = false) {\n        if (this._ranges[name] || !source.getAnimationRange(name)) {\n            return false;\n        }\n        let ret = true;\n        const frameOffset = this._getHighestAnimationFrame() + 1;\n        // make a dictionary of source skeleton's bones, so exact same order or doubly nested loop is not required\n        const boneDict = {};\n        const sourceBones = source.bones;\n        let nBones;\n        let i;\n        for (i = 0, nBones = sourceBones.length; i < nBones; i++) {\n            boneDict[sourceBones[i].name] = sourceBones[i];\n        }\n        if (this.bones.length !== sourceBones.length) {\n            Logger.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${sourceBones.length}`);\n            ret = false;\n        }\n        const skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;\n        for (i = 0, nBones = this.bones.length; i < nBones; i++) {\n            const boneName = this.bones[i].name;\n            const sourceBone = boneDict[boneName];\n            if (sourceBone) {\n                ret = ret && this.bones[i].copyAnimationRange(sourceBone, name, frameOffset, rescaleAsRequired, skelDimensionsRatio);\n            }\n            else {\n                Logger.Warn(\"copyAnimationRange: not same rig, missing source bone \" + boneName);\n                ret = false;\n            }\n        }\n        // do not call createAnimationRange(), since it also is done to bones, which was already done\n        const range = source.getAnimationRange(name);\n        if (range) {\n            this._ranges[name] = new AnimationRange(name, range.from + frameOffset, range.to + frameOffset);\n        }\n        return ret;\n    }\n    /**\n     * Forces the skeleton to go to rest pose\n     */\n    returnToRest() {\n        for (const bone of this.bones) {\n            if (bone._index !== -1) {\n                bone.returnToRest();\n            }\n        }\n    }\n    _getHighestAnimationFrame() {\n        let ret = 0;\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n            if (this.bones[i].animations[0]) {\n                const highest = this.bones[i].animations[0].getHighestFrame();\n                if (ret < highest) {\n                    ret = highest;\n                }\n            }\n        }\n        return ret;\n    }\n    /**\n     * Begin a specific animation range\n     * @param name defines the name of the range to start\n     * @param loop defines if looping must be turned on (false by default)\n     * @param speedRatio defines the speed ratio to apply (1 by default)\n     * @param onAnimationEnd defines a callback which will be called when animation will end\n     * @returns a new animatable\n     */\n    beginAnimation(name, loop, speedRatio, onAnimationEnd) {\n        const range = this.getAnimationRange(name);\n        if (!range) {\n            return null;\n        }\n        return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);\n    }\n    /**\n     * Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.\n     * @param skeleton defines the Skeleton containing the animation range to convert\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to\n     * @param range defines the name of the AnimationRange belonging to the Skeleton to convert\n     * @returns the original skeleton\n     */\n    static MakeAnimationAdditive(skeleton, referenceFrame = 0, range) {\n        const rangeValue = skeleton.getAnimationRange(range);\n        // We can't make a range additive if it doesn't exist\n        if (!rangeValue) {\n            return null;\n        }\n        // Find any current scene-level animatable belonging to the target that matches the range\n        const sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);\n        let rangeAnimatable = null;\n        for (let index = 0; index < sceneAnimatables.length; index++) {\n            const sceneAnimatable = sceneAnimatables[index];\n            if (sceneAnimatable.fromFrame === rangeValue?.from && sceneAnimatable.toFrame === rangeValue?.to) {\n                rangeAnimatable = sceneAnimatable;\n                break;\n            }\n        }\n        // Convert the animations belonging to the skeleton to additive keyframes\n        const animatables = skeleton.getAnimatables();\n        for (let index = 0; index < animatables.length; index++) {\n            const animatable = animatables[index];\n            const animations = animatable.animations;\n            if (!animations) {\n                continue;\n            }\n            for (let animIndex = 0; animIndex < animations.length; animIndex++) {\n                Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);\n            }\n        }\n        // Mark the scene-level animatable as additive\n        if (rangeAnimatable) {\n            rangeAnimatable.isAdditive = true;\n        }\n        return skeleton;\n    }\n    /** @internal */\n    _markAsDirty() {\n        this._isDirty = true;\n        this._absoluteTransformIsDirty = true;\n    }\n    /**\n     * @internal\n     */\n    _registerMeshWithPoseMatrix(mesh) {\n        this._meshesWithPoseMatrix.push(mesh);\n    }\n    /**\n     * @internal\n     */\n    _unregisterMeshWithPoseMatrix(mesh) {\n        const index = this._meshesWithPoseMatrix.indexOf(mesh);\n        if (index > -1) {\n            this._meshesWithPoseMatrix.splice(index, 1);\n        }\n    }\n    _computeTransformMatrices(targetMatrix, initialSkinMatrix) {\n        this.onBeforeComputeObservable.notifyObservers(this);\n        for (let index = 0; index < this.bones.length; index++) {\n            const bone = this.bones[index];\n            bone._childUpdateId++;\n            const parentBone = bone.getParent();\n            if (parentBone) {\n                bone.getLocalMatrix().multiplyToRef(parentBone.getFinalMatrix(), bone.getFinalMatrix());\n            }\n            else {\n                if (initialSkinMatrix) {\n                    bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getFinalMatrix());\n                }\n                else {\n                    bone.getFinalMatrix().copyFrom(bone.getLocalMatrix());\n                }\n            }\n            if (bone._index !== -1) {\n                const mappedIndex = bone._index === null ? index : bone._index;\n                bone.getAbsoluteInverseBindMatrix().multiplyToArray(bone.getFinalMatrix(), targetMatrix, mappedIndex * 16);\n            }\n        }\n        this._identity.copyToArray(targetMatrix, this.bones.length * 16);\n    }\n    /**\n     * Build all resources required to render a skeleton\n     * @param dontCheckFrameId defines a boolean indicating if prepare should be run without checking first the current frame id (default: false)\n     */\n    prepare(dontCheckFrameId = false) {\n        if (!dontCheckFrameId) {\n            const currentRenderId = this.getScene().getRenderId();\n            if (this._currentRenderId === currentRenderId) {\n                return;\n            }\n            this._currentRenderId = currentRenderId;\n        }\n        // Update the local matrix of bones with linked transform nodes.\n        if (this._numBonesWithLinkedTransformNode > 0) {\n            for (const bone of this.bones) {\n                if (bone._linkedTransformNode) {\n                    const node = bone._linkedTransformNode;\n                    bone.position = node.position;\n                    if (node.rotationQuaternion) {\n                        bone.rotationQuaternion = node.rotationQuaternion;\n                    }\n                    else {\n                        bone.rotation = node.rotation;\n                    }\n                    bone.scaling = node.scaling;\n                }\n            }\n        }\n        if (this.needInitialSkinMatrix) {\n            for (const mesh of this._meshesWithPoseMatrix) {\n                const poseMatrix = mesh.getPoseMatrix();\n                let needsUpdate = this._isDirty;\n                if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {\n                    mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));\n                    needsUpdate = true;\n                }\n                if (!needsUpdate) {\n                    continue;\n                }\n                if (this._synchronizedWithMesh !== mesh) {\n                    this._synchronizedWithMesh = mesh;\n                    // Prepare bones\n                    for (const bone of this.bones) {\n                        if (!bone.getParent()) {\n                            const matrix = bone.getBindMatrix();\n                            matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);\n                            bone._updateAbsoluteBindMatrices(TmpVectors.Matrix[1]);\n                        }\n                    }\n                    if (this.isUsingTextureForMatrices) {\n                        const textureWidth = (this.bones.length + 1) * 4;\n                        if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {\n                            if (mesh._transformMatrixTexture) {\n                                mesh._transformMatrixTexture.dispose();\n                            }\n                            mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(mesh._bonesTransformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTURETYPE_FLOAT);\n                        }\n                    }\n                }\n                this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);\n                if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {\n                    mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);\n                }\n            }\n        }\n        else {\n            if (!this._isDirty) {\n                return;\n            }\n            if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {\n                this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));\n                if (this.isUsingTextureForMatrices) {\n                    if (this._transformMatrixTexture) {\n                        this._transformMatrixTexture.dispose();\n                    }\n                    this._transformMatrixTexture = RawTexture.CreateRGBATexture(this._transformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTURETYPE_FLOAT);\n                }\n            }\n            this._computeTransformMatrices(this._transformMatrices, null);\n            if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {\n                this._transformMatrixTexture.update(this._transformMatrices);\n            }\n        }\n        this._isDirty = false;\n    }\n    /**\n     * Gets the list of animatables currently running for this skeleton\n     * @returns an array of animatables\n     */\n    getAnimatables() {\n        if (!this._animatables || this._animatables.length !== this.bones.length) {\n            this._animatables = [];\n            for (let index = 0; index < this.bones.length; index++) {\n                this._animatables.push(this.bones[index]);\n            }\n        }\n        return this._animatables;\n    }\n    /**\n     * Clone the current skeleton\n     * @param name defines the name of the new skeleton\n     * @param id defines the id of the new skeleton\n     * @returns the new skeleton\n     */\n    clone(name, id) {\n        const result = new Skeleton(name, id || name, this._scene);\n        result.needInitialSkinMatrix = this.needInitialSkinMatrix;\n        result.metadata = this.metadata;\n        for (let index = 0; index < this.bones.length; index++) {\n            const source = this.bones[index];\n            let parentBone = null;\n            const parent = source.getParent();\n            if (parent) {\n                const parentIndex = this.bones.indexOf(parent);\n                parentBone = result.bones[parentIndex];\n            }\n            const bone = new Bone(source.name, result, parentBone, source.getBindMatrix().clone(), source.getRestMatrix().clone());\n            bone._index = source._index;\n            if (source._linkedTransformNode) {\n                bone.linkTransformNode(source._linkedTransformNode);\n            }\n            DeepCopier.DeepCopy(source.animations, bone.animations);\n        }\n        if (this._ranges) {\n            result._ranges = {};\n            for (const rangeName in this._ranges) {\n                const range = this._ranges[rangeName];\n                if (range) {\n                    result._ranges[rangeName] = range.clone();\n                }\n            }\n        }\n        this._isDirty = true;\n        result.prepare(true);\n        return result;\n    }\n    /**\n     * Enable animation blending for this skeleton\n     * @param blendingSpeed defines the blending speed to apply\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\n     */\n    enableBlending(blendingSpeed = 0.01) {\n        for (const bone of this.bones) {\n            for (const animation of bone.animations) {\n                animation.enableBlending = true;\n                animation.blendingSpeed = blendingSpeed;\n            }\n        }\n    }\n    /**\n     * Releases all resources associated with the current skeleton\n     */\n    dispose() {\n        this._meshesWithPoseMatrix.length = 0;\n        this.metadata = null;\n        // Animations\n        this.getScene().stopAnimation(this);\n        // Remove from scene\n        this.getScene().removeSkeleton(this);\n        if (this._parentContainer) {\n            const index = this._parentContainer.skeletons.indexOf(this);\n            if (index > -1) {\n                this._parentContainer.skeletons.splice(index, 1);\n            }\n            this._parentContainer = null;\n        }\n        if (this._transformMatrixTexture) {\n            this._transformMatrixTexture.dispose();\n            this._transformMatrixTexture = null;\n        }\n    }\n    /**\n     * Serialize the skeleton in a JSON object\n     * @returns a JSON object\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.name = this.name;\n        serializationObject.id = this.id;\n        if (this.dimensionsAtRest) {\n            serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();\n        }\n        serializationObject.bones = [];\n        serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;\n        if (this.metadata) {\n            serializationObject.metadata = this.metadata;\n        }\n        for (let index = 0; index < this.bones.length; index++) {\n            const bone = this.bones[index];\n            const parent = bone.getParent();\n            const serializedBone = {\n                parentBoneIndex: parent ? this.bones.indexOf(parent) : -1,\n                index: bone.getIndex(),\n                name: bone.name,\n                id: bone.id,\n                matrix: bone.getBindMatrix().asArray(),\n                rest: bone.getRestMatrix().asArray(),\n                linkedTransformNodeId: bone.getTransformNode()?.id,\n            };\n            serializationObject.bones.push(serializedBone);\n            if (bone.length) {\n                serializedBone.length = bone.length;\n            }\n            if (bone.metadata) {\n                serializedBone.metadata = bone.metadata;\n            }\n            if (bone.animations && bone.animations.length > 0) {\n                serializedBone.animation = bone.animations[0].serialize();\n            }\n            serializationObject.ranges = [];\n            for (const name in this._ranges) {\n                const source = this._ranges[name];\n                if (!source) {\n                    continue;\n                }\n                const range = {};\n                range.name = name;\n                range.from = source.from;\n                range.to = source.to;\n                serializationObject.ranges.push(range);\n            }\n        }\n        return serializationObject;\n    }\n    /**\n     * Creates a new skeleton from serialized data\n     * @param parsedSkeleton defines the serialized data\n     * @param scene defines the hosting scene\n     * @returns a new skeleton\n     */\n    static Parse(parsedSkeleton, scene) {\n        const skeleton = new Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);\n        if (parsedSkeleton.dimensionsAtRest) {\n            skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);\n        }\n        skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;\n        if (parsedSkeleton.metadata) {\n            skeleton.metadata = parsedSkeleton.metadata;\n        }\n        let index;\n        for (index = 0; index < parsedSkeleton.bones.length; index++) {\n            const parsedBone = parsedSkeleton.bones[index];\n            const parsedBoneIndex = parsedSkeleton.bones[index].index;\n            let parentBone = null;\n            if (parsedBone.parentBoneIndex > -1) {\n                parentBone = skeleton.bones[parsedBone.parentBoneIndex];\n            }\n            const rest = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;\n            const bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);\n            if (parsedBone.id !== undefined && parsedBone.id !== null) {\n                bone.id = parsedBone.id;\n            }\n            if (parsedBone.length) {\n                bone.length = parsedBone.length;\n            }\n            if (parsedBone.metadata) {\n                bone.metadata = parsedBone.metadata;\n            }\n            if (parsedBone.animation) {\n                bone.animations.push(Animation.Parse(parsedBone.animation));\n            }\n            if (parsedBone.linkedTransformNodeId !== undefined && parsedBone.linkedTransformNodeId !== null) {\n                skeleton._hasWaitingData = true;\n                bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;\n            }\n        }\n        // placed after bones, so createAnimationRange can cascade down\n        if (parsedSkeleton.ranges) {\n            for (index = 0; index < parsedSkeleton.ranges.length; index++) {\n                const data = parsedSkeleton.ranges[index];\n                skeleton.createAnimationRange(data.name, data.from, data.to);\n            }\n        }\n        return skeleton;\n    }\n    /**\n     * Compute all node absolute matrices\n     * @param forceUpdate defines if computation must be done even if cache is up to date\n     */\n    computeAbsoluteMatrices(forceUpdate = false) {\n        if (this._absoluteTransformIsDirty || forceUpdate) {\n            this.bones[0].computeAbsoluteMatrices();\n            this._absoluteTransformIsDirty = false;\n        }\n    }\n    /**\n     * Compute all node absolute matrices\n     * @param forceUpdate defines if computation must be done even if cache is up to date\n     * @deprecated Please use computeAbsoluteMatrices instead\n     */\n    computeAbsoluteTransforms(forceUpdate = false) {\n        this.computeAbsoluteMatrices(forceUpdate);\n    }\n    /**\n     * Gets the root pose matrix\n     * @returns a matrix\n     */\n    getPoseMatrix() {\n        let poseMatrix = null;\n        if (this._meshesWithPoseMatrix.length > 0) {\n            poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();\n        }\n        return poseMatrix;\n    }\n    /**\n     * Sorts bones per internal index\n     */\n    sortBones() {\n        const bones = [];\n        const visited = new Array(this.bones.length);\n        for (let index = 0; index < this.bones.length; index++) {\n            this._sortBones(index, bones, visited);\n        }\n        this.bones = bones;\n    }\n    _sortBones(index, bones, visited) {\n        if (visited[index]) {\n            return;\n        }\n        visited[index] = true;\n        const bone = this.bones[index];\n        if (!bone) {\n            return;\n        }\n        if (bone._index === undefined) {\n            bone._index = index;\n        }\n        const parentBone = bone.getParent();\n        if (parentBone) {\n            this._sortBones(this.bones.indexOf(parentBone), bones, visited);\n        }\n        bones.push(bone);\n    }\n    /**\n     * Set the current local matrix as the restPose for all bones in the skeleton.\n     */\n    setCurrentPoseAsRest() {\n        for (const b of this.bones) {\n            b.setCurrentPoseAsRest();\n        }\n    }\n}\n//# sourceMappingURL=skeleton.js.map"],"names":["Skeleton","useTextureToStoreBoneMatrices","this","_useTextureToStoreBoneMatrices","value","_markAsDirty","animationPropertiesOverride","_animationPropertiesOverride","_scene","isUsingTextureForMatrices","_canUseTextureForBones","uniqueId","_uniqueId","constructor","name","id","scene","bones","needInitialSkinMatrix","_isDirty","_meshesWithPoseMatrix","Array","_identity","Matrix","Identity","_currentRenderId","_ranges","_absoluteTransformIsDirty","_numBonesWithLinkedTransformNode","_hasWaitingData","_parentContainer","doNotSerialize","onBeforeComputeObservable","Observable","metadata","EngineStore","LastCreatedScene","getUniqueId","addSkeleton","engineCaps","getEngine","getCaps","textureFloat","maxVertexTextureImageUnits","getClassName","getChildren","filter","b","getParent","getTransformMatrices","mesh","Error","_bonesTransformMatrices","prepare","_transformMatrices","getTransformMatrixTexture","_transformMatrixTexture","getScene","toString","fullDetails","ret","length","Object","keys","first","getBoneIndexByName","boneIndex","cache","createAnimationRange","from","to","AnimationRange","i","nBones","animations","createRange","deleteAnimationRange","deleteFrames","deleteRange","getAnimationRange","getAnimationRanges","animationRanges","push","copyAnimationRange","source","rescaleAsRequired","frameOffset","_getHighestAnimationFrame","boneDict","sourceBones","Logger","Warn","skelDimensionsRatio","dimensionsAtRest","divide","boneName","sourceBone","range","returnToRest","bone","_index","highest","getHighestFrame","beginAnimation","loop","speedRatio","onAnimationEnd","MakeAnimationAdditive","skeleton","referenceFrame","rangeValue","sceneAnimatables","getAllAnimatablesByTarget","rangeAnimatable","index","sceneAnimatable","fromFrame","toFrame","animatables","getAnimatables","animIndex","Animation","isAdditive","_registerMeshWithPoseMatrix","_unregisterMeshWithPoseMatrix","indexOf","splice","_computeTransformMatrices","targetMatrix","initialSkinMatrix","notifyObservers","_childUpdateId","parentBone","getLocalMatrix","multiplyToRef","getFinalMatrix","copyFrom","mappedIndex","getAbsoluteInverseBindMatrix","multiplyToArray","copyToArray","dontCheckFrameId","currentRenderId","getRenderId","_linkedTransformNode","node","position","rotationQuaternion","rotation","scaling","poseMatrix","getPoseMatrix","needsUpdate","Float32Array","_synchronizedWithMesh","getBindMatrix","TmpVectors","_updateAbsoluteBindMatrices","textureWidth","getSize","width","dispose","RawTexture","CreateRGBATexture","Constants","TEXTURE_NEAREST_SAMPLINGMODE","TEXTURETYPE_FLOAT","update","_animatables","clone","result","parent","parentIndex","Bone","getRestMatrix","linkTransformNode","DeepCopier","DeepCopy","rangeName","enableBlending","blendingSpeed","animation","stopAnimation","removeSkeleton","skeletons","serialize","serializationObject","asArray","serializedBone","parentBoneIndex","getIndex","matrix","rest","linkedTransformNodeId","getTransformNode","ranges","Parse","parsedSkeleton","Vector3","FromArray","parsedBone","parsedBoneIndex","undefined","_waitingTransformNodeId","data","computeAbsoluteMatrices","forceUpdate","computeAbsoluteTransforms","sortBones","visited","_sortBones","setCurrentPoseAsRest"],"mappings":"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"}