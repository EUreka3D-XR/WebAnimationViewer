{"version":3,"file":"engine.multiRender-DyBGUrkO.esm.min.js","sources":["../../../../../dev/core/dist/Engines/Extensions/engine.multiRender.js"],"sourcesContent":["import { InternalTexture } from \"../../Materials/Textures/internalTexture\";\nimport { Logger } from \"../../Misc/logger\";\nimport { Constants } from \"../constants\";\nimport { ThinEngine } from \"../thinEngine\";\nThinEngine.prototype.restoreSingleAttachment = function () {\n    const gl = this._gl;\n    this.bindAttachments([gl.BACK]);\n};\nThinEngine.prototype.restoreSingleAttachmentForRenderTarget = function () {\n    const gl = this._gl;\n    this.bindAttachments([gl.COLOR_ATTACHMENT0]);\n};\nThinEngine.prototype.buildTextureLayout = function (textureStatus, backBufferLayout = false) {\n    const gl = this._gl;\n    const result = [];\n    if (backBufferLayout) {\n        result.push(gl.BACK);\n    }\n    else {\n        for (let i = 0; i < textureStatus.length; i++) {\n            if (textureStatus[i]) {\n                result.push(gl[\"COLOR_ATTACHMENT\" + i]);\n            }\n            else {\n                result.push(gl.NONE);\n            }\n        }\n    }\n    return result;\n};\nThinEngine.prototype.bindAttachments = function (attachments) {\n    const gl = this._gl;\n    gl.drawBuffers(attachments);\n};\nThinEngine.prototype.unBindMultiColorAttachmentFramebuffer = function (rtWrapper, disableGenerateMipMaps = false, onBeforeUnbind) {\n    this._currentRenderTarget = null;\n    if (!rtWrapper.disableAutomaticMSAAResolve) {\n        this.resolveMultiFramebuffer(rtWrapper);\n    }\n    if (!disableGenerateMipMaps) {\n        this.generateMipMapsMultiFramebuffer(rtWrapper);\n    }\n    if (onBeforeUnbind) {\n        if (rtWrapper._MSAAFramebuffer) {\n            // Bind the correct framebuffer\n            this._bindUnboundFramebuffer(rtWrapper._framebuffer);\n        }\n        onBeforeUnbind();\n    }\n    this._bindUnboundFramebuffer(null);\n};\nThinEngine.prototype.createMultipleRenderTarget = function (size, options, initializeBuffers = true) {\n    let generateMipMaps = false;\n    let generateDepthBuffer = true;\n    let generateStencilBuffer = false;\n    let generateDepthTexture = false;\n    let depthTextureFormat = undefined;\n    let textureCount = 1;\n    let samples = 1;\n    const defaultType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\n    const defaultSamplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\n    const defaultUseSRGBBuffer = false;\n    const defaultFormat = Constants.TEXTUREFORMAT_RGBA;\n    const defaultTarget = Constants.TEXTURE_2D;\n    let types = [];\n    let samplingModes = [];\n    let useSRGBBuffers = [];\n    let formats = [];\n    let targets = [];\n    let faceIndex = [];\n    let layerIndex = [];\n    let layers = [];\n    let labels = [];\n    let dontCreateTextures = false;\n    const rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size);\n    if (options !== undefined) {\n        generateMipMaps = options.generateMipMaps === undefined ? false : options.generateMipMaps;\n        generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n        generateStencilBuffer = options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\n        generateDepthTexture = options.generateDepthTexture === undefined ? false : options.generateDepthTexture;\n        textureCount = options.textureCount ?? 1;\n        samples = options.samples ?? samples;\n        types = options.types || types;\n        samplingModes = options.samplingModes || samplingModes;\n        useSRGBBuffers = options.useSRGBBuffers || useSRGBBuffers;\n        formats = options.formats || formats;\n        targets = options.targetTypes || targets;\n        faceIndex = options.faceIndex || faceIndex;\n        layerIndex = options.layerIndex || layerIndex;\n        layers = options.layerCounts || layers;\n        labels = options.labels || labels;\n        dontCreateTextures = options.dontCreateTextures ?? false;\n        if (this.webGLVersion > 1 &&\n            (options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 ||\n                options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8 ||\n                options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24 ||\n                options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32_FLOAT ||\n                options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8)) {\n            depthTextureFormat = options.depthTextureFormat;\n        }\n    }\n    if (depthTextureFormat === undefined) {\n        depthTextureFormat = generateStencilBuffer ? Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 : Constants.TEXTUREFORMAT_DEPTH32_FLOAT;\n    }\n    const gl = this._gl;\n    // Create the framebuffer\n    const currentFramebuffer = this._currentFramebuffer;\n    const framebuffer = gl.createFramebuffer();\n    this._bindUnboundFramebuffer(framebuffer);\n    const width = size.width ?? size;\n    const height = size.height ?? size;\n    const textures = [];\n    const attachments = [];\n    const useStencilTexture = this.webGLVersion > 1 &&\n        (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 ||\n            depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8 ||\n            depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8);\n    rtWrapper.label = options?.label ?? \"MultiRenderTargetWrapper\";\n    rtWrapper._framebuffer = framebuffer;\n    rtWrapper._generateDepthBuffer = generateDepthTexture || generateDepthBuffer;\n    rtWrapper._generateStencilBuffer = generateDepthTexture ? useStencilTexture : generateStencilBuffer;\n    rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(rtWrapper._generateStencilBuffer, rtWrapper._generateDepthBuffer, width, height, 1, depthTextureFormat);\n    rtWrapper._attachments = attachments;\n    for (let i = 0; i < textureCount; i++) {\n        let samplingMode = samplingModes[i] || defaultSamplingMode;\n        let type = types[i] || defaultType;\n        let useSRGBBuffer = useSRGBBuffers[i] || defaultUseSRGBBuffer;\n        const format = formats[i] || defaultFormat;\n        const target = targets[i] || defaultTarget;\n        const layerCount = layers[i] ?? 1;\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\n            // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\n        }\n        else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\n            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\n        }\n        const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\n            type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\n            Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\n        }\n        useSRGBBuffer = useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU);\n        const isWebGL2 = this.webGLVersion > 1;\n        const attachment = gl[isWebGL2 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\n        attachments.push(attachment);\n        if (target === -1 || dontCreateTextures) {\n            continue;\n        }\n        const texture = new InternalTexture(this, 6 /* InternalTextureSource.MultiRenderTarget */);\n        textures[i] = texture;\n        gl.activeTexture(gl[\"TEXTURE\" + i]);\n        gl.bindTexture(target, texture._hardwareTexture.underlyingResource);\n        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, filters.mag);\n        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, filters.min);\n        gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        const internalSizedFormat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);\n        const internalFormat = this._getInternalFormat(format);\n        const webGLTextureType = this._getWebGLTextureType(type);\n        if (isWebGL2 && (target === Constants.TEXTURE_2D_ARRAY || target === Constants.TEXTURE_3D)) {\n            if (target === Constants.TEXTURE_2D_ARRAY) {\n                texture.is2DArray = true;\n            }\n            else {\n                texture.is3D = true;\n            }\n            texture.baseDepth = texture.depth = layerCount;\n            gl.texImage3D(target, 0, internalSizedFormat, width, height, layerCount, 0, internalFormat, webGLTextureType, null);\n        }\n        else if (target === Constants.TEXTURE_CUBE_MAP) {\n            // We have to generate all faces to complete the framebuffer\n            for (let i = 0; i < 6; i++) {\n                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, internalSizedFormat, width, height, 0, internalFormat, webGLTextureType, null);\n            }\n            texture.isCube = true;\n        }\n        else {\n            gl.texImage2D(gl.TEXTURE_2D, 0, internalSizedFormat, width, height, 0, internalFormat, webGLTextureType, null);\n        }\n        if (generateMipMaps) {\n            gl.generateMipmap(target);\n        }\n        // Unbind\n        this._bindTextureDirectly(target, null);\n        texture.baseWidth = width;\n        texture.baseHeight = height;\n        texture.width = width;\n        texture.height = height;\n        texture.isReady = true;\n        texture.samples = 1;\n        texture.generateMipMaps = generateMipMaps;\n        texture.samplingMode = samplingMode;\n        texture.type = type;\n        texture._useSRGBBuffer = useSRGBBuffer;\n        texture.format = format;\n        texture.label = labels[i] ?? rtWrapper.label + \"-Texture\" + i;\n        this._internalTexturesCache.push(texture);\n    }\n    if (generateDepthTexture && this._caps.depthTextureExtension && !dontCreateTextures) {\n        // Depth texture\n        const depthTexture = new InternalTexture(this, 14 /* InternalTextureSource.Depth */);\n        let depthTextureType = Constants.TEXTURETYPE_UNSIGNED_SHORT;\n        let glDepthTextureInternalFormat = gl.DEPTH_COMPONENT16;\n        let glDepthTextureFormat = gl.DEPTH_COMPONENT;\n        let glDepthTextureType = gl.UNSIGNED_SHORT;\n        let glDepthTextureAttachment = gl.DEPTH_ATTACHMENT;\n        if (this.webGLVersion < 2) {\n            glDepthTextureInternalFormat = gl.DEPTH_COMPONENT;\n        }\n        else {\n            if (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32_FLOAT) {\n                depthTextureType = Constants.TEXTURETYPE_FLOAT;\n                glDepthTextureType = gl.FLOAT;\n                glDepthTextureInternalFormat = gl.DEPTH_COMPONENT32F;\n            }\n            else if (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8) {\n                depthTextureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\n                glDepthTextureType = gl.FLOAT_32_UNSIGNED_INT_24_8_REV;\n                glDepthTextureInternalFormat = gl.DEPTH32F_STENCIL8;\n                glDepthTextureFormat = gl.DEPTH_STENCIL;\n                glDepthTextureAttachment = gl.DEPTH_STENCIL_ATTACHMENT;\n            }\n            else if (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24) {\n                depthTextureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\n                glDepthTextureType = gl.UNSIGNED_INT;\n                glDepthTextureInternalFormat = gl.DEPTH_COMPONENT24;\n                glDepthTextureAttachment = gl.DEPTH_ATTACHMENT;\n            }\n            else if (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 || depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8) {\n                depthTextureType = Constants.TEXTURETYPE_UNSIGNED_INT_24_8;\n                glDepthTextureType = gl.UNSIGNED_INT_24_8;\n                glDepthTextureInternalFormat = gl.DEPTH24_STENCIL8;\n                glDepthTextureFormat = gl.DEPTH_STENCIL;\n                glDepthTextureAttachment = gl.DEPTH_STENCIL_ATTACHMENT;\n            }\n        }\n        this._bindTextureDirectly(gl.TEXTURE_2D, depthTexture, true);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texImage2D(gl.TEXTURE_2D, 0, glDepthTextureInternalFormat, width, height, 0, glDepthTextureFormat, glDepthTextureType, null);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, glDepthTextureAttachment, gl.TEXTURE_2D, depthTexture._hardwareTexture.underlyingResource, 0);\n        this._bindTextureDirectly(gl.TEXTURE_2D, null);\n        rtWrapper._depthStencilTexture = depthTexture;\n        rtWrapper._depthStencilTextureWithStencil = useStencilTexture;\n        depthTexture.baseWidth = width;\n        depthTexture.baseHeight = height;\n        depthTexture.width = width;\n        depthTexture.height = height;\n        depthTexture.isReady = true;\n        depthTexture.samples = 1;\n        depthTexture.generateMipMaps = generateMipMaps;\n        depthTexture.samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\n        depthTexture.format = depthTextureFormat;\n        depthTexture.type = depthTextureType;\n        depthTexture.label = rtWrapper.label + \"-DepthStencil\";\n        textures[textureCount] = depthTexture;\n        this._internalTexturesCache.push(depthTexture);\n    }\n    rtWrapper.setTextures(textures);\n    if (initializeBuffers) {\n        gl.drawBuffers(attachments);\n    }\n    this._bindUnboundFramebuffer(currentFramebuffer);\n    rtWrapper.setLayerAndFaceIndices(layerIndex, faceIndex);\n    this.resetTextureCache();\n    if (!dontCreateTextures) {\n        this.updateMultipleRenderTargetTextureSampleCount(rtWrapper, samples, initializeBuffers);\n    }\n    else if (samples > 1) {\n        const framebuffer = gl.createFramebuffer();\n        if (!framebuffer) {\n            throw new Error(\"Unable to create multi sampled framebuffer\");\n        }\n        rtWrapper._samples = samples;\n        rtWrapper._MSAAFramebuffer = framebuffer;\n        if (textureCount > 0 && initializeBuffers) {\n            this._bindUnboundFramebuffer(framebuffer);\n            gl.drawBuffers(attachments);\n            this._bindUnboundFramebuffer(currentFramebuffer);\n        }\n    }\n    return rtWrapper;\n};\nThinEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function (rtWrapper, samples, initializeBuffers = true) {\n    if (this.webGLVersion < 2 || !rtWrapper) {\n        return 1;\n    }\n    if (rtWrapper.samples === samples) {\n        return samples;\n    }\n    const gl = this._gl;\n    samples = Math.min(samples, this.getCaps().maxMSAASamples);\n    // Dispose previous render buffers\n    if (rtWrapper._depthStencilBuffer) {\n        gl.deleteRenderbuffer(rtWrapper._depthStencilBuffer);\n        rtWrapper._depthStencilBuffer = null;\n    }\n    if (rtWrapper._MSAAFramebuffer) {\n        gl.deleteFramebuffer(rtWrapper._MSAAFramebuffer);\n        rtWrapper._MSAAFramebuffer = null;\n    }\n    const count = rtWrapper._attachments.length; // We do it this way instead of rtWrapper.textures.length to avoid taking into account the depth/stencil texture, in case it has been created\n    for (let i = 0; i < count; i++) {\n        const texture = rtWrapper.textures[i];\n        const hardwareTexture = texture._hardwareTexture;\n        hardwareTexture?.releaseMSAARenderBuffers();\n    }\n    if (samples > 1 && typeof gl.renderbufferStorageMultisample === \"function\") {\n        const framebuffer = gl.createFramebuffer();\n        if (!framebuffer) {\n            throw new Error(\"Unable to create multi sampled framebuffer\");\n        }\n        rtWrapper._MSAAFramebuffer = framebuffer;\n        this._bindUnboundFramebuffer(framebuffer);\n        const attachments = [];\n        for (let i = 0; i < count; i++) {\n            const texture = rtWrapper.textures[i];\n            const hardwareTexture = texture._hardwareTexture;\n            const attachment = gl[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\n            const colorRenderbuffer = this._createRenderBuffer(texture.width, texture.height, samples, -1 /* not used */, this._getRGBABufferInternalSizedFormat(texture.type, texture.format, texture._useSRGBBuffer), attachment);\n            if (!colorRenderbuffer) {\n                throw new Error(\"Unable to create multi sampled framebuffer\");\n            }\n            hardwareTexture.addMSAARenderBuffer(colorRenderbuffer);\n            texture.samples = samples;\n            attachments.push(attachment);\n        }\n        if (initializeBuffers) {\n            gl.drawBuffers(attachments);\n        }\n    }\n    else {\n        this._bindUnboundFramebuffer(rtWrapper._framebuffer);\n    }\n    const depthFormat = rtWrapper._depthStencilTexture ? rtWrapper._depthStencilTexture.format : undefined;\n    rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(rtWrapper._generateStencilBuffer, rtWrapper._generateDepthBuffer, rtWrapper.width, rtWrapper.height, samples, depthFormat);\n    this._bindUnboundFramebuffer(null);\n    rtWrapper._samples = samples;\n    return samples;\n};\nThinEngine.prototype.generateMipMapsMultiFramebuffer = function (texture) {\n    const rtWrapper = texture;\n    const gl = this._gl;\n    if (!rtWrapper.isMulti) {\n        return;\n    }\n    for (let i = 0; i < rtWrapper._attachments.length; i++) {\n        const texture = rtWrapper.textures[i];\n        if (texture?.generateMipMaps && !texture?.isCube && !texture?.is3D) {\n            this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);\n            gl.generateMipmap(gl.TEXTURE_2D);\n            this._bindTextureDirectly(gl.TEXTURE_2D, null);\n        }\n    }\n};\nThinEngine.prototype.resolveMultiFramebuffer = function (texture) {\n    const rtWrapper = texture;\n    const gl = this._gl;\n    if (!rtWrapper._MSAAFramebuffer || !rtWrapper.isMulti) {\n        return;\n    }\n    let bufferBits = rtWrapper.resolveMSAAColors ? gl.COLOR_BUFFER_BIT : 0;\n    bufferBits |= rtWrapper._generateDepthBuffer && rtWrapper.resolveMSAADepth ? gl.DEPTH_BUFFER_BIT : 0;\n    bufferBits |= rtWrapper._generateStencilBuffer && rtWrapper.resolveMSAAStencil ? gl.STENCIL_BUFFER_BIT : 0;\n    const attachments = rtWrapper._attachments;\n    const count = attachments.length;\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, rtWrapper._MSAAFramebuffer);\n    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, rtWrapper._framebuffer);\n    for (let i = 0; i < count; i++) {\n        const texture = rtWrapper.textures[i];\n        for (let j = 0; j < count; j++) {\n            attachments[j] = gl.NONE;\n        }\n        attachments[i] = gl[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\n        gl.readBuffer(attachments[i]);\n        gl.drawBuffers(attachments);\n        gl.blitFramebuffer(0, 0, texture.width, texture.height, 0, 0, texture.width, texture.height, bufferBits, gl.NEAREST);\n    }\n    for (let i = 0; i < count; i++) {\n        attachments[i] = gl[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\n    }\n    gl.drawBuffers(attachments);\n    gl.bindFramebuffer(this._gl.FRAMEBUFFER, rtWrapper._MSAAFramebuffer);\n};\n//# sourceMappingURL=engine.multiRender.js.map"],"names":["ThinEngine","prototype","restoreSingleAttachment","gl","this","_gl","bindAttachments","BACK","restoreSingleAttachmentForRenderTarget","COLOR_ATTACHMENT0","buildTextureLayout","textureStatus","backBufferLayout","result","push","i","length","NONE","attachments","drawBuffers","unBindMultiColorAttachmentFramebuffer","rtWrapper","disableGenerateMipMaps","onBeforeUnbind","_currentRenderTarget","disableAutomaticMSAAResolve","resolveMultiFramebuffer","generateMipMapsMultiFramebuffer","_MSAAFramebuffer","_bindUnboundFramebuffer","_framebuffer","createMultipleRenderTarget","size","options","initializeBuffers","depthTextureFormat","generateMipMaps","generateDepthBuffer","generateStencilBuffer","generateDepthTexture","textureCount","samples","defaultType","Constants","TEXTURETYPE_UNSIGNED_BYTE","defaultSamplingMode","TEXTURE_TRILINEAR_SAMPLINGMODE","defaultFormat","TEXTUREFORMAT_RGBA","defaultTarget","TEXTURE_2D","types","samplingModes","useSRGBBuffers","formats","targets","faceIndex","layerIndex","layers","labels","dontCreateTextures","_createHardwareRenderTargetWrapper","undefined","targetTypes","layerCounts","webGLVersion","TEXTUREFORMAT_DEPTH24_STENCIL8","TEXTUREFORMAT_DEPTH24UNORM_STENCIL8","TEXTUREFORMAT_DEPTH24","TEXTUREFORMAT_DEPTH32_FLOAT","TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8","currentFramebuffer","_currentFramebuffer","framebuffer","createFramebuffer","width","height","textures","useStencilTexture","label","_generateDepthBuffer","_generateStencilBuffer","_depthStencilBuffer","_setupFramebufferDepthAttachments","_attachments","samplingMode","type","useSRGBBuffer","format","target","layerCount","TEXTURETYPE_FLOAT","_caps","textureFloatLinearFiltering","TEXTURETYPE_HALF_FLOAT","textureHalfFloatLinearFiltering","TEXTURE_NEAREST_SAMPLINGMODE","filters","_getSamplingParameters","textureFloat","Logger","Warn","supportSRGBBuffers","isWebGPU","isWebGL2","attachment","texture","InternalTexture","activeTexture","bindTexture","_hardwareTexture","underlyingResource","texParameteri","TEXTURE_MAG_FILTER","mag","TEXTURE_MIN_FILTER","min","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","internalSizedFormat","_getRGBABufferInternalSizedFormat","internalFormat","_getInternalFormat","webGLTextureType","_getWebGLTextureType","TEXTURE_2D_ARRAY","TEXTURE_3D","TEXTURE_CUBE_MAP","texImage2D","TEXTURE_CUBE_MAP_POSITIVE_X","isCube","is2DArray","is3D","baseDepth","depth","texImage3D","generateMipmap","_bindTextureDirectly","baseWidth","baseHeight","isReady","_useSRGBBuffer","_internalTexturesCache","depthTextureExtension","depthTexture","depthTextureType","TEXTURETYPE_UNSIGNED_SHORT","glDepthTextureInternalFormat","DEPTH_COMPONENT16","glDepthTextureFormat","DEPTH_COMPONENT","glDepthTextureType","UNSIGNED_SHORT","glDepthTextureAttachment","DEPTH_ATTACHMENT","FLOAT","DEPTH_COMPONENT32F","FLOAT_32_UNSIGNED_INT_24_8_REV","DEPTH32F_STENCIL8","DEPTH_STENCIL","DEPTH_STENCIL_ATTACHMENT","UNSIGNED_INT","DEPTH_COMPONENT24","TEXTURETYPE_UNSIGNED_INT_24_8","UNSIGNED_INT_24_8","DEPTH24_STENCIL8","NEAREST","framebufferTexture2D","FRAMEBUFFER","_depthStencilTexture","_depthStencilTextureWithStencil","setTextures","setLayerAndFaceIndices","resetTextureCache","Error","_samples","updateMultipleRenderTargetTextureSampleCount","Math","getCaps","maxMSAASamples","deleteRenderbuffer","deleteFramebuffer","count","hardwareTexture","releaseMSAARenderBuffers","renderbufferStorageMultisample","colorRenderbuffer","_createRenderBuffer","addMSAARenderBuffer","depthFormat","isMulti","bufferBits","resolveMSAAColors","COLOR_BUFFER_BIT","resolveMSAADepth","DEPTH_BUFFER_BIT","resolveMSAAStencil","STENCIL_BUFFER_BIT","bindFramebuffer","READ_FRAMEBUFFER","DRAW_FRAMEBUFFER","j","readBuffer","blitFramebuffer"],"mappings":"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"}