import{C as e,S as t,Q as n,o as s,c3 as r,aF as i,bK as a,bJ as o}from"./index-BeBPThKX.esm.min.js";import{_ as l}from"./environmentTextureTools-Dw5blHnt.esm.min.js";import{CubeTexture as m}from"./cubeTexture-7G0wd05-.esm.min.js";import{GLTFLoader as c,ArrayItem as h}from"./glTFLoader-ASl42hNE.esm.min.js";import"./dumpTools-BaBBNyfl.esm.min.js";import"./abstractEngine.cubeTexture-Pdczw1PT.esm.min.js";import"./bone-4zSTwM2L.esm.min.js";import"./skeleton-BM6jc2S2.esm.min.js";import"./rawTexture-OHFtV4yv.esm.min.js";import"./assetContainer-C4iCgc7c.esm.min.js";import"./objectModelMapping-C_2yKgOV.esm.min.js";class d extends m{constructor(t,n,s,r=e.TEXTUREFORMAT_RGBA,i=e.TEXTURETYPE_UNSIGNED_BYTE,a=!1,o=!1,l=e.TEXTURE_TRILINEAR_SAMPLINGMODE,m=null){super("",t),this._texture=t.getEngine().createRawCubeTexture(n,s,r,i,a,o,l,m)}update(e,t,n,s,r=null){this._texture.getEngine().updateRawCubeTexture(this._texture,e,t,n,s,r)}updateRGBDAsync(e,t=null,n=.8,s=0){return l(this._texture,e,t,n,s).then((()=>{}))}clone(){return t.Clone((()=>{const e=this.getScene(),t=this._texture,n=new d(e,t._bufferViewArray,t.width,t.format,t.type,t.generateMipMaps,t.invertY,t.samplingMode,t._compression);return 13===t.source&&n.updateRGBDAsync(t._bufferViewArrayArray,t._sphericalPolynomial,t._lodGenerationScale,t._lodGenerationOffset),n}),this)}}const u="EXT_lights_image_based";class g{constructor(e){this.name=u,this._loader=e,this.enabled=this._loader.isExtensionUsed(u)}dispose(){this._loader=null,delete this._lights}onLoading(){const e=this._loader.gltf.extensions;if(e&&e[this.name]){const t=e[this.name];this._lights=t.lights}}loadSceneAsync(e,t){return c.LoadExtensionAsync(e,t,this.name,(async(n,s)=>{this._loader._allMaterialsDirtyRequired=!0;const r=new Array;r.push(this._loader.loadSceneAsync(e,t)),this._loader.logOpen(`${n}`);const i=h.Get(`${n}/light`,this._lights,s.light);return r.push(this._loadLightAsync(`/extensions/${this.name}/lights/${s.light}`,i).then((e=>{this._loader.babylonScene.environmentTexture=e}))),this._loader.logClose(),await Promise.all(r).then((()=>{}))}))}_loadLightAsync(e,t){if(!t._loaded){const a=new Array;this._loader.logOpen(`${e}`);const o=new Array(t.specularImages.length);for(let n=0;n<t.specularImages.length;n++){const s=t.specularImages[n];o[n]=new Array(s.length);for(let t=0;t<s.length;t++){const r=`${e}/specularImages/${n}/${t}`;this._loader.logOpen(`${r}`);const i=s[t],l=h.Get(r,this._loader.gltf.images,i);a.push(this._loader.loadImageAsync(`/images/${i}`,l).then((e=>{o[n][t]=e}))),this._loader.logClose()}}this._loader.logClose(),t._loaded=Promise.all(a).then((async()=>{const a=new d(this._loader.babylonScene,null,t.specularImageSize);if(a.name=t.name||"environment",t._babylonTexture=a,null!=t.intensity&&(a.level=t.intensity),t.rotation){let e=n.FromArray(t.rotation);this._loader.babylonScene.useRightHandedSystem||(e=n.Inverse(e)),s.FromQuaternionToRef(e,a.getReflectionTextureMatrix())}if(!t.irradianceCoefficients)throw new Error(`${e}: Irradiance coefficients are missing`);const l=r.FromArray(t.irradianceCoefficients);l.scaleInPlace(t.intensity),l.convertIrradianceToLambertianRadiance();const m=i.FromHarmonics(l),c=(o.length-1)/Math.log2(t.specularImageSize);return await a.updateRGBDAsync(o,m,c)}))}return t._loaded.then((()=>t._babylonTexture))}}a(u),o(u,!0,(e=>new g(e)));export{g as EXT_lights_image_based};
//# sourceMappingURL=EXT_lights_image_based-QPhttNCI.esm.min.js.map
