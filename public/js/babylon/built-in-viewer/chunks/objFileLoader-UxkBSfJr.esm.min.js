import{aW as s,T as t,h as e,G as i,V as o,d as r,L as n,bN as a,v as l,u as h,bW as _,p,aI as m}from"./index-BeBPThKX.esm.min.js";import{A as d}from"./assetContainer-C4iCgc7c.esm.min.js";import{S as c}from"./standardMaterial-DnuI_hxA.esm.min.js";class u{constructor(){this.materials=[]}parseMTL(t,e,i,o){if(e instanceof ArrayBuffer)return;const r=e.split("\n"),n=/\s+/;let a,l=null;for(let e=0;e<r.length;e++){const h=r[e].trim();if(0===h.length||"#"===h.charAt(0))continue;const _=h.indexOf(" ");let p=_>=0?h.substring(0,_):h;p=p.toLowerCase();const m=_>=0?h.substring(_+1).trim():"";if("newmtl"===p)l&&this.materials.push(l),t._blockEntityCollection=!!o,l=new c(m,t),l._parentContainer=o,t._blockEntityCollection=!1;else if("kd"===p&&l)a=m.split(n,3).map(parseFloat),l.diffuseColor=s.FromArray(a);else if("ka"===p&&l)a=m.split(n,3).map(parseFloat),l.ambientColor=s.FromArray(a);else if("ks"===p&&l)a=m.split(n,3).map(parseFloat),l.specularColor=s.FromArray(a);else if("ke"===p&&l)a=m.split(n,3).map(parseFloat),l.emissiveColor=s.FromArray(a);else if("ns"===p&&l)l.specularPower=parseFloat(m);else if("d"===p&&l)l.alpha=parseFloat(m);else if("map_ka"===p&&l)l.ambientTexture=u._GetTexture(i,m,t);else if("map_kd"===p&&l)l.diffuseTexture=u._GetTexture(i,m,t);else if("map_ks"===p&&l)l.specularTexture=u._GetTexture(i,m,t);else if("map_ns"===p);else if("map_bump"===p&&l){const s=m.split(n),e=s.indexOf("-bm");let o=null;e>=0&&(o=s[e+1],s.splice(e,2)),l.bumpTexture=u._GetTexture(i,s.join(" "),t),l.bumpTexture&&null!==o&&(l.bumpTexture.level=parseFloat(o))}else"map_d"===p&&l&&(l.opacityTexture=u._GetTexture(i,m,t))}l&&this.materials.push(l)}static _GetTexture(s,e,i){if(!e)return null;let o=s;if("file:"===s){let s=e.lastIndexOf("\\");-1===s&&(s=e.lastIndexOf("/")),o+=s>-1?e.substring(s+1):e}else o+=e;return new t(o,i,!1,u.INVERT_TEXTURE_Y)}}u.INVERT_TEXTURE_Y=!0;class F{constructor(s,t,i){this._positions=[],this._normals=[],this._uvs=[],this._colors=[],this._extColors=[],this._meshesFromObj=[],this._indicesForBabylon=[],this._wrappedPositionForBabylon=[],this._wrappedUvsForBabylon=[],this._wrappedColorsForBabylon=[],this._wrappedNormalsForBabylon=[],this._tuplePosNorm=[],this._curPositionInIndices=0,this._hasMeshes=!1,this._unwrappedPositionsForBabylon=[],this._unwrappedColorsForBabylon=[],this._unwrappedNormalsForBabylon=[],this._unwrappedUVForBabylon=[],this._triangles=[],this._materialNameFromObj="",this._objMeshName="",this._increment=1,this._isFirstMaterial=!0,this._grayColor=new e(.5,.5,.5,1),this._hasLineData=!1,this._materialToUse=s,this._babylonMeshesArray=t,this._loadingOptions=i}_isInArray(s,t){s[t[0]]||(s[t[0]]={normals:[],idx:[]});const e=s[t[0]].normals.indexOf(t[1]);return-1===e?-1:s[t[0]].idx[e]}_isInArrayUV(s,t){s[t[0]]||(s[t[0]]={normals:[],idx:[],uv:[]});const e=s[t[0]].normals.indexOf(t[1]);return 1!=e&&t[2]===s[t[0]].uv[e]?s[t[0]].idx[e]:-1}_setData(s){let t;s.indiceUvsFromObj??=-1,s.indiceNormalFromObj??=-1,t=this._loadingOptions.optimizeWithUV?this._isInArrayUV(this._tuplePosNorm,[s.indicePositionFromObj,s.indiceNormalFromObj,s.indiceUvsFromObj]):this._isInArray(this._tuplePosNorm,[s.indicePositionFromObj,s.indiceNormalFromObj]),-1===t?(this._indicesForBabylon.push(this._wrappedPositionForBabylon.length),this._wrappedPositionForBabylon.push(s.positionVectorFromOBJ),void 0!==s.textureVectorFromOBJ&&this._wrappedUvsForBabylon.push(s.textureVectorFromOBJ),void 0!==s.normalsVectorFromOBJ&&this._wrappedNormalsForBabylon.push(s.normalsVectorFromOBJ),void 0!==s.positionColorsFromOBJ&&this._wrappedColorsForBabylon.push(s.positionColorsFromOBJ),this._tuplePosNorm[s.indicePositionFromObj].normals.push(s.indiceNormalFromObj),this._tuplePosNorm[s.indicePositionFromObj].idx.push(this._curPositionInIndices++),this._loadingOptions.optimizeWithUV&&this._tuplePosNorm[s.indicePositionFromObj].uv.push(s.indiceUvsFromObj)):this._indicesForBabylon.push(t)}_unwrapData(){try{for(let s=0;s<this._wrappedPositionForBabylon.length;s++)this._unwrappedPositionsForBabylon.push(this._wrappedPositionForBabylon[s].x*this._handednessSign,this._wrappedPositionForBabylon[s].y,this._wrappedPositionForBabylon[s].z),this._wrappedNormalsForBabylon.length&&this._unwrappedNormalsForBabylon.push(this._wrappedNormalsForBabylon[s].x*this._handednessSign,this._wrappedNormalsForBabylon[s].y,this._wrappedNormalsForBabylon[s].z),this._wrappedUvsForBabylon.length&&this._unwrappedUVForBabylon.push(this._wrappedUvsForBabylon[s].x,this._wrappedUvsForBabylon[s].y),this._unwrappedColorsForBabylon.length&&this._unwrappedColorsForBabylon.push(this._wrappedColorsForBabylon[s].r,this._wrappedColorsForBabylon[s].g,this._wrappedColorsForBabylon[s].b,this._wrappedColorsForBabylon[s].a);this._wrappedPositionForBabylon.length=0,this._wrappedNormalsForBabylon.length=0,this._wrappedUvsForBabylon.length=0,this._wrappedColorsForBabylon.length=0,this._tuplePosNorm.length=0,this._curPositionInIndices=0}catch(s){throw new Error("Unable to unwrap data while parsing OBJ data.")}}_getTriangles(s,t){for(let e=t;e<s.length-1;e++)this._pushTriangle(s,e)}_getColor(s){return this._loadingOptions.importVertexColors?this._extColors[s]??this._colors[s]:void 0}_setDataForCurrentFaceWithPattern1(s,t){this._getTriangles(s,t);for(let s=0;s<this._triangles.length;s++){const t=parseInt(this._triangles[s])-1;this._setData({indicePositionFromObj:t,positionVectorFromOBJ:this._positions[t],positionColorsFromOBJ:this._getColor(t)})}this._triangles.length=0}_setDataForCurrentFaceWithPattern2(s,t){this._getTriangles(s,t);for(let s=0;s<this._triangles.length;s++){const t=this._triangles[s].split("/"),e=parseInt(t[0])-1,i=parseInt(t[1])-1;this._setData({indicePositionFromObj:e,indiceUvsFromObj:i,positionVectorFromOBJ:this._positions[e],textureVectorFromOBJ:this._uvs[i],positionColorsFromOBJ:this._getColor(e)})}this._triangles.length=0}_setDataForCurrentFaceWithPattern3(s,t){this._getTriangles(s,t);for(let s=0;s<this._triangles.length;s++){const t=this._triangles[s].split("/"),e=parseInt(t[0])-1,i=parseInt(t[1])-1,o=parseInt(t[2])-1;this._setData({indicePositionFromObj:e,indiceUvsFromObj:i,indiceNormalFromObj:o,positionVectorFromOBJ:this._positions[e],textureVectorFromOBJ:this._uvs[i],normalsVectorFromOBJ:this._normals[o]})}this._triangles.length=0}_setDataForCurrentFaceWithPattern4(s,t){this._getTriangles(s,t);for(let s=0;s<this._triangles.length;s++){const t=this._triangles[s].split("//"),e=parseInt(t[0])-1,i=parseInt(t[1])-1;this._setData({indicePositionFromObj:e,indiceNormalFromObj:i,positionVectorFromOBJ:this._positions[e],normalsVectorFromOBJ:this._normals[i],positionColorsFromOBJ:this._getColor(e)})}this._triangles.length=0}_setDataForCurrentFaceWithPattern5(s,t){this._getTriangles(s,t);for(let s=0;s<this._triangles.length;s++){const t=this._triangles[s].split("/"),e=this._positions.length+parseInt(t[0]),i=this._uvs.length+parseInt(t[1]),o=this._normals.length+parseInt(t[2]);this._setData({indicePositionFromObj:e,indiceUvsFromObj:i,indiceNormalFromObj:o,positionVectorFromOBJ:this._positions[e],textureVectorFromOBJ:this._uvs[i],normalsVectorFromOBJ:this._normals[o],positionColorsFromOBJ:this._getColor(e)})}this._triangles.length=0}_addPreviousObjMesh(){this._meshesFromObj.length>0&&(this._handledMesh=this._meshesFromObj[this._meshesFromObj.length-1],this._unwrapData(),this._loadingOptions.useLegacyBehavior&&this._indicesForBabylon.reverse(),this._handledMesh.indices=this._indicesForBabylon.slice(),this._handledMesh.positions=this._unwrappedPositionsForBabylon.slice(),this._unwrappedNormalsForBabylon.length&&(this._handledMesh.normals=this._unwrappedNormalsForBabylon.slice()),this._unwrappedUVForBabylon.length&&(this._handledMesh.uvs=this._unwrappedUVForBabylon.slice()),this._unwrappedColorsForBabylon.length&&(this._handledMesh.colors=this._unwrappedColorsForBabylon.slice()),this._handledMesh.hasLines=this._hasLineData,this._indicesForBabylon.length=0,this._unwrappedPositionsForBabylon.length=0,this._unwrappedColorsForBabylon.length=0,this._unwrappedNormalsForBabylon.length=0,this._unwrappedUVForBabylon.length=0,this._hasLineData=!1)}_optimizeNormals(s){const t=s.getVerticesData(i.PositionKind),e=s.getVerticesData(i.NormalKind),r={};if(!t||!e)return;for(let s=0;s<t.length/3;s++){const e=t[3*s+0]+"_"+t[3*s+1]+"_"+t[3*s+2];let i=r[e];i||(i=[],r[e]=i),i.push(s)}const n=new o;for(const s in r){const t=r[s];if(t.length<2)continue;const i=t[0];for(let s=1;s<t.length;++s){const o=t[s];e[3*i+0]+=e[3*o+0],e[3*i+1]+=e[3*o+1],e[3*i+2]+=e[3*o+2]}n.copyFromFloats(e[3*i+0],e[3*i+1],e[3*i+2]),n.normalize();for(let s=0;s<t.length;++s){const i=t[s];e[3*i+0]=n.x,e[3*i+1]=n.y,e[3*i+2]=n.z}}s.setVerticesData(i.NormalKind,e)}static _IsLineElement(s){return s.startsWith("l")}static _IsObjectElement(s){return s.startsWith("o")}static _IsGroupElement(s){return s.startsWith("g")}static _GetZbrushMRGB(s,t){if(!s.startsWith("mrgb"))return null;if(s=s.replace("mrgb","").trim(),t)return[];const i=s.match(/[a-z0-9]/g);if(!i||i.length%8!=0)return[];const o=[];for(let s=0;s<i.length/8;s++){const t=i[8*s+2]+i[8*s+3],r=i[8*s+4]+i[8*s+5],n=i[8*s+6]+i[8*s+7];o.push(new e(parseInt(t,16)/255,parseInt(r,16)/255,parseInt(n,16)/255,1))}return o}parse(t,i,_,p,m){i=(i=i.replace(/#MRGB/g,"mrgb")).replace(/#.*$/gm,"").trim(),this._loadingOptions.useLegacyBehavior?(this._pushTriangle=(s,t)=>this._triangles.push(s[0],s[t],s[t+1]),this._handednessSign=1):_.useRightHandedSystem?(this._pushTriangle=(s,t)=>this._triangles.push(s[0],s[t+1],s[t]),this._handednessSign=1):(this._pushTriangle=(s,t)=>this._triangles.push(s[0],s[t],s[t+1]),this._handednessSign=-1);const d=i.split("\n"),u=[];let b=[];u.push(b);for(let s=0;s<d.length;s++){const t=d[s].trim().replace(/\s\s/g," ");if(0!==t.length&&"#"!==t.charAt(0))if((F._IsGroupElement(t)||F._IsObjectElement(t))&&(b=[],u.push(b)),F._IsLineElement(t)){const s=t.split(" ");for(let t=1;t<s.length-1;t++)b.push(`l ${s[t]} ${s[t+1]}`)}else b.push(t)}const g=u.flat();for(let s=0;s<g.length;s++){const t=g[s].trim().replace(/\s\s/g," ");let i;if(0!==t.length&&"#"!==t.charAt(0))if(F.VertexPattern.test(t)){if(i=t.match(/[^ ]+/g),this._positions.push(new o(parseFloat(i[1]),parseFloat(i[2]),parseFloat(i[3]))),this._loadingOptions.importVertexColors)if(i.length>=7){const s=parseFloat(i[4]),t=parseFloat(i[5]),o=parseFloat(i[6]);this._colors.push(new e(s>1?s/255:s,t>1?t/255:t,o>1?o/255:o,7===i.length||void 0===i[7]?1:parseFloat(i[7])))}else this._colors.push(this._grayColor)}else if(null!==(i=F.NormalPattern.exec(t)))this._normals.push(new o(parseFloat(i[1]),parseFloat(i[2]),parseFloat(i[3])));else if(null!==(i=F.UVPattern.exec(t)))this._uvs.push(new r(parseFloat(i[1])*this._loadingOptions.UVScaling.x,parseFloat(i[2])*this._loadingOptions.UVScaling.y));else if(null!==(i=F.FacePattern3.exec(t)))this._setDataForCurrentFaceWithPattern3(i[1].trim().split(" "),1);else if(null!==(i=F.FacePattern4.exec(t)))this._setDataForCurrentFaceWithPattern4(i[1].trim().split(" "),1);else if(null!==(i=F.FacePattern5.exec(t)))this._setDataForCurrentFaceWithPattern5(i[1].trim().split(" "),1);else if(null!==(i=F.FacePattern2.exec(t)))this._setDataForCurrentFaceWithPattern2(i[1].trim().split(" "),1);else if(null!==(i=F.FacePattern1.exec(t)))this._setDataForCurrentFaceWithPattern1(i[1].trim().split(" "),1);else if(null!==(i=F.LinePattern1.exec(t)))this._setDataForCurrentFaceWithPattern1(i[1].trim().split(" "),0),this._hasLineData=!0;else if(null!==(i=F.LinePattern2.exec(t)))this._setDataForCurrentFaceWithPattern2(i[1].trim().split(" "),0),this._hasLineData=!0;else if(i=F._GetZbrushMRGB(t,!this._loadingOptions.importVertexColors))for(const s of i)this._extColors.push(s);else if(null!==(i=F.LinePattern3.exec(t)))this._setDataForCurrentFaceWithPattern3(i[1].trim().split(" "),0),this._hasLineData=!0;else if(F.GroupDescriptor.test(t)||F.ObjectDescriptor.test(t)){const s={name:t.substring(2).trim(),indices:null,positions:null,normals:null,uvs:null,colors:null,materialName:this._materialNameFromObj,isObject:F.ObjectDescriptor.test(t)};this._addPreviousObjMesh(),this._meshesFromObj.push(s),this._hasMeshes=!0,this._isFirstMaterial=!0,this._increment=1}else if(F.UseMtlDescriptor.test(t)){if(this._materialNameFromObj=t.substring(7).trim(),!this._isFirstMaterial||!this._hasMeshes){this._addPreviousObjMesh();const s={name:(this._objMeshName||"mesh")+"_mm"+this._increment.toString(),indices:null,positions:null,normals:null,uvs:null,colors:null,materialName:this._materialNameFromObj,isObject:!1};this._increment++,this._meshesFromObj.push(s),this._hasMeshes=!0}this._hasMeshes&&this._isFirstMaterial&&(this._meshesFromObj[this._meshesFromObj.length-1].materialName=this._materialNameFromObj,this._isFirstMaterial=!1)}else F.MtlLibGroupDescriptor.test(t)?m(t.substring(7).trim()):F.SmoothDescriptor.test(t)||n.Log("Unhandled expression at line : "+t)}if(this._hasMeshes&&(this._handledMesh=this._meshesFromObj[this._meshesFromObj.length-1],this._loadingOptions.useLegacyBehavior&&this._indicesForBabylon.reverse(),this._unwrapData(),this._handledMesh.indices=this._indicesForBabylon,this._handledMesh.positions=this._unwrappedPositionsForBabylon,this._unwrappedNormalsForBabylon.length&&(this._handledMesh.normals=this._unwrappedNormalsForBabylon),this._unwrappedUVForBabylon.length&&(this._handledMesh.uvs=this._unwrappedUVForBabylon),this._unwrappedColorsForBabylon.length&&(this._handledMesh.colors=this._unwrappedColorsForBabylon),this._handledMesh.hasLines=this._hasLineData),!this._hasMeshes){let t=null;if(this._indicesForBabylon.length)this._loadingOptions.useLegacyBehavior&&this._indicesForBabylon.reverse(),this._unwrapData();else{for(const s of this._positions)this._unwrappedPositionsForBabylon.push(s.x,s.y,s.z);if(this._normals.length)for(const s of this._normals)this._unwrappedNormalsForBabylon.push(s.x,s.y,s.z);if(this._uvs.length)for(const s of this._uvs)this._unwrappedUVForBabylon.push(s.x,s.y);if(this._extColors.length)for(const s of this._extColors)this._unwrappedColorsForBabylon.push(s.r,s.g,s.b,s.a);else if(this._colors.length)for(const s of this._colors)this._unwrappedColorsForBabylon.push(s.r,s.g,s.b,s.a);this._materialNameFromObj||(t=new c(a.RandomId(),_),t.pointsCloud=!0,this._materialNameFromObj=t.name,this._normals.length||(t.disableLighting=!0,t.emissiveColor=s.White()))}this._meshesFromObj.push({name:a.RandomId(),indices:this._indicesForBabylon,positions:this._unwrappedPositionsForBabylon,colors:this._unwrappedColorsForBabylon,normals:this._unwrappedNormalsForBabylon,uvs:this._unwrappedUVForBabylon,materialName:this._materialNameFromObj,directMaterial:t,isObject:!0,hasLines:this._hasLineData})}for(let s=0;s<this._meshesFromObj.length;s++){if(t&&this._meshesFromObj[s].name)if(t instanceof Array){if(-1===t.indexOf(this._meshesFromObj[s].name))continue}else if(this._meshesFromObj[s].name!==t)continue;this._handledMesh=this._meshesFromObj[s],_._blockEntityCollection=!!p;const e=new l(this._meshesFromObj[s].name,_);if(e._parentContainer=p,_._blockEntityCollection=!1,this._handledMesh._babylonMesh=e,!this._handledMesh.isObject)for(let t=s-1;t>=0;--t)if(this._meshesFromObj[t].isObject&&this._meshesFromObj[t]._babylonMesh){e.parent=this._meshesFromObj[t]._babylonMesh;break}if(this._materialToUse.push(this._meshesFromObj[s].materialName),this._handledMesh.hasLines&&(e._internalMetadata??={},e._internalMetadata._isLine=!0),0===this._handledMesh.positions?.length){this._babylonMeshesArray.push(e);continue}const i=new h;if(i.indices=this._handledMesh.indices,i.positions=this._handledMesh.positions,this._loadingOptions.computeNormals||!this._handledMesh.normals){const s=new Array;h.ComputeNormals(this._handledMesh.positions,this._handledMesh.indices,s),i.normals=s}else i.normals=this._handledMesh.normals;this._handledMesh.uvs&&(i.uvs=this._handledMesh.uvs),this._handledMesh.colors&&(i.colors=this._handledMesh.colors),i.applyToMesh(e),this._loadingOptions.invertY&&(e.scaling.y*=-1),this._loadingOptions.optimizeNormals&&this._optimizeNormals(e),this._babylonMeshesArray.push(e),this._handledMesh.directMaterial&&(e.material=this._handledMesh.directMaterial)}}}F.ObjectDescriptor=/^o/,F.GroupDescriptor=/^g/,F.MtlLibGroupDescriptor=/^mtllib /,F.UseMtlDescriptor=/^usemtl /,F.SmoothDescriptor=/^s /,F.VertexPattern=/^v(\s+[\d|.|+|\-|e|E]+){3,7}/,F.NormalPattern=/^vn(\s+[\d|.|+|\-|e|E]+)( +[\d|.|+|\-|e|E]+)( +[\d|.|+|\-|e|E]+)/,F.UVPattern=/^vt(\s+[\d|.|+|\-|e|E]+)( +[\d|.|+|\-|e|E]+)/,F.FacePattern1=/^f\s+(([\d]{1,}[\s]?){3,})+/,F.FacePattern2=/^f\s+((([\d]{1,}\/[\d]{1,}[\s]?){3,})+)/,F.FacePattern3=/^f\s+((([\d]{1,}\/[\d]{1,}\/[\d]{1,}[\s]?){3,})+)/,F.FacePattern4=/^f\s+((([\d]{1,}\/\/[\d]{1,}[\s]?){3,})+)/,F.FacePattern5=/^f\s+(((-[\d]{1,}\/-[\d]{1,}\/-[\d]{1,}[\s]?){3,})+)/,F.LinePattern1=/^l\s+(([\d]{1,}[\s]?){2,})+/,F.LinePattern2=/^l\s+((([\d]{1,}\/[\d]{1,}[\s]?){2,})+)/,F.LinePattern3=/^l\s+((([\d]{1,}\/[\d]{1,}\/[\d]{1,}[\s]?){2,})+)/;class b{static get INVERT_TEXTURE_Y(){return u.INVERT_TEXTURE_Y}static set INVERT_TEXTURE_Y(s){u.INVERT_TEXTURE_Y=s}constructor(s){this.name=_.name,this.extensions=_.extensions,this._assetContainer=null,this._loadingOptions={...b._DefaultLoadingOptions,...s??{}}}static get _DefaultLoadingOptions(){return{computeNormals:b.COMPUTE_NORMALS,optimizeNormals:b.OPTIMIZE_NORMALS,importVertexColors:b.IMPORT_VERTEX_COLORS,invertY:b.INVERT_Y,invertTextureY:b.INVERT_TEXTURE_Y,UVScaling:b.UV_SCALING,materialLoadingFailsSilently:b.MATERIAL_LOADING_FAILS_SILENTLY,optimizeWithUV:b.OPTIMIZE_WITH_UV,skipMaterials:b.SKIP_MATERIALS,useLegacyBehavior:b.USE_LEGACY_BEHAVIOR}}_loadMTL(s,t,e,i){const o=t+s;p.LoadFile(o,e,void 0,void 0,!1,((s,t)=>{i(o,t)}))}createPlugin(s){return new b(s[_.name])}canDirectLoad(){return!1}importMeshAsync(s,t,e,i){return this._parseSolidAsync(s,t,e,i).then((s=>({meshes:s,particleSystems:[],skeletons:[],animationGroups:[],transformNodes:[],geometries:[],lights:[],spriteManagers:[]})))}loadAsync(s,t,e){return this.importMeshAsync(null,s,t,e).then((()=>{}))}loadAssetContainerAsync(s,t,e){const i=new d(s);return this._assetContainer=i,this.importMeshAsync(null,s,t,e).then((s=>(s.meshes.forEach((s=>i.meshes.push(s))),s.meshes.forEach((s=>{const t=s.material;if(t&&-1==i.materials.indexOf(t)){i.materials.push(t);t.getActiveTextures().forEach((s=>{-1==i.textures.indexOf(s)&&i.textures.push(s)}))}})),this._assetContainer=null,i))).catch((s=>{throw this._assetContainer=null,s}))}_parseSolidAsync(s,t,e,i){let o="";const r=new u,n=[],a=[];e=e.replace(/#.*$/gm,"").trim();new F(n,a,this._loadingOptions).parse(s,e,t,this._assetContainer,(s=>{o=s}));const l=[];return""===o||this._loadingOptions.skipMaterials||l.push(new Promise(((s,e)=>{this._loadMTL(o,i,(l=>{try{r.parseMTL(t,l,i,this._assetContainer);for(let s=0;s<r.materials.length;s++){let t=0;const e=[];let i;for(;(i=n.indexOf(r.materials[s].name,t))>-1;)e.push(i),t=i+1;if(-1===i&&0===e.length)r.materials[s].dispose();else for(let t=0;t<e.length;t++){const i=a[e[t]],o=r.materials[s];i.material=o,i.getTotalIndices()||(o.pointsCloud=!0)}}s()}catch(t){p.Warn(`Error processing MTL file: '${o}'`),this._loadingOptions.materialLoadingFailsSilently?s():e(t)}}),((t,i)=>{p.Warn(`Error downloading MTL file: '${o}'`),this._loadingOptions.materialLoadingFailsSilently?s():e(i)}))}))),Promise.all(l).then((()=>{const s=s=>Boolean(s._internalMetadata?._isLine??!1);return a.forEach((e=>{if(s(e)){let i=e.material??new c(e.name+"_line",t);i.getBindedMeshes().filter((t=>!s(t))).length>0&&(i=i.clone(i.name+"_line")??i),i.wireframe=!0,e.material=i,e._internalMetadata&&(e._internalMetadata._isLine=void 0)}})),a}))}}b.OPTIMIZE_WITH_UV=!0,b.INVERT_Y=!1,b.IMPORT_VERTEX_COLORS=!1,b.COMPUTE_NORMALS=!1,b.OPTIMIZE_NORMALS=!1,b.UV_SCALING=new r(1,1),b.SKIP_MATERIALS=!1,b.MATERIAL_LOADING_FAILS_SILENTLY=!0,b.USE_LEGACY_BEHAVIOR=!1,m(new b);export{b as OBJFileLoader};
//# sourceMappingURL=objFileLoader-UxkBSfJr.esm.min.js.map
