import{aG as e,V as t,o,p as r,Q as n,aH as s,aI as i}from"./index-BeBPThKX.esm.min.js";import{A as a}from"./assetContainer-C4iCgc7c.esm.min.js";import{B as l}from"./bone-4zSTwM2L.esm.min.js";import{S as f}from"./skeleton-BM6jc2S2.esm.min.js";import"./rawTexture-OHFtV4yv.esm.min.js";const c="Xposition",p="Yposition",m="Zposition",h="Xrotation",d="Yrotation",u="Zrotation";class E{constructor(t){this.loopMode=e.ANIMATIONLOOPMODE_CYCLE,this.list=[],this.root=w(),this.numFrames=0,this.frameRate=0,this.skeleton=t}}function w(){return{name:"",type:"",offset:new t,channels:[],children:[],frames:[],parent:null}}function N(t,r,n){const s=function(e){const t=e.offset.x,r=e.offset.y,n=e.offset.z;return o.Translation(t,r,n)}(t),i=new l(t.name,n.skeleton,r,s),a=function(t,o){if(0===t.frames.length)return[];const r=[],n=t.channels.some((e=>e===c||e===p||e===m)),s=t.channels.some((e=>e===h||e===d||e===u)),i=new e(`${t.name}_pos`,"position",o.frameRate,e.ANIMATIONTYPE_VECTOR3,o.loopMode),a=new e(`${t.name}_rot`,"rotationQuaternion",o.frameRate,e.ANIMATIONTYPE_QUATERNION,o.loopMode),l=[],f=[];for(let e=0;e<t.frames.length;e++){const o=t.frames[e];n&&o.position&&l.push({frame:o.frame,value:o.position.clone()}),s&&f.push({frame:o.frame,value:o.rotation.clone()})}return l.length>0&&(i.setKeys(l),r.push(i)),f.length>0&&(a.setKeys(f),r.push(a)),r}(t,n);for(const e of a)e.getKeys()&&e.getKeys().length>0&&i.animations.push(e);for(const e of t.children)N(e,i,n)}function g(e,s,i,a){if("ENDSITE"===i.type)return;const l={frame:0,position:new t,rotation:new n};l.frame=s,l.position=new t,l.rotation=new n,i.frames.push(l);let f=o.Identity();for(let t=0;t<i.channels.length;++t){const n=i.channels[t],s=e[a.i++];if(!s)continue;const E=parseFloat(s.trim());if(n.endsWith("position"))switch(n){case c:l.position.x=E;break;case p:l.position.y=E;break;case m:l.position.z=E}else if(n.endsWith("rotation")){const e=r.ToRadians(E);let t;switch(n){case h:t=o.RotationX(e);break;case d:t=o.RotationY(e);break;case u:t=o.RotationZ(e)}f=t.multiply(f)}}n.FromRotationMatrixToRef(f,l.rotation);for(const t of i.children)g(e,s,t,a)}function I(e,o,r,n){const s=w();s.parent=r,n.list.push(s);let i=o.trim().split(/\s+/);if("END"===i[0].toUpperCase()&&"SITE"===i[1].toUpperCase()?(s.type="ENDSITE",s.name="ENDSITE"):(s.name=i[1],s.type=i[0].toUpperCase()),"{"!=e.shift()?.trim())throw new Error("Expected opening { after type & name");const a=e.shift()?.trim().split(/\s+/);if(!a)throw new Error("Unexpected end of file: missing OFFSET");if(i=a,"OFFSET"!=i[0].toUpperCase())throw new Error("Expected OFFSET, but got: "+i[0]);if(4!=i.length)throw new Error("OFFSET: Invalid number of values");const l=new t(parseFloat(i[1]),parseFloat(i[2]),parseFloat(i[3]));if(isNaN(l.x)||isNaN(l.y)||isNaN(l.z))throw new Error("OFFSET: Invalid values");if(s.offset=l,"ENDSITE"!=s.type){if(i=e.shift()?.trim().split(/\s+/),!i)throw new Error("Unexpected end of file: missing CHANNELS");if("CHANNELS"!=i[0].toUpperCase())throw new Error("Expected CHANNELS definition");const t=parseInt(i[1]);s.channels=i.splice(2,t),s.children=[]}for(;e.length>0;){const t=e.shift()?.trim();if("}"===t)return s;t&&s.children.push(I(e,t,s,n))}throw new Error("Unexpected end of file: missing closing brace")}function H(e,t,o,r){const n=e.split("\n"),{loopMode:s}=r;t._blockEntityCollection=!!o;const i=new f("","",t);i._parentContainer=o,t._blockEntityCollection=!1;const a=new E(i);a.loopMode=s;const l=n.shift();if(!l||"HIERARCHY"!==l.trim().toUpperCase())throw new Error("HIERARCHY expected");const c=n.shift();if(!c)throw new Error("Unexpected end of file after HIERARCHY");const p=I(n,c.trim(),null,a),m=n.shift();if(!m||"MOTION"!==m.trim().toUpperCase())throw new Error("MOTION expected");const h=n.shift();if(!h)throw new Error("Unexpected end of file before frame count");const d=h.trim().split(/[\s]+/);if(d.length<2)throw new Error("Invalid frame count line");const u=parseInt(d[1]);if(isNaN(u))throw new Error("Failed to read number of frames.");a.numFrames=u;const w=n.shift();if(!w)throw new Error("Unexpected end of file before frame time");const H=w.trim().split(/[\s]+/);if(H.length<3)throw new Error("Invalid frame time line");const y=parseFloat(H[2]);if(isNaN(y))throw new Error("Failed to read frame time.");if(y<=0)throw new Error("Failed to read frame time. Invalid value "+y);a.frameRate=1/y;for(let e=0;e<u;++e){const t=n.shift();if(!t)continue;g(t.trim().split(/[\s]+/)||[],e,p,{i:0})}return a.root=p,N(a.root,null,a),a.skeleton.returnToRest(),a.skeleton}class y{constructor(e){this.name=s.name,this.extensions=s.extensions,this._loadingOptions={...y._DefaultLoadingOptions,...e??{}}}static get _DefaultLoadingOptions(){return{loopMode:e.ANIMATIONLOOPMODE_CYCLE}}createPlugin(e){return new y(e[s.name])}canDirectLoad(e){return this.isBvhHeader(e)}isBvhHeader(e){return"HIERARCHY"==e.split("\n")[0]}isNotBvhHeader(e){return!this.isBvhHeader(e)}importMeshAsync(e,t,o){if("string"!=typeof o)return Promise.reject("BVH loader expects string data.");if(this.isNotBvhHeader(o))return Promise.reject("BVH loader expects HIERARCHY header.");try{const e=H(o,t,null,this._loadingOptions);return Promise.resolve({meshes:[],particleSystems:[],skeletons:[e],animationGroups:[],transformNodes:[],geometries:[],lights:[],spriteManagers:[]})}catch(e){return Promise.reject(e)}}loadAsync(e,t){return"string"!=typeof t?Promise.reject("BVH loader expects string data."):this.isNotBvhHeader(t)?Promise.reject("BVH loader expects HIERARCHY header."):this.importMeshAsync(null,e,t).then((()=>{}))}loadAssetContainerAsync(e,t){if("string"!=typeof t)return Promise.reject("BVH loader expects string data.");if(this.isNotBvhHeader(t))return Promise.reject("BVH loader expects HIERARCHY header.");const o=new a(e);try{const r=H(t,e,o,this._loadingOptions);return o.skeletons.push(r),Promise.resolve(o)}catch(e){return Promise.reject(e)}}}i(new y);export{y as BVHFileLoader};
//# sourceMappingURL=bvhFileLoader-BbSWRYks.esm.min.js.map
