{"version":3,"file":"objectModelMapping-C_2yKgOV.esm.min.js","sources":["../../../../../dev/core/dist/Lights/spotLight.js","../../../../../dev/loaders/dist/glTF/2.0/Extensions/gltfPathToObjectConverter.js","../../../../../dev/loaders/dist/glTF/2.0/Extensions/objectModelMapping.js"],"sourcesContent":["import { __decorate } from \"tslib\";\nimport { serialize, serializeAsTexture } from \"../Misc/decorators\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { Node } from \"../node\";\nimport { Light } from \"./light\";\nimport { ShadowLight } from \"./shadowLight\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { RegisterClass } from \"../Misc/typeStore\";\nimport { Constants } from \"core/Engines/constants\";\nNode.AddNodeConstructor(\"Light_Type_2\", (name, scene) => {\n    return () => new SpotLight(name, Vector3.Zero(), Vector3.Zero(), 0, 0, scene);\n});\n/**\n * A spot light is defined by a position, a direction, an angle, and an exponent.\n * These values define a cone of light starting from the position, emitting toward the direction.\n * The angle, in radians, defines the size (field of illumination) of the spotlight's conical beam,\n * and the exponent defines the speed of the decay of the light with distance (reach).\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n */\nexport class SpotLight extends ShadowLight {\n    /**\n     * Gets or sets the IES profile texture used to create the spotlight\n     * @see https://playground.babylonjs.com/#UIAXAU#1\n     */\n    get iesProfileTexture() {\n        return this._iesProfileTexture;\n    }\n    set iesProfileTexture(value) {\n        if (this._iesProfileTexture === value) {\n            return;\n        }\n        this._iesProfileTexture = value;\n        if (this._iesProfileTexture && SpotLight._IsTexture(this._iesProfileTexture)) {\n            this._iesProfileTexture.onLoadObservable.addOnce(() => {\n                this._markMeshesAsLightDirty();\n            });\n        }\n    }\n    /**\n     * Gets the cone angle of the spot light in Radians.\n     */\n    get angle() {\n        return this._angle;\n    }\n    /**\n     * Sets the cone angle of the spot light in Radians.\n     */\n    set angle(value) {\n        this._angle = value;\n        this._cosHalfAngle = Math.cos(value * 0.5);\n        this._projectionTextureProjectionLightDirty = true;\n        this.forceProjectionMatrixCompute();\n        this._computeAngleValues();\n    }\n    /**\n     * Only used in gltf falloff mode, this defines the angle where\n     * the directional falloff will start before cutting at angle which could be seen\n     * as outer angle.\n     */\n    get innerAngle() {\n        return this._innerAngle;\n    }\n    /**\n     * Only used in gltf falloff mode, this defines the angle where\n     * the directional falloff will start before cutting at angle which could be seen\n     * as outer angle.\n     */\n    set innerAngle(value) {\n        this._innerAngle = value;\n        this._computeAngleValues();\n    }\n    /**\n     * Allows scaling the angle of the light for shadow generation only.\n     */\n    get shadowAngleScale() {\n        return this._shadowAngleScale;\n    }\n    /**\n     * Allows scaling the angle of the light for shadow generation only.\n     */\n    set shadowAngleScale(value) {\n        this._shadowAngleScale = value;\n        this.forceProjectionMatrixCompute();\n    }\n    /**\n     * Allows reading the projection texture\n     */\n    get projectionTextureMatrix() {\n        return this._projectionTextureMatrix;\n    }\n    /**\n     * Gets the near clip of the Spotlight for texture projection.\n     */\n    get projectionTextureLightNear() {\n        return this._projectionTextureLightNear;\n    }\n    /**\n     * Sets the near clip of the Spotlight for texture projection.\n     */\n    set projectionTextureLightNear(value) {\n        this._projectionTextureLightNear = value;\n        this._projectionTextureProjectionLightDirty = true;\n    }\n    /**\n     * Gets the far clip of the Spotlight for texture projection.\n     */\n    get projectionTextureLightFar() {\n        return this._projectionTextureLightFar;\n    }\n    /**\n     * Sets the far clip of the Spotlight for texture projection.\n     */\n    set projectionTextureLightFar(value) {\n        this._projectionTextureLightFar = value;\n        this._projectionTextureProjectionLightDirty = true;\n    }\n    /**\n     * Gets the Up vector of the Spotlight for texture projection.\n     */\n    get projectionTextureUpDirection() {\n        return this._projectionTextureUpDirection;\n    }\n    /**\n     * Sets the Up vector of the Spotlight for texture projection.\n     */\n    set projectionTextureUpDirection(value) {\n        this._projectionTextureUpDirection = value;\n        this._projectionTextureProjectionLightDirty = true;\n    }\n    /**\n     * Gets the projection texture of the light.\n     */\n    get projectionTexture() {\n        return this._projectionTexture;\n    }\n    /**\n     * Sets the projection texture of the light.\n     */\n    set projectionTexture(value) {\n        if (this._projectionTexture === value) {\n            return;\n        }\n        this._projectionTexture = value;\n        this._projectionTextureDirty = true;\n        if (this._projectionTexture && !this._projectionTexture.isReady()) {\n            if (SpotLight._IsProceduralTexture(this._projectionTexture)) {\n                this._projectionTexture.getEffect().executeWhenCompiled(() => {\n                    this._markMeshesAsLightDirty();\n                });\n            }\n            else if (SpotLight._IsTexture(this._projectionTexture)) {\n                this._projectionTexture.onLoadObservable.addOnce(() => {\n                    this._markMeshesAsLightDirty();\n                });\n            }\n        }\n    }\n    static _IsProceduralTexture(texture) {\n        return texture.onGeneratedObservable !== undefined;\n    }\n    static _IsTexture(texture) {\n        return texture.onLoadObservable !== undefined;\n    }\n    /**\n     * Gets or sets the light projection matrix as used by the projection texture\n     */\n    get projectionTextureProjectionLightMatrix() {\n        return this._projectionTextureProjectionLightMatrix;\n    }\n    set projectionTextureProjectionLightMatrix(projection) {\n        this._projectionTextureProjectionLightMatrix = projection;\n        this._projectionTextureProjectionLightDirty = false;\n        this._projectionTextureDirty = true;\n    }\n    /**\n     * Creates a SpotLight object in the scene. A spot light is a simply light oriented cone.\n     * It can cast shadows.\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n     * @param name The light friendly name\n     * @param position The position of the spot light in the scene\n     * @param direction The direction of the light in the scene\n     * @param angle The cone angle of the light in Radians\n     * @param exponent The light decay speed with the distance from the emission spot\n     * @param scene The scene the lights belongs to\n     */\n    constructor(name, position, direction, angle, exponent, scene) {\n        super(name, scene);\n        this._innerAngle = 0;\n        this._iesProfileTexture = null;\n        this._projectionTextureMatrix = Matrix.Zero();\n        this._projectionTextureLightNear = 1e-6;\n        this._projectionTextureLightFar = 1000.0;\n        this._projectionTextureUpDirection = Vector3.Up();\n        this._projectionTextureViewLightDirty = true;\n        this._projectionTextureProjectionLightDirty = true;\n        this._projectionTextureDirty = true;\n        this._projectionTextureViewTargetVector = Vector3.Zero();\n        this._projectionTextureViewLightMatrix = Matrix.Zero();\n        this._projectionTextureProjectionLightMatrix = Matrix.Zero();\n        this._projectionTextureScalingMatrix = Matrix.FromValues(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);\n        this.position = position;\n        this.direction = direction;\n        this.angle = angle;\n        this.exponent = exponent;\n    }\n    /**\n     * Returns the string \"SpotLight\".\n     * @returns the class name\n     */\n    getClassName() {\n        return \"SpotLight\";\n    }\n    /**\n     * Returns the integer 2.\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    getTypeID() {\n        return Light.LIGHTTYPEID_SPOTLIGHT;\n    }\n    /**\n     * Overrides the direction setter to recompute the projection texture view light Matrix.\n     * @param value\n     */\n    _setDirection(value) {\n        super._setDirection(value);\n        this._projectionTextureViewLightDirty = true;\n    }\n    /**\n     * Overrides the position setter to recompute the projection texture view light Matrix.\n     * @param value\n     */\n    _setPosition(value) {\n        super._setPosition(value);\n        this._projectionTextureViewLightDirty = true;\n    }\n    /**\n     * Sets the passed matrix \"matrix\" as perspective projection matrix for the shadows and the passed view matrix with the fov equal to the SpotLight angle and and aspect ratio of 1.0.\n     * Returns the SpotLight.\n     * @param matrix\n     * @param viewMatrix\n     * @param renderList\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {\n        const activeCamera = this.getScene().activeCamera;\n        if (!activeCamera) {\n            return;\n        }\n        this._shadowAngleScale = this._shadowAngleScale || 1;\n        const angle = this._shadowAngleScale * this._angle;\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\n        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\n        Matrix.PerspectiveFovLHToRef(angle, 1.0, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, true, this._scene.getEngine().isNDCHalfZRange, undefined, useReverseDepthBuffer);\n    }\n    _computeProjectionTextureViewLightMatrix() {\n        this._projectionTextureViewLightDirty = false;\n        this._projectionTextureDirty = true;\n        this.getAbsolutePosition().addToRef(this.getShadowDirection(), this._projectionTextureViewTargetVector);\n        Matrix.LookAtLHToRef(this.getAbsolutePosition(), this._projectionTextureViewTargetVector, this._projectionTextureUpDirection, this._projectionTextureViewLightMatrix);\n    }\n    _computeProjectionTextureProjectionLightMatrix() {\n        this._projectionTextureProjectionLightDirty = false;\n        this._projectionTextureDirty = true;\n        const lightFar = this.projectionTextureLightFar;\n        const lightNear = this.projectionTextureLightNear;\n        const p = lightFar / (lightFar - lightNear);\n        const q = -p * lightNear;\n        const s = 1.0 / Math.tan(this._angle / 2.0);\n        const a = 1.0;\n        Matrix.FromValuesToRef(s / a, 0.0, 0.0, 0.0, 0.0, s, 0.0, 0.0, 0.0, 0.0, p, 1.0, 0.0, 0.0, q, 0.0, this._projectionTextureProjectionLightMatrix);\n    }\n    /**\n     * Main function for light texture projection matrix computing.\n     */\n    _computeProjectionTextureMatrix() {\n        this._projectionTextureDirty = false;\n        this._projectionTextureViewLightMatrix.multiplyToRef(this._projectionTextureProjectionLightMatrix, this._projectionTextureMatrix);\n        if (this._projectionTexture instanceof Texture) {\n            const u = this._projectionTexture.uScale / 2.0;\n            const v = this._projectionTexture.vScale / 2.0;\n            Matrix.FromValuesToRef(u, 0.0, 0.0, 0.0, 0.0, v, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0, this._projectionTextureScalingMatrix);\n        }\n        this._projectionTextureMatrix.multiplyToRef(this._projectionTextureScalingMatrix, this._projectionTextureMatrix);\n    }\n    _buildUniformLayout() {\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\n        this._uniformBuffer.addUniform(\"vLightDirection\", 3);\n        this._uniformBuffer.addUniform(\"vLightFalloff\", 4);\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\n        this._uniformBuffer.create();\n    }\n    _computeAngleValues() {\n        this._lightAngleScale = 1.0 / Math.max(0.001, Math.cos(this._innerAngle * 0.5) - this._cosHalfAngle);\n        this._lightAngleOffset = -this._cosHalfAngle * this._lightAngleScale;\n    }\n    /**\n     * Sets the passed Effect \"effect\" with the Light textures.\n     * @param effect The effect to update\n     * @param lightIndex The index of the light in the effect to update\n     * @returns The light\n     */\n    transferTexturesToEffect(effect, lightIndex) {\n        if (this.projectionTexture && this.projectionTexture.isReady()) {\n            if (this._projectionTextureViewLightDirty) {\n                this._computeProjectionTextureViewLightMatrix();\n            }\n            if (this._projectionTextureProjectionLightDirty) {\n                this._computeProjectionTextureProjectionLightMatrix();\n            }\n            if (this._projectionTextureDirty) {\n                this._computeProjectionTextureMatrix();\n            }\n            effect.setMatrix(\"textureProjectionMatrix\" + lightIndex, this._projectionTextureMatrix);\n            effect.setTexture(\"projectionLightTexture\" + lightIndex, this.projectionTexture);\n        }\n        if (this._iesProfileTexture && this._iesProfileTexture.isReady()) {\n            effect.setTexture(\"iesLightTexture\" + lightIndex, this._iesProfileTexture);\n        }\n        return this;\n    }\n    /**\n     * Sets the passed Effect object with the SpotLight transformed position (or position if not parented) and normalized direction.\n     * @param effect The effect to update\n     * @param lightIndex The index of the light in the effect to update\n     * @returns The spot light\n     */\n    transferToEffect(effect, lightIndex) {\n        let normalizeDirection;\n        if (this.computeTransformedInformation()) {\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedPosition.x - this._scene.floatingOriginOffset.x, this.transformedPosition.y - this._scene.floatingOriginOffset.y, this.transformedPosition.z - this._scene.floatingOriginOffset.z, this.exponent, lightIndex);\n            normalizeDirection = Vector3.Normalize(this.transformedDirection);\n        }\n        else {\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.position.x - this._scene.floatingOriginOffset.x, this.position.y - this._scene.floatingOriginOffset.y, this.position.z - this._scene.floatingOriginOffset.z, this.exponent, lightIndex);\n            normalizeDirection = Vector3.Normalize(this.direction);\n        }\n        this._uniformBuffer.updateFloat4(\"vLightDirection\", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, this._cosHalfAngle, lightIndex);\n        this._uniformBuffer.updateFloat4(\"vLightFalloff\", this.range, this._inverseSquaredRange, this._lightAngleScale, this._lightAngleOffset, lightIndex);\n        return this;\n    }\n    transferToNodeMaterialEffect(effect, lightDataUniformName) {\n        let normalizeDirection;\n        if (this.computeTransformedInformation()) {\n            normalizeDirection = Vector3.Normalize(this.transformedDirection);\n        }\n        else {\n            normalizeDirection = Vector3.Normalize(this.direction);\n        }\n        if (this.getScene().useRightHandedSystem) {\n            effect.setFloat3(lightDataUniformName, -normalizeDirection.x, -normalizeDirection.y, -normalizeDirection.z);\n        }\n        else {\n            effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);\n        }\n        return this;\n    }\n    /**\n     * Disposes the light and the associated resources.\n     */\n    dispose() {\n        super.dispose();\n        if (this._projectionTexture) {\n            this._projectionTexture.dispose();\n        }\n        if (this._iesProfileTexture) {\n            this._iesProfileTexture.dispose();\n            this._iesProfileTexture = null;\n        }\n    }\n    /**\n     * Gets the minZ used for shadow according to both the scene and the light.\n     * @param activeCamera The camera we are returning the min for\n     * @returns the depth min z\n     */\n    getDepthMinZ(activeCamera) {\n        const engine = this._scene.getEngine();\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : (activeCamera?.minZ ?? Constants.ShadowMinZ);\n        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? minZ : this._scene.getEngine().isNDCHalfZRange ? 0 : minZ;\n    }\n    /**\n     * Gets the maxZ used for shadow according to both the scene and the light.\n     * @param activeCamera The camera we are returning the max for\n     * @returns the depth max z\n     */\n    getDepthMaxZ(activeCamera) {\n        const engine = this._scene.getEngine();\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : (activeCamera?.maxZ ?? Constants.ShadowMaxZ);\n        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : maxZ;\n    }\n    /**\n     * Prepares the list of defines specific to the light type.\n     * @param defines the list of defines\n     * @param lightIndex defines the index of the light for the effect\n     */\n    prepareLightSpecificDefines(defines, lightIndex) {\n        defines[\"SPOTLIGHT\" + lightIndex] = true;\n        defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex] = this.projectionTexture && this.projectionTexture.isReady() ? true : false;\n        defines[\"IESLIGHTTEXTURE\" + lightIndex] = this._iesProfileTexture && this._iesProfileTexture.isReady() ? true : false;\n    }\n}\n__decorate([\n    serialize()\n], SpotLight.prototype, \"angle\", null);\n__decorate([\n    serialize()\n], SpotLight.prototype, \"innerAngle\", null);\n__decorate([\n    serialize()\n], SpotLight.prototype, \"shadowAngleScale\", null);\n__decorate([\n    serialize()\n], SpotLight.prototype, \"exponent\", void 0);\n__decorate([\n    serialize()\n], SpotLight.prototype, \"projectionTextureLightNear\", null);\n__decorate([\n    serialize()\n], SpotLight.prototype, \"projectionTextureLightFar\", null);\n__decorate([\n    serialize()\n], SpotLight.prototype, \"projectionTextureUpDirection\", null);\n__decorate([\n    serializeAsTexture(\"projectedLightTexture\")\n], SpotLight.prototype, \"_projectionTexture\", void 0);\n// Register Class Name\nRegisterClass(\"BABYLON.SpotLight\", SpotLight);\n//# sourceMappingURL=spotLight.js.map","/**\n * Adding an exception here will break traversing through the glTF object tree.\n * This is used for properties that might not be in the glTF object model, but are optional and have a default value.\n * For example, the path /nodes/\\{\\}/extensions/KHR_node_visibility/visible is optional - the object can be deferred without the object fully existing.\n */\nexport const OptionalPathExceptionsList = [\n    {\n        // get the node as object when reading an extension\n        regex: new RegExp(`^/nodes/\\\\d+/extensions/`),\n    },\n];\n/**\n * A converter that takes a glTF Object Model JSON Pointer\n * and transforms it into an ObjectAccessorContainer, allowing\n * objects referenced in the glTF to be associated with their\n * respective Babylon.js objects.\n */\nexport class GLTFPathToObjectConverter {\n    constructor(_gltf, _infoTree) {\n        this._gltf = _gltf;\n        this._infoTree = _infoTree;\n    }\n    /**\n     * The pointer string is represented by a [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901).\n     * See also https://github.com/KhronosGroup/glTF/blob/main/specification/2.0/ObjectModel.adoc#core-pointers\n     * <animationPointer> := /<rootNode>/<assetIndex>/<propertyPath>\n     * <rootNode> := \"nodes\" | \"materials\" | \"meshes\" | \"cameras\" | \"extensions\"\n     * <assetIndex> := <digit> | <name>\n     * <propertyPath> := <extensionPath> | <standardPath>\n     * <extensionPath> := \"extensions\"/<name>/<standardPath>\n     * <standardPath> := <name> | <name>/<standardPath>\n     * <name> := W+\n     * <digit> := D+\n     *\n     * Examples:\n     *  - \"/nodes/0/rotation\"\n     * - \"/nodes.length\"\n     *  - \"/materials/2/emissiveFactor\"\n     *  - \"/materials/2/pbrMetallicRoughness/baseColorFactor\"\n     *  - \"/materials/2/extensions/KHR_materials_emissive_strength/emissiveStrength\"\n     *\n     * @param path The path to convert\n     * @returns The object and info associated with the path\n     */\n    convert(path) {\n        let objectTree = this._gltf;\n        let infoTree = this._infoTree;\n        let target = undefined;\n        if (!path.startsWith(\"/\")) {\n            throw new Error(\"Path must start with a /\");\n        }\n        const parts = path.split(\"/\");\n        parts.shift();\n        //if the last part has \".length\" in it, separate that as an extra part\n        if (parts[parts.length - 1].includes(\".length\")) {\n            const lastPart = parts[parts.length - 1];\n            const split = lastPart.split(\".\");\n            parts.pop();\n            parts.push(...split);\n        }\n        let ignoreObjectTree = false;\n        for (const part of parts) {\n            const isLength = part === \"length\";\n            if (isLength && !infoTree.__array__) {\n                throw new Error(`Path ${path} is invalid`);\n            }\n            if (infoTree.__ignoreObjectTree__) {\n                ignoreObjectTree = true;\n            }\n            if (infoTree.__array__ && !isLength) {\n                infoTree = infoTree.__array__;\n            }\n            else {\n                infoTree = infoTree[part];\n                if (!infoTree) {\n                    throw new Error(`Path ${path} is invalid`);\n                }\n            }\n            if (!ignoreObjectTree) {\n                if (objectTree === undefined) {\n                    // check if the path is in the exception list. If it is, break and return the last object that was found\n                    const exception = OptionalPathExceptionsList.find((e) => e.regex.test(path));\n                    if (!exception) {\n                        throw new Error(`Path ${path} is invalid`);\n                    }\n                }\n                else if (!isLength) {\n                    objectTree = objectTree?.[part];\n                }\n            }\n            if (infoTree.__target__ || isLength) {\n                target = objectTree;\n            }\n        }\n        return {\n            object: target,\n            info: infoTree,\n        };\n    }\n}\n//# sourceMappingURL=gltfPathToObjectConverter.js.map","/* eslint-disable @typescript-eslint/naming-convention */\nimport { Matrix, Quaternion, Vector2 } from \"core/Maths/math.vector\";\nimport { Constants } from \"core/Engines/constants\";\nimport { Color4 } from \"core/Maths/math.color\";\nimport { SpotLight } from \"core/Lights/spotLight\";\nimport { GLTFPathToObjectConverter } from \"./gltfPathToObjectConverter\";\nconst nodesTree = {\n    length: {\n        type: \"number\",\n        get: (nodes) => nodes.length,\n        getTarget: (nodes) => nodes.map((node) => node._babylonTransformNode),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {\n        __target__: true,\n        translation: {\n            type: \"Vector3\",\n            get: (node) => node._babylonTransformNode?.position,\n            set: (value, node) => node._babylonTransformNode?.position.copyFrom(value),\n            getTarget: (node) => node._babylonTransformNode,\n            getPropertyName: [() => \"position\"],\n        },\n        rotation: {\n            type: \"Quaternion\",\n            get: (node) => node._babylonTransformNode?.rotationQuaternion,\n            set: (value, node) => node._babylonTransformNode?.rotationQuaternion?.copyFrom(value),\n            getTarget: (node) => node._babylonTransformNode,\n            getPropertyName: [() => \"rotationQuaternion\"],\n        },\n        scale: {\n            type: \"Vector3\",\n            get: (node) => node._babylonTransformNode?.scaling,\n            set: (value, node) => node._babylonTransformNode?.scaling.copyFrom(value),\n            getTarget: (node) => node._babylonTransformNode,\n            getPropertyName: [() => \"scaling\"],\n        },\n        weights: {\n            length: {\n                type: \"number\",\n                get: (node) => node._numMorphTargets,\n                getTarget: (node) => node._babylonTransformNode,\n                getPropertyName: [() => \"influence\"],\n            },\n            __array__: {\n                __target__: true,\n                type: \"number\",\n                get: (node, index) => (index !== undefined ? node._primitiveBabylonMeshes?.[0].morphTargetManager?.getTarget(index).influence : undefined),\n                // set: (value: number, node: INode, index?: number) => node._babylonTransformNode?.getMorphTargetManager()?.getTarget(index)?.setInfluence(value),\n                getTarget: (node) => node._babylonTransformNode,\n                getPropertyName: [() => \"influence\"],\n            },\n            type: \"number[]\",\n            get: (node, index) => [0], // TODO: get the weights correctly\n            // set: (value: number, node: INode, index?: number) => node._babylonTransformNode?.getMorphTargetManager()?.getTarget(index)?.setInfluence(value),\n            getTarget: (node) => node._babylonTransformNode,\n            getPropertyName: [() => \"influence\"],\n        },\n        // readonly!\n        matrix: {\n            type: \"Matrix\",\n            get: (node) => Matrix.Compose(node._babylonTransformNode?.scaling, node._babylonTransformNode?.rotationQuaternion, node._babylonTransformNode?.position),\n            getTarget: (node) => node._babylonTransformNode,\n            isReadOnly: true,\n        },\n        globalMatrix: {\n            type: \"Matrix\",\n            get: (node) => {\n                const matrix = Matrix.Identity();\n                // RHS/LHS support\n                let rootNode = node.parent;\n                while (rootNode && rootNode.parent) {\n                    rootNode = rootNode.parent;\n                }\n                const forceUpdate = node._babylonTransformNode?.position._isDirty || node._babylonTransformNode?.rotationQuaternion?._isDirty || node._babylonTransformNode?.scaling._isDirty;\n                if (rootNode) {\n                    // take the parent root node's world matrix, invert it, and multiply it with the current node's world matrix\n                    // This will provide the global matrix, ignoring the RHS->LHS conversion\n                    const rootMatrix = rootNode._babylonTransformNode?.computeWorldMatrix(true).invert();\n                    if (rootMatrix) {\n                        node._babylonTransformNode?.computeWorldMatrix(forceUpdate)?.multiplyToRef(rootMatrix, matrix);\n                    }\n                }\n                else if (node._babylonTransformNode) {\n                    matrix.copyFrom(node._babylonTransformNode.computeWorldMatrix(forceUpdate));\n                }\n                return matrix;\n            },\n            getTarget: (node) => node._babylonTransformNode,\n            isReadOnly: true,\n        },\n        extensions: {\n            EXT_lights_ies: {\n                multiplier: {\n                    type: \"number\",\n                    get: (node) => {\n                        return node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0]?.intensity;\n                    },\n                    getTarget: (node) => node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0],\n                    set: (value, node) => {\n                        if (node._babylonTransformNode) {\n                            const light = node._babylonTransformNode.getChildren((child) => child instanceof SpotLight, true)[0];\n                            if (light) {\n                                light.intensity = value;\n                            }\n                        }\n                    },\n                },\n                color: {\n                    type: \"Color3\",\n                    get: (node) => {\n                        return node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0]?.diffuse;\n                    },\n                    getTarget: (node) => node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0],\n                    set: (value, node) => {\n                        if (node._babylonTransformNode) {\n                            const light = node._babylonTransformNode.getChildren((child) => child instanceof SpotLight, true)[0];\n                            if (light) {\n                                light.diffuse = value;\n                            }\n                        }\n                    },\n                },\n            },\n        },\n    },\n};\nconst animationsTree = {\n    length: {\n        type: \"number\",\n        get: (animations) => animations.length,\n        getTarget: (animations) => animations.map((animation) => animation._babylonAnimationGroup),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {},\n};\nconst meshesTree = {\n    length: {\n        type: \"number\",\n        get: (meshes) => meshes.length,\n        getTarget: (meshes) => meshes.map((mesh) => mesh.primitives[0]._instanceData?.babylonSourceMesh),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {},\n};\nconst camerasTree = {\n    __array__: {\n        __target__: true,\n        orthographic: {\n            xmag: {\n                componentsCount: 2,\n                type: \"Vector2\",\n                get: (camera) => new Vector2(camera._babylonCamera?.orthoLeft ?? 0, camera._babylonCamera?.orthoRight ?? 0),\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.orthoLeft = value.x;\n                        camera._babylonCamera.orthoRight = value.y;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"orthoLeft\", () => \"orthoRight\"],\n            },\n            ymag: {\n                componentsCount: 2,\n                type: \"Vector2\",\n                get: (camera) => new Vector2(camera._babylonCamera?.orthoBottom ?? 0, camera._babylonCamera?.orthoTop ?? 0),\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.orthoBottom = value.x;\n                        camera._babylonCamera.orthoTop = value.y;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"orthoBottom\", () => \"orthoTop\"],\n            },\n            zfar: {\n                type: \"number\",\n                get: (camera) => camera._babylonCamera?.maxZ,\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.maxZ = value;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"maxZ\"],\n            },\n            znear: {\n                type: \"number\",\n                get: (camera) => camera._babylonCamera?.minZ,\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.minZ = value;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"minZ\"],\n            },\n        },\n        perspective: {\n            aspectRatio: {\n                type: \"number\",\n                get: (camera) => camera._babylonCamera?.getEngine().getAspectRatio(camera._babylonCamera),\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"aspectRatio\"],\n                isReadOnly: true, // might not be the case for glTF?\n            },\n            yfov: {\n                type: \"number\",\n                get: (camera) => camera._babylonCamera?.fov,\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.fov = value;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"fov\"],\n            },\n            zfar: {\n                type: \"number\",\n                get: (camera) => camera._babylonCamera?.maxZ,\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.maxZ = value;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"maxZ\"],\n            },\n            znear: {\n                type: \"number\",\n                get: (camera) => camera._babylonCamera?.minZ,\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.minZ = value;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"minZ\"],\n            },\n        },\n    },\n};\nconst materialsTree = {\n    __array__: {\n        __target__: true,\n        emissiveFactor: {\n            type: \"Color3\",\n            get: (material, index, payload) => GetMaterial(material, index, payload).emissiveColor,\n            set: (value, material, index, payload) => GetMaterial(material, index, payload).emissiveColor.copyFrom(value),\n            getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n            getPropertyName: [() => \"emissiveColor\"],\n        },\n        emissiveTexture: {\n            extensions: {\n                KHR_texture_transform: GenerateTextureMap(\"emissiveTexture\"),\n            },\n        },\n        normalTexture: {\n            scale: {\n                type: \"number\",\n                get: (material, index, payload) => GetTexture(material, payload, \"bumpTexture\")?.level,\n                set: (value, material, index, payload) => {\n                    const texture = GetTexture(material, payload, \"bumpTexture\");\n                    if (texture) {\n                        texture.level = value;\n                    }\n                },\n                getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"level\"],\n            },\n            extensions: {\n                KHR_texture_transform: GenerateTextureMap(\"bumpTexture\"),\n            },\n        },\n        occlusionTexture: {\n            strength: {\n                type: \"number\",\n                get: (material, index, payload) => GetMaterial(material, index, payload).ambientTextureStrength,\n                set: (value, material, index, payload) => {\n                    const mat = GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.ambientTextureStrength = value;\n                    }\n                },\n                getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"ambientTextureStrength\"],\n            },\n            extensions: {\n                KHR_texture_transform: GenerateTextureMap(\"ambientTexture\"),\n            },\n        },\n        pbrMetallicRoughness: {\n            baseColorFactor: {\n                type: \"Color4\",\n                get: (material, index, payload) => {\n                    const mat = GetMaterial(material, index, payload);\n                    return Color4.FromColor3(mat.albedoColor, mat.alpha);\n                },\n                set: (value, material, index, payload) => {\n                    const mat = GetMaterial(material, index, payload);\n                    mat.albedoColor.set(value.r, value.g, value.b);\n                    mat.alpha = value.a;\n                },\n                getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                // This is correct on the animation level, but incorrect as a single property of a type Color4\n                getPropertyName: [() => \"albedoColor\", () => \"alpha\"],\n            },\n            baseColorTexture: {\n                extensions: {\n                    KHR_texture_transform: GenerateTextureMap(\"albedoTexture\"),\n                },\n            },\n            metallicFactor: {\n                type: \"number\",\n                get: (material, index, payload) => GetMaterial(material, index, payload).metallic,\n                set: (value, material, index, payload) => {\n                    const mat = GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.metallic = value;\n                    }\n                },\n                getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"metallic\"],\n            },\n            roughnessFactor: {\n                type: \"number\",\n                get: (material, index, payload) => GetMaterial(material, index, payload).roughness,\n                set: (value, material, index, payload) => {\n                    const mat = GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.roughness = value;\n                    }\n                },\n                getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"roughness\"],\n            },\n            metallicRoughnessTexture: {\n                extensions: {\n                    KHR_texture_transform: GenerateTextureMap(\"metallicTexture\"),\n                },\n            },\n        },\n        extensions: {\n            KHR_materials_anisotropy: {\n                anisotropyStrength: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).anisotropy.intensity,\n                    set: (value, material, index, payload) => {\n                        GetMaterial(material, index, payload).anisotropy.intensity = value;\n                    },\n                    getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"anisotropy.intensity\"],\n                },\n                anisotropyRotation: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).anisotropy.angle,\n                    set: (value, material, index, payload) => {\n                        GetMaterial(material, index, payload).anisotropy.angle = value;\n                    },\n                    getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"anisotropy.angle\"],\n                },\n                anisotropyTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"anisotropy\", \"texture\"),\n                    },\n                },\n            },\n            KHR_materials_clearcoat: {\n                clearcoatFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).clearCoat.intensity,\n                    set: (value, material, index, payload) => {\n                        GetMaterial(material, index, payload).clearCoat.intensity = value;\n                    },\n                    getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"clearCoat.intensity\"],\n                },\n                clearcoatRoughnessFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).clearCoat.roughness,\n                    set: (value, material, index, payload) => {\n                        GetMaterial(material, index, payload).clearCoat.roughness = value;\n                    },\n                    getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"clearCoat.roughness\"],\n                },\n                clearcoatTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"clearCoat\", \"texture\"),\n                    },\n                },\n                clearcoatNormalTexture: {\n                    scale: {\n                        type: \"number\",\n                        get: (material, index, payload) => GetMaterial(material, index, payload).clearCoat.bumpTexture?.level,\n                        getTarget: GetMaterial,\n                        set: (value, material, index, payload) => (GetMaterial(material, index, payload).clearCoat.bumpTexture.level = value),\n                    },\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"clearCoat\", \"bumpTexture\"),\n                    },\n                },\n                clearcoatRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"clearCoat\", \"textureRoughness\"),\n                    },\n                },\n            },\n            KHR_materials_dispersion: {\n                dispersion: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.dispersion,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.dispersion = value),\n                },\n            },\n            KHR_materials_emissive_strength: {\n                emissiveStrength: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).emissiveIntensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).emissiveIntensity = value),\n                },\n            },\n            KHR_materials_ior: {\n                ior: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).indexOfRefraction,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).indexOfRefraction = value),\n                },\n            },\n            KHR_materials_iridescence: {\n                iridescenceFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.intensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.intensity = value),\n                },\n                iridescenceIor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.indexOfRefraction,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.indexOfRefraction = value),\n                },\n                iridescenceTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"iridescence\", \"texture\"),\n                    },\n                },\n                iridescenceThicknessMaximum: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.maximumThickness,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.maximumThickness = value),\n                },\n                iridescenceThicknessMinimum: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.minimumThickness,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.minimumThickness = value),\n                },\n                iridescenceThicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"iridescence\", \"thicknessTexture\"),\n                    },\n                },\n            },\n            KHR_materials_sheen: {\n                sheenColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).sheen.color,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => GetMaterial(material, index, payload).sheen.color.copyFrom(value),\n                },\n                sheenColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"sheen\", \"texture\"),\n                    },\n                },\n                sheenRoughnessFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).sheen.intensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).sheen.intensity = value),\n                },\n                sheenRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"sheen\", \"thicknessTexture\"),\n                    },\n                },\n            },\n            KHR_materials_specular: {\n                specularFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).metallicF0Factor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).metallicF0Factor = value),\n                    getPropertyName: [() => \"metallicF0Factor\"],\n                },\n                specularColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).metallicReflectanceColor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => GetMaterial(material, index, payload).metallicReflectanceColor.copyFrom(value),\n                    getPropertyName: [() => \"metallicReflectanceColor\"],\n                },\n                specularTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"metallicReflectanceTexture\"),\n                    },\n                },\n                specularColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"reflectanceTexture\"),\n                    },\n                },\n            },\n            KHR_materials_transmission: {\n                transmissionFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.refractionIntensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.refractionIntensity = value),\n                    getPropertyName: [() => \"subSurface.refractionIntensity\"],\n                },\n                transmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"refractionIntensityTexture\"),\n                    },\n                },\n            },\n            KHR_materials_diffuse_transmission: {\n                diffuseTransmissionFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.translucencyIntensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.translucencyIntensity = value),\n                },\n                diffuseTransmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"translucencyIntensityTexture\"),\n                    },\n                },\n                diffuseTransmissionColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.translucencyColor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => value && GetMaterial(material, index, payload).subSurface.translucencyColor?.copyFrom(value),\n                },\n                diffuseTransmissionColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"translucencyColorTexture\"),\n                    },\n                },\n            },\n            KHR_materials_volume: {\n                attenuationColor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColor.copyFrom(value),\n                },\n                attenuationDistance: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColorAtDistance,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.tintColorAtDistance = value),\n                },\n                thicknessFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.maximumThickness,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.maximumThickness = value),\n                },\n                thicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"thicknessTexture\"),\n                    },\n                },\n            },\n        },\n    },\n};\nconst extensionsTree = {\n    KHR_lights_punctual: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights) => lights.length,\n                getTarget: (lights) => lights.map((light) => light._babylonLight),\n                getPropertyName: [(_lights) => \"length\"],\n            },\n            __array__: {\n                __target__: true,\n                color: {\n                    type: \"Color3\",\n                    get: (light) => light._babylonLight?.diffuse,\n                    set: (value, light) => light._babylonLight?.diffuse.copyFrom(value),\n                    getTarget: (light) => light._babylonLight,\n                    getPropertyName: [(_light) => \"diffuse\"],\n                },\n                intensity: {\n                    type: \"number\",\n                    get: (light) => light._babylonLight?.intensity,\n                    set: (value, light) => (light._babylonLight ? (light._babylonLight.intensity = value) : undefined),\n                    getTarget: (light) => light._babylonLight,\n                    getPropertyName: [(_light) => \"intensity\"],\n                },\n                range: {\n                    type: \"number\",\n                    get: (light) => light._babylonLight?.range,\n                    set: (value, light) => (light._babylonLight ? (light._babylonLight.range = value) : undefined),\n                    getTarget: (light) => light._babylonLight,\n                    getPropertyName: [(_light) => \"range\"],\n                },\n                spot: {\n                    innerConeAngle: {\n                        type: \"number\",\n                        get: (light) => light._babylonLight?.innerAngle,\n                        set: (value, light) => (light._babylonLight ? (light._babylonLight.innerAngle = value) : undefined),\n                        getTarget: (light) => light._babylonLight,\n                        getPropertyName: [(_light) => \"innerConeAngle\"],\n                    },\n                    outerConeAngle: {\n                        type: \"number\",\n                        get: (light) => light._babylonLight?.angle,\n                        set: (value, light) => (light._babylonLight ? (light._babylonLight.angle = value) : undefined),\n                        getTarget: (light) => light._babylonLight,\n                        getPropertyName: [(_light) => \"outerConeAngle\"],\n                    },\n                },\n            },\n        },\n    },\n    EXT_lights_ies: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights) => lights.length,\n                getTarget: (lights) => lights.map((light) => light._babylonLight),\n                getPropertyName: [(_lights) => \"length\"],\n            },\n        },\n    },\n    EXT_lights_image_based: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights) => lights.length,\n                getTarget: (lights) => lights.map((light) => light._babylonTexture),\n                getPropertyName: [(_lights) => \"length\"],\n            },\n            __array__: {\n                __target__: true,\n                intensity: {\n                    type: \"number\",\n                    get: (light) => light._babylonTexture?.level,\n                    set: (value, light) => {\n                        if (light._babylonTexture) {\n                            light._babylonTexture.level = value;\n                        }\n                    },\n                    getTarget: (light) => light._babylonTexture,\n                },\n                rotation: {\n                    type: \"Quaternion\",\n                    get: (light) => light._babylonTexture && Quaternion.FromRotationMatrix(light._babylonTexture?.getReflectionTextureMatrix()),\n                    set: (value, light) => {\n                        if (!light._babylonTexture) {\n                            return;\n                        }\n                        // Invert the rotation so that positive rotation is counter-clockwise.\n                        if (!light._babylonTexture.getScene()?.useRightHandedSystem) {\n                            value = Quaternion.Inverse(value);\n                        }\n                        Matrix.FromQuaternionToRef(value, light._babylonTexture.getReflectionTextureMatrix());\n                    },\n                    getTarget: (light) => light._babylonTexture,\n                },\n            },\n        },\n    },\n};\nfunction GetTexture(material, payload, textureType, textureInObject) {\n    const babylonMaterial = GetMaterial(material, payload);\n    return textureInObject ? babylonMaterial[textureType][textureInObject] : babylonMaterial[textureType];\n}\nfunction GetMaterial(material, _index, payload) {\n    return material._data?.[payload?.fillMode ?? Constants.MATERIAL_TriangleFillMode]?.babylonMaterial;\n}\nfunction GenerateTextureMap(textureType, textureInObject) {\n    return {\n        offset: {\n            componentsCount: 2,\n            // assuming two independent values for u and v, and NOT a Vector2\n            type: \"Vector2\",\n            get: (material, _index, payload) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                return new Vector2(texture?.uOffset, texture?.vOffset);\n            },\n            getTarget: GetMaterial,\n            set: (value, material, _index, payload) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                (texture.uOffset = value.x), (texture.vOffset = value.y);\n            },\n            getPropertyName: [\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.uOffset`,\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.vOffset`,\n            ],\n        },\n        rotation: {\n            type: \"number\",\n            get: (material, _index, payload) => GetTexture(material, payload, textureType, textureInObject)?.wAng,\n            getTarget: GetMaterial,\n            set: (value, material, _index, payload) => (GetTexture(material, payload, textureType, textureInObject).wAng = value),\n            getPropertyName: [() => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.wAng`],\n        },\n        scale: {\n            componentsCount: 2,\n            type: \"Vector2\",\n            get: (material, _index, payload) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                return new Vector2(texture?.uScale, texture?.vScale);\n            },\n            getTarget: GetMaterial,\n            set: (value, material, index, payload) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                (texture.uScale = value.x), (texture.vScale = value.y);\n            },\n            getPropertyName: [\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.uScale`,\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.vScale`,\n            ],\n        },\n    };\n}\nconst objectModelMapping = {\n    cameras: camerasTree,\n    nodes: nodesTree,\n    materials: materialsTree,\n    extensions: extensionsTree,\n    animations: animationsTree,\n    meshes: meshesTree,\n};\n/**\n * get a path-to-object converter for the given glTF tree\n * @param gltf the glTF tree to use\n * @returns a path-to-object converter for the given glTF tree\n */\nexport function GetPathToObjectConverter(gltf) {\n    return new GLTFPathToObjectConverter(gltf, objectModelMapping);\n}\n/**\n * This function will return the object accessor for the given key in the object model\n * If the key is not found, it will return undefined\n * @param key the key to get the mapping for, for example /materials/\\{\\}/emissiveFactor\n * @returns an object accessor for the given key, or undefined if the key is not found\n */\nexport function GetMappingForKey(key) {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        current = current[part];\n    }\n    // validate that current is an object accessor\n    if (current && current.type && current.get) {\n        return current;\n    }\n    return undefined;\n}\n/**\n * Set interpolation for a specific key in the object model\n * @param key the key to set, for example /materials/\\{\\}/emissiveFactor\n * @param interpolation the interpolation elements array\n */\nexport function SetInterpolationForKey(key, interpolation) {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        current = current[part];\n    }\n    // validate that the current object is an object accessor\n    if (current && current.type && current.get) {\n        current.interpolation = interpolation;\n    }\n}\n/**\n * This will ad a new object accessor in the object model at the given key.\n * Note that this will NOT change the typescript types. To do that you will need to change the interface itself (extending it in the module that uses it)\n * @param key the key to add the object accessor at. For example /cameras/\\{\\}/perspective/aspectRatio\n * @param accessor the object accessor to add\n */\nexport function AddObjectAccessorToKey(key, accessor) {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        if (!current[part]) {\n            if (part === \"?\") {\n                current.__ignoreObjectTree__ = true;\n                continue;\n            }\n            current[part] = {};\n            // if the part is __array__ then add the __target__ property\n            if (part === \"__array__\") {\n                current[part].__target__ = true;\n            }\n        }\n        current = current[part];\n    }\n    Object.assign(current, accessor);\n}\n//# sourceMappingURL=objectModelMapping.js.map"],"names":["Node","AddNodeConstructor","name","scene","SpotLight","Vector3","Zero","ShadowLight","iesProfileTexture","this","_iesProfileTexture","value","_IsTexture","onLoadObservable","addOnce","_markMeshesAsLightDirty","angle","_angle","_cosHalfAngle","Math","cos","_projectionTextureProjectionLightDirty","forceProjectionMatrixCompute","_computeAngleValues","innerAngle","_innerAngle","shadowAngleScale","_shadowAngleScale","projectionTextureMatrix","_projectionTextureMatrix","projectionTextureLightNear","_projectionTextureLightNear","projectionTextureLightFar","_projectionTextureLightFar","projectionTextureUpDirection","_projectionTextureUpDirection","projectionTexture","_projectionTexture","_projectionTextureDirty","isReady","_IsProceduralTexture","getEffect","executeWhenCompiled","texture","undefined","onGeneratedObservable","projectionTextureProjectionLightMatrix","_projectionTextureProjectionLightMatrix","projection","constructor","position","direction","exponent","super","Matrix","Up","_projectionTextureViewLightDirty","_projectionTextureViewTargetVector","_projectionTextureViewLightMatrix","_projectionTextureScalingMatrix","FromValues","getClassName","getTypeID","Light","LIGHTTYPEID_SPOTLIGHT","_setDirection","_setPosition","_setDefaultShadowProjectionMatrix","matrix","viewMatrix","renderList","activeCamera","getScene","minZ","shadowMinZ","maxZ","shadowMaxZ","useReverseDepthBuffer","getEngine","PerspectiveFovLHToRef","_scene","isNDCHalfZRange","_computeProjectionTextureViewLightMatrix","getAbsolutePosition","addToRef","getShadowDirection","LookAtLHToRef","_computeProjectionTextureProjectionLightMatrix","lightFar","lightNear","p","q","s","tan","FromValuesToRef","_computeProjectionTextureMatrix","multiplyToRef","Texture","u","uScale","v","vScale","_buildUniformLayout","_uniformBuffer","addUniform","create","_lightAngleScale","max","_lightAngleOffset","transferTexturesToEffect","effect","lightIndex","setMatrix","setTexture","transferToEffect","normalizeDirection","computeTransformedInformation","updateFloat4","transformedPosition","x","floatingOriginOffset","y","z","Normalize","transformedDirection","range","_inverseSquaredRange","transferToNodeMaterialEffect","lightDataUniformName","useRightHandedSystem","setFloat3","dispose","getDepthMinZ","engine","Constants","ShadowMinZ","getDepthMaxZ","ShadowMaxZ","prepareLightSpecificDefines","defines","__decorate","serialize","prototype","serializeAsTexture","RegisterClass","OptionalPathExceptionsList","regex","RegExp","GLTFPathToObjectConverter","_gltf","_infoTree","convert","path","target","objectTree","infoTree","startsWith","Error","parts","split","shift","length","includes","pop","push","ignoreObjectTree","part","isLength","__array__","__ignoreObjectTree__","find","e","test","__target__","object","info","GetTexture","material","payload","textureType","textureInObject","babylonMaterial","GetMaterial","_index","_data","fillMode","MATERIAL_TriangleFillMode","GenerateTextureMap","offset","componentsCount","type","get","Vector2","uOffset","vOffset","getTarget","set","getPropertyName","rotation","wAng","scale","index","objectModelMapping","cameras","orthographic","xmag","camera","_babylonCamera","orthoLeft","orthoRight","ymag","orthoBottom","orthoTop","zfar","znear","perspective","aspectRatio","getAspectRatio","isReadOnly","yfov","fov","nodes","map","node","_babylonTransformNode","translation","copyFrom","rotationQuaternion","scaling","weights","_numMorphTargets","_primitiveBabylonMeshes","morphTargetManager","influence","Compose","globalMatrix","Identity","rootNode","parent","forceUpdate","_isDirty","rootMatrix","computeWorldMatrix","invert","extensions","EXT_lights_ies","multiplier","getChildren","child","intensity","light","color","diffuse","materials","emissiveFactor","emissiveColor","emissiveTexture","KHR_texture_transform","normalTexture","level","occlusionTexture","strength","ambientTextureStrength","mat","pbrMetallicRoughness","baseColorFactor","Color4","FromColor3","albedoColor","alpha","r","g","b","a","baseColorTexture","metallicFactor","metallic","roughnessFactor","roughness","metallicRoughnessTexture","KHR_materials_anisotropy","anisotropyStrength","anisotropy","anisotropyRotation","anisotropyTexture","KHR_materials_clearcoat","clearcoatFactor","clearCoat","clearcoatRoughnessFactor","clearcoatTexture","clearcoatNormalTexture","bumpTexture","clearcoatRoughnessTexture","KHR_materials_dispersion","dispersion","subSurface","KHR_materials_emissive_strength","emissiveStrength","emissiveIntensity","KHR_materials_ior","ior","indexOfRefraction","KHR_materials_iridescence","iridescenceFactor","iridescence","iridescenceIor","iridescenceTexture","iridescenceThicknessMaximum","maximumThickness","iridescenceThicknessMinimum","minimumThickness","iridescenceThicknessTexture","KHR_materials_sheen","sheenColorFactor","sheen","sheenColorTexture","sheenRoughnessFactor","sheenRoughnessTexture","KHR_materials_specular","specularFactor","metallicF0Factor","specularColorFactor","metallicReflectanceColor","specularTexture","specularColorTexture","KHR_materials_transmission","transmissionFactor","refractionIntensity","transmissionTexture","KHR_materials_diffuse_transmission","diffuseTransmissionFactor","translucencyIntensity","diffuseTransmissionTexture","diffuseTransmissionColorFactor","translucencyColor","diffuseTransmissionColorTexture","KHR_materials_volume","attenuationColor","tintColor","attenuationDistance","tintColorAtDistance","thicknessFactor","thicknessTexture","KHR_lights_punctual","lights","_babylonLight","_lights","_light","spot","innerConeAngle","outerConeAngle","EXT_lights_image_based","_babylonTexture","Quaternion","FromRotationMatrix","getReflectionTextureMatrix","Inverse","FromQuaternionToRef","animations","animation","_babylonAnimationGroup","meshes","mesh","primitives","_instanceData","babylonSourceMesh","GetPathToObjectConverter","gltf","GetMappingForKey","key","keyParts","replace","current","SetInterpolationForKey","interpolation","AddObjectAccessorToKey","accessor","Object","assign"],"mappings":"0IASAA,EAAKC,mBAAmB,gBAAgB,CAACC,EAAMC,IACpC,IAAM,IAAIC,EAAUF,EAAMG,EAAQC,OAAQD,EAAQC,OAAQ,EAAG,EAAGH,KASpE,MAAMC,UAAkBG,EAK3B,qBAAIC,GACA,OAAOC,KAAKC,kBACpB,CACI,qBAAIF,CAAkBG,GACdF,KAAKC,qBAAuBC,IAGhCF,KAAKC,mBAAqBC,EACtBF,KAAKC,oBAAsBN,EAAUQ,WAAWH,KAAKC,qBACrDD,KAAKC,mBAAmBG,iBAAiBC,SAAQ,KAC7CL,KAAKM,6BAGrB,CAII,SAAIC,GACA,OAAOP,KAAKQ,MACpB,CAII,SAAID,CAAML,GACNF,KAAKQ,OAASN,EACdF,KAAKS,cAAgBC,KAAKC,IAAY,GAART,GAC9BF,KAAKY,wCAAyC,EAC9CZ,KAAKa,+BACLb,KAAKc,qBACb,CAMI,cAAIC,GACA,OAAOf,KAAKgB,WACpB,CAMI,cAAID,CAAWb,GACXF,KAAKgB,YAAcd,EACnBF,KAAKc,qBACb,CAII,oBAAIG,GACA,OAAOjB,KAAKkB,iBACpB,CAII,oBAAID,CAAiBf,GACjBF,KAAKkB,kBAAoBhB,EACzBF,KAAKa,8BACb,CAII,2BAAIM,GACA,OAAOnB,KAAKoB,wBACpB,CAII,8BAAIC,GACA,OAAOrB,KAAKsB,2BACpB,CAII,8BAAID,CAA2BnB,GAC3BF,KAAKsB,4BAA8BpB,EACnCF,KAAKY,wCAAyC,CACtD,CAII,6BAAIW,GACA,OAAOvB,KAAKwB,0BACpB,CAII,6BAAID,CAA0BrB,GAC1BF,KAAKwB,2BAA6BtB,EAClCF,KAAKY,wCAAyC,CACtD,CAII,gCAAIa,GACA,OAAOzB,KAAK0B,6BACpB,CAII,gCAAID,CAA6BvB,GAC7BF,KAAK0B,8BAAgCxB,EACrCF,KAAKY,wCAAyC,CACtD,CAII,qBAAIe,GACA,OAAO3B,KAAK4B,kBACpB,CAII,qBAAID,CAAkBzB,GACdF,KAAK4B,qBAAuB1B,IAGhCF,KAAK4B,mBAAqB1B,EAC1BF,KAAK6B,yBAA0B,EAC3B7B,KAAK4B,qBAAuB5B,KAAK4B,mBAAmBE,YAChDnC,EAAUoC,qBAAqB/B,KAAK4B,oBACpC5B,KAAK4B,mBAAmBI,YAAYC,qBAAoB,KACpDjC,KAAKM,6BAGJX,EAAUQ,WAAWH,KAAK4B,qBAC/B5B,KAAK4B,mBAAmBxB,iBAAiBC,SAAQ,KAC7CL,KAAKM,8BAIzB,CACI,2BAAOyB,CAAqBG,GACxB,YAAyCC,IAAlCD,EAAQE,qBACvB,CACI,iBAAOjC,CAAW+B,GACd,YAAoCC,IAA7BD,EAAQ9B,gBACvB,CAII,0CAAIiC,GACA,OAAOrC,KAAKsC,uCACpB,CACI,0CAAID,CAAuCE,GACvCvC,KAAKsC,wCAA0CC,EAC/CvC,KAAKY,wCAAyC,EAC9CZ,KAAK6B,yBAA0B,CACvC,CAYI,WAAAW,CAAY/C,EAAMgD,EAAUC,EAAWnC,EAAOoC,EAAUjD,GACpDkD,MAAMnD,EAAMC,GACZM,KAAKgB,YAAc,EACnBhB,KAAKC,mBAAqB,KAC1BD,KAAKoB,yBAA2ByB,EAAOhD,OACvCG,KAAKsB,4BAA8B,KACnCtB,KAAKwB,2BAA6B,IAClCxB,KAAK0B,8BAAgC9B,EAAQkD,KAC7C9C,KAAK+C,kCAAmC,EACxC/C,KAAKY,wCAAyC,EAC9CZ,KAAK6B,yBAA0B,EAC/B7B,KAAKgD,mCAAqCpD,EAAQC,OAClDG,KAAKiD,kCAAoCJ,EAAOhD,OAChDG,KAAKsC,wCAA0CO,EAAOhD,OACtDG,KAAKkD,gCAAkCL,EAAOM,WAAW,GAAK,EAAK,EAAK,EAAK,EAAK,GAAK,EAAK,EAAK,EAAK,EAAK,GAAK,EAAK,GAAK,GAAK,GAAK,GACpInD,KAAKyC,SAAWA,EAChBzC,KAAK0C,UAAYA,EACjB1C,KAAKO,MAAQA,EACbP,KAAK2C,SAAWA,CACxB,CAKI,YAAAS,GACI,MAAO,WACf,CAMI,SAAAC,GACI,OAAOC,EAAMC,qBACrB,CAKI,aAAAC,CAActD,GACV0C,MAAMY,cAActD,GACpBF,KAAK+C,kCAAmC,CAChD,CAKI,YAAAU,CAAavD,GACT0C,MAAMa,aAAavD,GACnBF,KAAK+C,kCAAmC,CAChD,CASI,iCAAAW,CAAkCC,EAAQC,EAAYC,GAClD,MAAMC,EAAe9D,KAAK+D,WAAWD,aACrC,IAAKA,EACD,OAEJ9D,KAAKkB,kBAAoBlB,KAAKkB,mBAAqB,EACnD,MAAMX,EAAQP,KAAKkB,kBAAoBlB,KAAKQ,OACtCwD,OAA2B7B,IAApBnC,KAAKiE,WAA2BjE,KAAKiE,WAAaH,EAAaE,KACtEE,OAA2B/B,IAApBnC,KAAKmE,WAA2BnE,KAAKmE,WAAaL,EAAaI,KACtEE,EAAwBpE,KAAK+D,WAAWM,YAAYD,sBAC1DvB,EAAOyB,sBAAsB/D,EAAO,EAAK6D,EAAwBF,EAAOF,EAAMI,EAAwBJ,EAAOE,EAAMP,GAAQ,EAAM3D,KAAKuE,OAAOF,YAAYG,qBAAiBrC,EAAWiC,EAC7L,CACI,wCAAAK,GACIzE,KAAK+C,kCAAmC,EACxC/C,KAAK6B,yBAA0B,EAC/B7B,KAAK0E,sBAAsBC,SAAS3E,KAAK4E,qBAAsB5E,KAAKgD,oCACpEH,EAAOgC,cAAc7E,KAAK0E,sBAAuB1E,KAAKgD,mCAAoChD,KAAK0B,8BAA+B1B,KAAKiD,kCAC3I,CACI,8CAAA6B,GACI9E,KAAKY,wCAAyC,EAC9CZ,KAAK6B,yBAA0B,EAC/B,MAAMkD,EAAW/E,KAAKuB,0BAChByD,EAAYhF,KAAKqB,2BACjB4D,EAAIF,GAAYA,EAAWC,GAC3BE,GAAKD,EAAID,EACTG,EAAI,EAAMzE,KAAK0E,IAAIpF,KAAKQ,OAAS,GAEvCqC,EAAOwC,gBAAgBF,EADb,EACoB,EAAK,EAAK,EAAK,EAAKA,EAAG,EAAK,EAAK,EAAK,EAAKF,EAAG,EAAK,EAAK,EAAKC,EAAG,EAAKlF,KAAKsC,wCAChH,CAII,+BAAAgD,GAGI,GAFAtF,KAAK6B,yBAA0B,EAC/B7B,KAAKiD,kCAAkCsC,cAAcvF,KAAKsC,wCAAyCtC,KAAKoB,0BACpGpB,KAAK4B,8BAA8B4D,EAAS,CAC5C,MAAMC,EAAIzF,KAAK4B,mBAAmB8D,OAAS,EACrCC,EAAI3F,KAAK4B,mBAAmBgE,OAAS,EAC3C/C,EAAOwC,gBAAgBI,EAAG,EAAK,EAAK,EAAK,EAAKE,EAAG,EAAK,EAAK,EAAK,EAAK,GAAK,EAAK,GAAK,GAAK,GAAK,EAAK3F,KAAKkD,gCACpH,CACQlD,KAAKoB,yBAAyBmE,cAAcvF,KAAKkD,gCAAiClD,KAAKoB,yBAC/F,CACI,mBAAAyE,GACI7F,KAAK8F,eAAeC,WAAW,aAAc,GAC7C/F,KAAK8F,eAAeC,WAAW,gBAAiB,GAChD/F,KAAK8F,eAAeC,WAAW,iBAAkB,GACjD/F,KAAK8F,eAAeC,WAAW,kBAAmB,GAClD/F,KAAK8F,eAAeC,WAAW,gBAAiB,GAChD/F,KAAK8F,eAAeC,WAAW,cAAe,GAC9C/F,KAAK8F,eAAeC,WAAW,cAAe,GAC9C/F,KAAK8F,eAAeE,QAC5B,CACI,mBAAAlF,GACId,KAAKiG,iBAAmB,EAAMvF,KAAKwF,IAAI,KAAOxF,KAAKC,IAAuB,GAAnBX,KAAKgB,aAAqBhB,KAAKS,eACtFT,KAAKmG,mBAAqBnG,KAAKS,cAAgBT,KAAKiG,gBAC5D,CAOI,wBAAAG,CAAyBC,EAAQC,GAiB7B,OAhBItG,KAAK2B,mBAAqB3B,KAAK2B,kBAAkBG,YAC7C9B,KAAK+C,kCACL/C,KAAKyE,2CAELzE,KAAKY,wCACLZ,KAAK8E,iDAEL9E,KAAK6B,yBACL7B,KAAKsF,kCAETe,EAAOE,UAAU,0BAA4BD,EAAYtG,KAAKoB,0BAC9DiF,EAAOG,WAAW,yBAA2BF,EAAYtG,KAAK2B,oBAE9D3B,KAAKC,oBAAsBD,KAAKC,mBAAmB6B,WACnDuE,EAAOG,WAAW,kBAAoBF,EAAYtG,KAAKC,oBAEpDD,IACf,CAOI,gBAAAyG,CAAiBJ,EAAQC,GACrB,IAAII,EAWJ,OAVI1G,KAAK2G,iCACL3G,KAAK8F,eAAec,aAAa,aAAc5G,KAAK6G,oBAAoBC,EAAI9G,KAAKuE,OAAOwC,qBAAqBD,EAAG9G,KAAK6G,oBAAoBG,EAAIhH,KAAKuE,OAAOwC,qBAAqBC,EAAGhH,KAAK6G,oBAAoBI,EAAIjH,KAAKuE,OAAOwC,qBAAqBE,EAAGjH,KAAK2C,SAAU2D,GACjQI,EAAqB9G,EAAQsH,UAAUlH,KAAKmH,wBAG5CnH,KAAK8F,eAAec,aAAa,aAAc5G,KAAKyC,SAASqE,EAAI9G,KAAKuE,OAAOwC,qBAAqBD,EAAG9G,KAAKyC,SAASuE,EAAIhH,KAAKuE,OAAOwC,qBAAqBC,EAAGhH,KAAKyC,SAASwE,EAAIjH,KAAKuE,OAAOwC,qBAAqBE,EAAGjH,KAAK2C,SAAU2D,GAChOI,EAAqB9G,EAAQsH,UAAUlH,KAAK0C,YAEhD1C,KAAK8F,eAAec,aAAa,kBAAmBF,EAAmBI,EAAGJ,EAAmBM,EAAGN,EAAmBO,EAAGjH,KAAKS,cAAe6F,GAC1ItG,KAAK8F,eAAec,aAAa,gBAAiB5G,KAAKoH,MAAOpH,KAAKqH,qBAAsBrH,KAAKiG,iBAAkBjG,KAAKmG,kBAAmBG,GACjItG,IACf,CACI,4BAAAsH,CAA6BjB,EAAQkB,GACjC,IAAIb,EAaJ,OAXIA,EADA1G,KAAK2G,gCACgB/G,EAAQsH,UAAUlH,KAAKmH,sBAGvBvH,EAAQsH,UAAUlH,KAAK0C,WAE5C1C,KAAK+D,WAAWyD,qBAChBnB,EAAOoB,UAAUF,GAAuBb,EAAmBI,GAAIJ,EAAmBM,GAAIN,EAAmBO,GAGzGZ,EAAOoB,UAAUF,EAAsBb,EAAmBI,EAAGJ,EAAmBM,EAAGN,EAAmBO,GAEnGjH,IACf,CAII,OAAA0H,GACI9E,MAAM8E,UACF1H,KAAK4B,oBACL5B,KAAK4B,mBAAmB8F,UAExB1H,KAAKC,qBACLD,KAAKC,mBAAmByH,UACxB1H,KAAKC,mBAAqB,KAEtC,CAMI,YAAA0H,CAAa7D,GACT,MAAM8D,EAAS5H,KAAKuE,OAAOF,YACrBL,OAA2B7B,IAApBnC,KAAKiE,WAA2BjE,KAAKiE,WAAcH,GAAcE,MAAQ6D,EAAUC,WAChG,OAAOF,EAAOxD,uBAAyBwD,EAAOpD,gBAAkBR,EAAOhE,KAAKuE,OAAOF,YAAYG,gBAAkB,EAAIR,CAC7H,CAMI,YAAA+D,CAAajE,GACT,MAAM8D,EAAS5H,KAAKuE,OAAOF,YACrBH,OAA2B/B,IAApBnC,KAAKmE,WAA2BnE,KAAKmE,WAAcL,GAAcI,MAAQ2D,EAAUG,WAChG,OAAOJ,EAAOxD,uBAAyBwD,EAAOpD,gBAAkB,EAAIN,CAC5E,CAMI,2BAAA+D,CAA4BC,EAAS5B,GACjC4B,EAAQ,YAAc5B,IAAc,EACpC4B,EAAQ,wBAA0B5B,MAActG,KAAK2B,oBAAqB3B,KAAK2B,kBAAkBG,WACjGoG,EAAQ,kBAAoB5B,MAActG,KAAKC,qBAAsBD,KAAKC,mBAAmB6B,UACrG,EAEAqG,EAAW,CACPC,KACDzI,EAAU0I,UAAW,QAAS,MACjCF,EAAW,CACPC,KACDzI,EAAU0I,UAAW,aAAc,MACtCF,EAAW,CACPC,KACDzI,EAAU0I,UAAW,mBAAoB,MAC5CF,EAAW,CACPC,KACDzI,EAAU0I,UAAW,gBAAY,GACpCF,EAAW,CACPC,KACDzI,EAAU0I,UAAW,6BAA8B,MACtDF,EAAW,CACPC,KACDzI,EAAU0I,UAAW,4BAA6B,MACrDF,EAAW,CACPC,KACDzI,EAAU0I,UAAW,+BAAgC,MACxDF,EAAW,CACPG,EAAmB,0BACpB3I,EAAU0I,UAAW,0BAAsB,GAE9CE,EAAc,oBAAqB5I,GCza5B,MAAM6I,EAA6B,CACtC,CAEIC,MAAO,IAAIC,OAAO,8BASnB,MAAMC,EACT,WAAAnG,CAAYoG,EAAOC,GACf7I,KAAK4I,MAAQA,EACb5I,KAAK6I,UAAYA,CACzB,CAuBI,OAAAC,CAAQC,GACJ,IAEIC,EAFAC,EAAajJ,KAAK4I,MAClBM,EAAWlJ,KAAK6I,UAEpB,IAAKE,EAAKI,WAAW,KACjB,MAAM,IAAIC,MAAM,4BAEpB,MAAMC,EAAQN,EAAKO,MAAM,KAGzB,GAFAD,EAAME,QAEFF,EAAMA,EAAMG,OAAS,GAAGC,SAAS,WAAY,CAC7C,MACMH,EADWD,EAAMA,EAAMG,OAAS,GACfF,MAAM,KAC7BD,EAAMK,MACNL,EAAMM,QAAQL,EAC1B,CACQ,IAAIM,GAAmB,EACvB,IAAK,MAAMC,KAAQR,EAAO,CACtB,MAAMS,EAAoB,WAATD,EACjB,GAAIC,IAAaZ,EAASa,UACtB,MAAM,IAAIX,MAAM,QAAQL,gBAK5B,GAHIG,EAASc,uBACTJ,GAAmB,GAEnBV,EAASa,YAAcD,EACvBZ,EAAWA,EAASa,eAIpB,GADAb,EAAWA,EAASW,IACfX,EACD,MAAM,IAAIE,MAAM,QAAQL,gBAGhC,IAAKa,EACD,QAAmBzH,IAAf8G,EAA0B,CAG1B,IADkBT,EAA2ByB,MAAMC,GAAMA,EAAEzB,MAAM0B,KAAKpB,KAElE,MAAM,IAAIK,MAAM,QAAQL,eAEhD,MAC0Be,IACNb,EAAaA,IAAaY,KAG9BX,EAASkB,YAAcN,KACvBd,EAASC,EAEzB,CACQ,MAAO,CACHoB,OAAQrB,EACRsB,KAAMpB,EAElB,EC0kBA,SAASqB,EAAWC,EAAUC,EAASC,EAAaC,GAChD,MAAMC,EAAkBC,EAAYL,GACpC,OAAOG,EAAkBC,EAAgBF,GAAaC,GAAmBC,EAAgBF,EAC7F,CACA,SAASG,EAAYL,EAAUM,EAAQL,GACnC,OAAOD,EAASO,QAAQN,GAASO,UAAYnD,EAAUoD,4BAA4BL,eACvF,CACA,SAASM,EAAmBR,EAAaC,GACrC,MAAO,CACHQ,OAAQ,CACJC,gBAAiB,EAEjBC,KAAM,UACNC,IAAK,CAACd,EAAUM,EAAQL,KACpB,MAAMvI,EAAUqI,EAAWC,EAAUC,EAASC,EAAaC,GAC3D,OAAO,IAAIY,EAAQrJ,GAASsJ,QAAStJ,GAASuJ,UAElDC,UAAWb,EACXc,IAAK,CAACzL,EAAOsK,EAAUM,EAAQL,KAC3B,MAAMvI,EAAUqI,EAAWC,EAAUC,EAASC,EAAaC,GAC1DzI,EAAQsJ,QAAUtL,EAAM4G,EAAK5E,EAAQuJ,QAAUvL,EAAM8G,GAE1D4E,gBAAiB,CACb,IAAM,GAAGlB,IAAcC,EAAkB,IAAMA,EAAkB,aACjE,IAAM,GAAGD,IAAcC,EAAkB,IAAMA,EAAkB,eAGzEkB,SAAU,CACNR,KAAM,SACNC,IAAK,CAACd,EAAUM,EAAQL,IAAYF,EAAWC,EAAUC,EAASC,EAAaC,IAAkBmB,KACjGJ,UAAWb,EACXc,IAAK,CAACzL,EAAOsK,EAAUM,EAAQL,IAAaF,EAAWC,EAAUC,EAASC,EAAaC,GAAiBmB,KAAO5L,EAC/G0L,gBAAiB,CAAC,IAAM,GAAGlB,IAAcC,EAAkB,IAAMA,EAAkB,YAEvFoB,MAAO,CACHX,gBAAiB,EACjBC,KAAM,UACNC,IAAK,CAACd,EAAUM,EAAQL,KACpB,MAAMvI,EAAUqI,EAAWC,EAAUC,EAASC,EAAaC,GAC3D,OAAO,IAAIY,EAAQrJ,GAASwD,OAAQxD,GAAS0D,SAEjD8F,UAAWb,EACXc,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,KAC1B,MAAMvI,EAAUqI,EAAWC,EAAUC,EAASC,EAAaC,GAC1DzI,EAAQwD,OAASxF,EAAM4G,EAAK5E,EAAQ0D,OAAS1F,EAAM8G,GAExD4E,gBAAiB,CACb,IAAM,GAAGlB,IAAcC,EAAkB,IAAMA,EAAkB,YACjE,IAAM,GAAGD,IAAcC,EAAkB,IAAMA,EAAkB,cAIjF,CACA,MAAMsB,EAAqB,CACvBC,QAllBgB,CAChBnC,UAAW,CACPK,YAAY,EACZ+B,aAAc,CACVC,KAAM,CACFhB,gBAAiB,EACjBC,KAAM,UACNC,IAAMe,GAAW,IAAId,EAAQc,EAAOC,gBAAgBC,WAAa,EAAGF,EAAOC,gBAAgBE,YAAc,GACzGb,IAAK,CAACzL,EAAOmM,KACLA,EAAOC,iBACPD,EAAOC,eAAeC,UAAYrM,EAAM4G,EACxCuF,EAAOC,eAAeE,WAAatM,EAAM8G,IAGjD0E,UAAYW,GAAWA,EACvBT,gBAAiB,CAAC,IAAM,YAAa,IAAM,eAE/Ca,KAAM,CACFrB,gBAAiB,EACjBC,KAAM,UACNC,IAAMe,GAAW,IAAId,EAAQc,EAAOC,gBAAgBI,aAAe,EAAGL,EAAOC,gBAAgBK,UAAY,GACzGhB,IAAK,CAACzL,EAAOmM,KACLA,EAAOC,iBACPD,EAAOC,eAAeI,YAAcxM,EAAM4G,EAC1CuF,EAAOC,eAAeK,SAAWzM,EAAM8G,IAG/C0E,UAAYW,GAAWA,EACvBT,gBAAiB,CAAC,IAAM,cAAe,IAAM,aAEjDgB,KAAM,CACFvB,KAAM,SACNC,IAAMe,GAAWA,EAAOC,gBAAgBpI,KACxCyH,IAAK,CAACzL,EAAOmM,KACLA,EAAOC,iBACPD,EAAOC,eAAepI,KAAOhE,IAGrCwL,UAAYW,GAAWA,EACvBT,gBAAiB,CAAC,IAAM,SAE5BiB,MAAO,CACHxB,KAAM,SACNC,IAAMe,GAAWA,EAAOC,gBAAgBtI,KACxC2H,IAAK,CAACzL,EAAOmM,KACLA,EAAOC,iBACPD,EAAOC,eAAetI,KAAO9D,IAGrCwL,UAAYW,GAAWA,EACvBT,gBAAiB,CAAC,IAAM,UAGhCkB,YAAa,CACTC,YAAa,CACT1B,KAAM,SACNC,IAAMe,GAAWA,EAAOC,gBAAgBjI,YAAY2I,eAAeX,EAAOC,gBAC1EZ,UAAYW,GAAWA,EACvBT,gBAAiB,CAAC,IAAM,eACxBqB,YAAY,GAEhBC,KAAM,CACF7B,KAAM,SACNC,IAAMe,GAAWA,EAAOC,gBAAgBa,IACxCxB,IAAK,CAACzL,EAAOmM,KACLA,EAAOC,iBACPD,EAAOC,eAAea,IAAMjN,IAGpCwL,UAAYW,GAAWA,EACvBT,gBAAiB,CAAC,IAAM,QAE5BgB,KAAM,CACFvB,KAAM,SACNC,IAAMe,GAAWA,EAAOC,gBAAgBpI,KACxCyH,IAAK,CAACzL,EAAOmM,KACLA,EAAOC,iBACPD,EAAOC,eAAepI,KAAOhE,IAGrCwL,UAAYW,GAAWA,EACvBT,gBAAiB,CAAC,IAAM,SAE5BiB,MAAO,CACHxB,KAAM,SACNC,IAAMe,GAAWA,EAAOC,gBAAgBtI,KACxC2H,IAAK,CAACzL,EAAOmM,KACLA,EAAOC,iBACPD,EAAOC,eAAetI,KAAO9D,IAGrCwL,UAAYW,GAAWA,EACvBT,gBAAiB,CAAC,IAAM,YAufpCwB,MA7tBc,CACd5D,OAAQ,CACJ6B,KAAM,SACNC,IAAM8B,GAAUA,EAAM5D,OACtBkC,UAAY0B,GAAUA,EAAMC,KAAKC,GAASA,EAAKC,wBAC/C3B,gBAAiB,CAAC,IAAM,WAE5B7B,UAAW,CACPK,YAAY,EACZoD,YAAa,CACTnC,KAAM,UACNC,IAAMgC,GAASA,EAAKC,uBAAuB9K,SAC3CkJ,IAAK,CAACzL,EAAOoN,IAASA,EAAKC,uBAAuB9K,SAASgL,SAASvN,GACpEwL,UAAY4B,GAASA,EAAKC,sBAC1B3B,gBAAiB,CAAC,IAAM,aAE5BC,SAAU,CACNR,KAAM,aACNC,IAAMgC,GAASA,EAAKC,uBAAuBG,mBAC3C/B,IAAK,CAACzL,EAAOoN,IAASA,EAAKC,uBAAuBG,oBAAoBD,SAASvN,GAC/EwL,UAAY4B,GAASA,EAAKC,sBAC1B3B,gBAAiB,CAAC,IAAM,uBAE5BG,MAAO,CACHV,KAAM,UACNC,IAAMgC,GAASA,EAAKC,uBAAuBI,QAC3ChC,IAAK,CAACzL,EAAOoN,IAASA,EAAKC,uBAAuBI,QAAQF,SAASvN,GACnEwL,UAAY4B,GAASA,EAAKC,sBAC1B3B,gBAAiB,CAAC,IAAM,YAE5BgC,QAAS,CACLpE,OAAQ,CACJ6B,KAAM,SACNC,IAAMgC,GAASA,EAAKO,iBACpBnC,UAAY4B,GAASA,EAAKC,sBAC1B3B,gBAAiB,CAAC,IAAM,cAE5B7B,UAAW,CACPK,YAAY,EACZiB,KAAM,SACNC,IAAK,CAACgC,EAAMtB,SAAqB7J,IAAV6J,EAAsBsB,EAAKQ,0BAA0B,GAAGC,oBAAoBrC,UAAUM,GAAOgC,eAAY7L,EAEhIuJ,UAAY4B,GAASA,EAAKC,sBAC1B3B,gBAAiB,CAAC,IAAM,cAE5BP,KAAM,WACNC,IAAK,CAACgC,EAAMtB,IAAU,CAAC,GAEvBN,UAAY4B,GAASA,EAAKC,sBAC1B3B,gBAAiB,CAAC,IAAM,cAG5BjI,OAAQ,CACJ0H,KAAM,SACNC,IAAMgC,GAASzK,EAAOoL,QAAQX,EAAKC,uBAAuBI,QAASL,EAAKC,uBAAuBG,mBAAoBJ,EAAKC,uBAAuB9K,UAC/IiJ,UAAY4B,GAASA,EAAKC,sBAC1BN,YAAY,GAEhBiB,aAAc,CACV7C,KAAM,SACNC,IAAMgC,IACF,MAAM3J,EAASd,EAAOsL,WAEtB,IAAIC,EAAWd,EAAKe,OACpB,KAAOD,GAAYA,EAASC,QACxBD,EAAWA,EAASC,OAExB,MAAMC,EAAchB,EAAKC,uBAAuB9K,SAAS8L,UAAYjB,EAAKC,uBAAuBG,oBAAoBa,UAAYjB,EAAKC,uBAAuBI,QAAQY,SACrK,GAAIH,EAAU,CAGV,MAAMI,EAAaJ,EAASb,uBAAuBkB,oBAAmB,GAAMC,SACxEF,GACAlB,EAAKC,uBAAuBkB,mBAAmBH,IAAc/I,cAAciJ,EAAY7K,EAE/G,MACyB2J,EAAKC,uBACV5J,EAAO8J,SAASH,EAAKC,sBAAsBkB,mBAAmBH,IAElE,OAAO3K,GAEX+H,UAAY4B,GAASA,EAAKC,sBAC1BN,YAAY,GAEhB0B,WAAY,CACRC,eAAgB,CACZC,WAAY,CACRxD,KAAM,SACNC,IAAMgC,GACKA,EAAKC,uBAAuBuB,aAAaC,GAAUA,aAAiBpP,IAAW,GAAM,IAAIqP,UAEpGtD,UAAY4B,GAASA,EAAKC,uBAAuBuB,aAAaC,GAAUA,aAAiBpP,IAAW,GAAM,GAC1GgM,IAAK,CAACzL,EAAOoN,KACT,GAAIA,EAAKC,sBAAuB,CAC5B,MAAM0B,EAAQ3B,EAAKC,sBAAsBuB,aAAaC,GAAUA,aAAiBpP,IAAW,GAAM,GAC9FsP,IACAA,EAAMD,UAAY9O,EAElD,IAGgBgP,MAAO,CACH7D,KAAM,SACNC,IAAMgC,GACKA,EAAKC,uBAAuBuB,aAAaC,GAAUA,aAAiBpP,IAAW,GAAM,IAAIwP,QAEpGzD,UAAY4B,GAASA,EAAKC,uBAAuBuB,aAAaC,GAAUA,aAAiBpP,IAAW,GAAM,GAC1GgM,IAAK,CAACzL,EAAOoN,KACT,GAAIA,EAAKC,sBAAuB,CAC5B,MAAM0B,EAAQ3B,EAAKC,sBAAsBuB,aAAaC,GAAUA,aAAiBpP,IAAW,GAAM,GAC9FsP,IACAA,EAAME,QAAUjP,EAEhD,QA6mBIkP,UAnfkB,CAClBrF,UAAW,CACPK,YAAY,EACZiF,eAAgB,CACZhE,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAAS6E,cACzE3D,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAAS6E,cAAc7B,SAASvN,GACvGwL,UAAW,CAAClB,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GACtEmB,gBAAiB,CAAC,IAAM,kBAE5B2D,gBAAiB,CACbZ,WAAY,CACRa,sBAAuBtE,EAAmB,qBAGlDuE,cAAe,CACX1D,MAAO,CACHV,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYF,EAAWC,EAAUC,EAAS,gBAAgBiF,MACjF/D,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,KAC1B,MAAMvI,EAAUqI,EAAWC,EAAUC,EAAS,eAC1CvI,IACAA,EAAQwN,MAAQxP,IAGxBwL,UAAW,CAAClB,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GACtEmB,gBAAiB,CAAC,IAAM,UAE5B+C,WAAY,CACRa,sBAAuBtE,EAAmB,iBAGlDyE,iBAAkB,CACdC,SAAU,CACNvE,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAASoF,uBACzElE,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,KAC1B,MAAMqF,EAAMjF,EAAYL,EAAUwB,EAAOvB,GACrCqF,IACAA,EAAID,uBAAyB3P,IAGrCwL,UAAW,CAAClB,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GACtEmB,gBAAiB,CAAC,IAAM,2BAE5B+C,WAAY,CACRa,sBAAuBtE,EAAmB,oBAGlD6E,qBAAsB,CAClBC,gBAAiB,CACb3E,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,KACnB,MAAMqF,EAAMjF,EAAYL,EAAUwB,EAAOvB,GACzC,OAAOwF,EAAOC,WAAWJ,EAAIK,YAAaL,EAAIM,QAElDzE,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,KAC1B,MAAMqF,EAAMjF,EAAYL,EAAUwB,EAAOvB,GACzCqF,EAAIK,YAAYxE,IAAIzL,EAAMmQ,EAAGnQ,EAAMoQ,EAAGpQ,EAAMqQ,GAC5CT,EAAIM,MAAQlQ,EAAMsQ,GAEtB9E,UAAW,CAAClB,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAEtEmB,gBAAiB,CAAC,IAAM,cAAe,IAAM,UAEjD6E,iBAAkB,CACd9B,WAAY,CACRa,sBAAuBtE,EAAmB,mBAGlDwF,eAAgB,CACZrF,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAASkG,SACzEhF,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,KAC1B,MAAMqF,EAAMjF,EAAYL,EAAUwB,EAAOvB,GACrCqF,IACAA,EAAIa,SAAWzQ,IAGvBwL,UAAW,CAAClB,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GACtEmB,gBAAiB,CAAC,IAAM,aAE5BgF,gBAAiB,CACbvF,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAASoG,UACzElF,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,KAC1B,MAAMqF,EAAMjF,EAAYL,EAAUwB,EAAOvB,GACrCqF,IACAA,EAAIe,UAAY3Q,IAGxBwL,UAAW,CAAClB,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GACtEmB,gBAAiB,CAAC,IAAM,cAE5BkF,yBAA0B,CACtBnC,WAAY,CACRa,sBAAuBtE,EAAmB,sBAItDyD,WAAY,CACRoC,yBAA0B,CACtBC,mBAAoB,CAChB3F,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAASwG,WAAWjC,UACpFrD,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,KAC1BI,EAAYL,EAAUwB,EAAOvB,GAASwG,WAAWjC,UAAY9O,GAEjEwL,UAAW,CAAClB,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GACtEmB,gBAAiB,CAAC,IAAM,yBAE5BsF,mBAAoB,CAChB7F,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAASwG,WAAW1Q,MACpFoL,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,KAC1BI,EAAYL,EAAUwB,EAAOvB,GAASwG,WAAW1Q,MAAQL,GAE7DwL,UAAW,CAAClB,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GACtEmB,gBAAiB,CAAC,IAAM,qBAE5BuF,kBAAmB,CACfxC,WAAY,CACRa,sBAAuBtE,EAAmB,aAAc,cAIpEkG,wBAAyB,CACrBC,gBAAiB,CACbhG,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAAS6G,UAAUtC,UACnFrD,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,KAC1BI,EAAYL,EAAUwB,EAAOvB,GAAS6G,UAAUtC,UAAY9O,GAEhEwL,UAAW,CAAClB,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GACtEmB,gBAAiB,CAAC,IAAM,wBAE5B2F,yBAA0B,CACtBlG,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAAS6G,UAAUT,UACnFlF,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,KAC1BI,EAAYL,EAAUwB,EAAOvB,GAAS6G,UAAUT,UAAY3Q,GAEhEwL,UAAW,CAAClB,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GACtEmB,gBAAiB,CAAC,IAAM,wBAE5B4F,iBAAkB,CACd7C,WAAY,CACRa,sBAAuBtE,EAAmB,YAAa,aAG/DuG,uBAAwB,CACpB1F,MAAO,CACHV,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAAS6G,UAAUI,aAAahC,MAChGhE,UAAWb,EACXc,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,IAAaI,EAAYL,EAAUwB,EAAOvB,GAAS6G,UAAUI,YAAYhC,MAAQxP,GAEnHyO,WAAY,CACRa,sBAAuBtE,EAAmB,YAAa,iBAG/DyG,0BAA2B,CACvBhD,WAAY,CACRa,sBAAuBtE,EAAmB,YAAa,uBAInE0G,yBAA0B,CACtBC,WAAY,CACRxG,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAASqH,WAAWD,WACpFnG,UAAWb,EACXc,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,IAAaI,EAAYL,EAAUwB,EAAOvB,GAASqH,WAAWD,WAAa3R,IAGjH6R,gCAAiC,CAC7BC,iBAAkB,CACd3G,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAASwH,kBACzEvG,UAAWb,EACXc,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,IAAaI,EAAYL,EAAUwB,EAAOvB,GAASwH,kBAAoB/R,IAG7GgS,kBAAmB,CACfC,IAAK,CACD9G,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAAS2H,kBACzE1G,UAAWb,EACXc,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,IAAaI,EAAYL,EAAUwB,EAAOvB,GAAS2H,kBAAoBlS,IAG7GmS,0BAA2B,CACvBC,kBAAmB,CACfjH,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAAS8H,YAAYvD,UACrFtD,UAAWb,EACXc,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,IAAaI,EAAYL,EAAUwB,EAAOvB,GAAS8H,YAAYvD,UAAY9O,GAE7GsS,eAAgB,CACZnH,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAAS8H,YAAYH,kBACrF1G,UAAWb,EACXc,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,IAAaI,EAAYL,EAAUwB,EAAOvB,GAAS8H,YAAYH,kBAAoBlS,GAErHuS,mBAAoB,CAChB9D,WAAY,CACRa,sBAAuBtE,EAAmB,cAAe,aAGjEwH,4BAA6B,CACzBrH,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAAS8H,YAAYI,iBACrFjH,UAAWb,EACXc,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,IAAaI,EAAYL,EAAUwB,EAAOvB,GAAS8H,YAAYI,iBAAmBzS,GAEpH0S,4BAA6B,CACzBvH,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAAS8H,YAAYM,iBACrFnH,UAAWb,EACXc,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,IAAaI,EAAYL,EAAUwB,EAAOvB,GAAS8H,YAAYM,iBAAmB3S,GAEpH4S,4BAA6B,CACzBnE,WAAY,CACRa,sBAAuBtE,EAAmB,cAAe,uBAIrE6H,oBAAqB,CACjBC,iBAAkB,CACd3H,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAASwI,MAAM/D,MAC/ExD,UAAWb,EACXc,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAASwI,MAAM/D,MAAMzB,SAASvN,IAEzGgT,kBAAmB,CACfvE,WAAY,CACRa,sBAAuBtE,EAAmB,QAAS,aAG3DiI,qBAAsB,CAClB9H,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAASwI,MAAMjE,UAC/EtD,UAAWb,EACXc,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,IAAaI,EAAYL,EAAUwB,EAAOvB,GAASwI,MAAMjE,UAAY9O,GAEvGkT,sBAAuB,CACnBzE,WAAY,CACRa,sBAAuBtE,EAAmB,QAAS,uBAI/DmI,uBAAwB,CACpBC,eAAgB,CACZjI,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAAS8I,iBACzE7H,UAAWb,EACXc,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,IAAaI,EAAYL,EAAUwB,EAAOvB,GAAS8I,iBAAmBrT,EACpG0L,gBAAiB,CAAC,IAAM,qBAE5B4H,oBAAqB,CACjBnI,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAASgJ,yBACzE/H,UAAWb,EACXc,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAASgJ,yBAAyBhG,SAASvN,GAClH0L,gBAAiB,CAAC,IAAM,6BAE5B8H,gBAAiB,CACb/E,WAAY,CACRa,sBAAuBtE,EAAmB,gCAGlDyI,qBAAsB,CAClBhF,WAAY,CACRa,sBAAuBtE,EAAmB,yBAItD0I,2BAA4B,CACxBC,mBAAoB,CAChBxI,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAASqH,WAAWgC,oBACpFpI,UAAWb,EACXc,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,IAAaI,EAAYL,EAAUwB,EAAOvB,GAASqH,WAAWgC,oBAAsB5T,EAClH0L,gBAAiB,CAAC,IAAM,mCAE5BmI,oBAAqB,CACjBpF,WAAY,CACRa,sBAAuBtE,EAAmB,aAAc,iCAIpE8I,mCAAoC,CAChCC,0BAA2B,CACvB5I,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAASqH,WAAWoC,sBACpFxI,UAAWb,EACXc,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,IAAaI,EAAYL,EAAUwB,EAAOvB,GAASqH,WAAWoC,sBAAwBhU,GAExHiU,2BAA4B,CACxBxF,WAAY,CACRa,sBAAuBtE,EAAmB,aAAc,kCAGhEkJ,+BAAgC,CAC5B/I,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAASqH,WAAWuC,kBACpF3I,UAAWb,EACXc,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,IAAYvK,GAAS2K,EAAYL,EAAUwB,EAAOvB,GAASqH,WAAWuC,mBAAmB5G,SAASvN,IAEpIoU,gCAAiC,CAC7B3F,WAAY,CACRa,sBAAuBtE,EAAmB,aAAc,+BAIpEqJ,qBAAsB,CAClBC,iBAAkB,CACdnJ,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAASqH,WAAW2C,UACpF/I,UAAWb,EACXc,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAASqH,WAAW2C,UAAUhH,SAASvN,IAElHwU,oBAAqB,CACjBrJ,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAASqH,WAAW6C,oBACpFjJ,UAAWb,EACXc,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,IAAaI,EAAYL,EAAUwB,EAAOvB,GAASqH,WAAW6C,oBAAsBzU,GAEtH0U,gBAAiB,CACbvJ,KAAM,SACNC,IAAK,CAACd,EAAUwB,EAAOvB,IAAYI,EAAYL,EAAUwB,EAAOvB,GAASqH,WAAWa,iBACpFjH,UAAWb,EACXc,IAAK,CAACzL,EAAOsK,EAAUwB,EAAOvB,IAAaI,EAAYL,EAAUwB,EAAOvB,GAASqH,WAAWa,iBAAmBzS,GAEnH2U,iBAAkB,CACdlG,WAAY,CACRa,sBAAuBtE,EAAmB,aAAc,0BAoK5EyD,WA7JmB,CACnBmG,oBAAqB,CACjBC,OAAQ,CACJvL,OAAQ,CACJ6B,KAAM,SACNC,IAAMyJ,GAAWA,EAAOvL,OACxBkC,UAAYqJ,GAAWA,EAAO1H,KAAK4B,GAAUA,EAAM+F,gBACnDpJ,gBAAiB,CAAEqJ,GAAY,WAEnClL,UAAW,CACPK,YAAY,EACZ8E,MAAO,CACH7D,KAAM,SACNC,IAAM2D,GAAUA,EAAM+F,eAAe7F,QACrCxD,IAAK,CAACzL,EAAO+O,IAAUA,EAAM+F,eAAe7F,QAAQ1B,SAASvN,GAC7DwL,UAAYuD,GAAUA,EAAM+F,cAC5BpJ,gBAAiB,CAAEsJ,GAAW,YAElClG,UAAW,CACP3D,KAAM,SACNC,IAAM2D,GAAUA,EAAM+F,eAAehG,UACrCrD,IAAK,CAACzL,EAAO+O,IAAWA,EAAM+F,cAAiB/F,EAAM+F,cAAchG,UAAY9O,OAASiC,EACxFuJ,UAAYuD,GAAUA,EAAM+F,cAC5BpJ,gBAAiB,CAAEsJ,GAAW,cAElC9N,MAAO,CACHiE,KAAM,SACNC,IAAM2D,GAAUA,EAAM+F,eAAe5N,MACrCuE,IAAK,CAACzL,EAAO+O,IAAWA,EAAM+F,cAAiB/F,EAAM+F,cAAc5N,MAAQlH,OAASiC,EACpFuJ,UAAYuD,GAAUA,EAAM+F,cAC5BpJ,gBAAiB,CAAEsJ,GAAW,UAElCC,KAAM,CACFC,eAAgB,CACZ/J,KAAM,SACNC,IAAM2D,GAAUA,EAAM+F,eAAejU,WACrC4K,IAAK,CAACzL,EAAO+O,IAAWA,EAAM+F,cAAiB/F,EAAM+F,cAAcjU,WAAab,OAASiC,EACzFuJ,UAAYuD,GAAUA,EAAM+F,cAC5BpJ,gBAAiB,CAAEsJ,GAAW,mBAElCG,eAAgB,CACZhK,KAAM,SACNC,IAAM2D,GAAUA,EAAM+F,eAAezU,MACrCoL,IAAK,CAACzL,EAAO+O,IAAWA,EAAM+F,cAAiB/F,EAAM+F,cAAczU,MAAQL,OAASiC,EACpFuJ,UAAYuD,GAAUA,EAAM+F,cAC5BpJ,gBAAiB,CAAEsJ,GAAW,uBAMlDtG,eAAgB,CACZmG,OAAQ,CACJvL,OAAQ,CACJ6B,KAAM,SACNC,IAAMyJ,GAAWA,EAAOvL,OACxBkC,UAAYqJ,GAAWA,EAAO1H,KAAK4B,GAAUA,EAAM+F,gBACnDpJ,gBAAiB,CAAEqJ,GAAY,aAI3CK,uBAAwB,CACpBP,OAAQ,CACJvL,OAAQ,CACJ6B,KAAM,SACNC,IAAMyJ,GAAWA,EAAOvL,OACxBkC,UAAYqJ,GAAWA,EAAO1H,KAAK4B,GAAUA,EAAMsG,kBACnD3J,gBAAiB,CAAEqJ,GAAY,WAEnClL,UAAW,CACPK,YAAY,EACZ4E,UAAW,CACP3D,KAAM,SACNC,IAAM2D,GAAUA,EAAMsG,iBAAiB7F,MACvC/D,IAAK,CAACzL,EAAO+O,KACLA,EAAMsG,kBACNtG,EAAMsG,gBAAgB7F,MAAQxP,IAGtCwL,UAAYuD,GAAUA,EAAMsG,iBAEhC1J,SAAU,CACNR,KAAM,aACNC,IAAM2D,GAAUA,EAAMsG,iBAAmBC,EAAWC,mBAAmBxG,EAAMsG,iBAAiBG,8BAC9F/J,IAAK,CAACzL,EAAO+O,KACJA,EAAMsG,kBAINtG,EAAMsG,gBAAgBxR,YAAYyD,uBACnCtH,EAAQsV,EAAWG,QAAQzV,IAE/B2C,EAAO+S,oBAAoB1V,EAAO+O,EAAMsG,gBAAgBG,gCAE5DhK,UAAYuD,GAAUA,EAAMsG,qBAgE5CM,WAxmBmB,CACnBrM,OAAQ,CACJ6B,KAAM,SACNC,IAAMuK,GAAeA,EAAWrM,OAChCkC,UAAYmK,GAAeA,EAAWxI,KAAKyI,GAAcA,EAAUC,yBACnEnK,gBAAiB,CAAC,IAAM,WAE5B7B,UAAW,CAAE,GAkmBbiM,OAhmBe,CACfxM,OAAQ,CACJ6B,KAAM,SACNC,IAAM0K,GAAWA,EAAOxM,OACxBkC,UAAYsK,GAAWA,EAAO3I,KAAK4I,GAASA,EAAKC,WAAW,GAAGC,eAAeC,oBAC9ExK,gBAAiB,CAAC,IAAM,WAE5B7B,UAAW,CAAE,IAgmBV,SAASsM,EAAyBC,GACrC,OAAO,IAAI3N,EAA0B2N,EAAMrK,EAC/C,CAOO,SAASsK,EAAiBC,GAE7B,MAAMC,EAAWD,EAAIlN,MAAM,KAAK+D,KAAKxD,GAASA,EAAK6M,QAAQ,MAAO,eAClE,IAAIC,EAAU1K,EACd,IAAK,MAAMpC,KAAQ4M,EAEV5M,IAGL8M,EAAUA,EAAQ9M,IAGtB,GAAI8M,GAAWA,EAAQtL,MAAQsL,EAAQrL,IACnC,OAAOqL,CAGf,CAMO,SAASC,EAAuBJ,EAAKK,GAExC,MAAMJ,EAAWD,EAAIlN,MAAM,KAAK+D,KAAKxD,GAASA,EAAK6M,QAAQ,MAAO,eAClE,IAAIC,EAAU1K,EACd,IAAK,MAAMpC,KAAQ4M,EAEV5M,IAGL8M,EAAUA,EAAQ9M,IAGlB8M,GAAWA,EAAQtL,MAAQsL,EAAQrL,MACnCqL,EAAQE,cAAgBA,EAEhC,CAOO,SAASC,EAAuBN,EAAKO,GAExC,MAAMN,EAAWD,EAAIlN,MAAM,KAAK+D,KAAKxD,GAASA,EAAK6M,QAAQ,MAAO,eAClE,IAAIC,EAAU1K,EACd,IAAK,MAAMpC,KAAQ4M,EAEf,GAAK5M,EAAL,CAGA,IAAK8M,EAAQ9M,GAAO,CAChB,GAAa,MAATA,EAAc,CACd8M,EAAQ3M,sBAAuB,EAC/B,QAChB,CACY2M,EAAQ9M,GAAQ,CAAE,EAEL,cAATA,IACA8M,EAAQ9M,GAAMO,YAAa,EAE3C,CACQuM,EAAUA,EAAQ9M,EAZ1B,CAcImN,OAAOC,OAAON,EAASI,EAC3B"}