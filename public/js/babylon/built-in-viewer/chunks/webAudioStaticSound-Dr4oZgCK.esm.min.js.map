{"version":3,"file":"webAudioStaticSound-Dr4oZgCK.esm.min.js","sources":["../../../../../dev/core/dist/AudioV2/abstractAudio/staticSound.js","../../../../../dev/core/dist/AudioV2/abstractAudio/staticSoundBuffer.js","../../../../../dev/core/dist/AudioV2/abstractAudio/staticSoundInstance.js","../../../../../dev/core/dist/AudioV2/webAudio/webAudioStaticSound.js"],"sourcesContent":["import { AbstractSound } from \"./abstractSound\";\n/**\n * Abstract class representing a static sound.\n *\n * A static sound has a sound buffer that is loaded into memory all at once. This allows it to have more capabilities\n * than a streaming sound, such as loop points and playback rate changes, but it also means that the sound must be\n * fully downloaded and decoded before it can be played, which may take a long time for sounds with long durations.\n *\n * To prevent downloading and decoding a sound multiple times, a sound's buffer can be shared with other sounds.\n * See {@link CreateSoundBufferAsync}, {@link StaticSoundBuffer} and {@link StaticSound.buffer} for more information.\n *\n * Static sounds are created by the {@link CreateSoundAsync} function.\n */\nexport class StaticSound extends AbstractSound {\n    constructor(name, engine) {\n        super(name, engine);\n    }\n    /**\n     * The amount of time to play the sound for, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the sound plays for its full duration.\n     */\n    get duration() {\n        return this._options.duration;\n    }\n    set duration(value) {\n        this._options.duration = value;\n    }\n    /**\n     * The start of the loop range, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the loop starts at the beginning of the sound.\n     */\n    get loopStart() {\n        return this._options.loopStart;\n    }\n    set loopStart(value) {\n        this._options.loopStart = value;\n    }\n    /**\n     * The end of the loop range, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the loop plays for the sound's full duration.\n     */\n    get loopEnd() {\n        return this._options.loopEnd;\n    }\n    set loopEnd(value) {\n        this._options.loopEnd = value;\n    }\n    /**\n     * The pitch of the sound, in cents. Defaults to `0`.\n     * - Gets combined with {@link playbackRate} to determine the final pitch.\n     */\n    get pitch() {\n        return this._options.pitch;\n    }\n    set pitch(value) {\n        this._options.pitch = value;\n        const it = this._instances.values();\n        for (let instance = it.next(); !instance.done; instance = it.next()) {\n            instance.value.pitch = value;\n        }\n    }\n    /**\n     * The playback rate of the sound. Defaults to `1`.\n     * - Gets combined with {@link pitch} to determine the final playback rate.\n     */\n    get playbackRate() {\n        return this._options.playbackRate;\n    }\n    set playbackRate(value) {\n        this._options.playbackRate = value;\n        const it = this._instances.values();\n        for (let instance = it.next(); !instance.done; instance = it.next()) {\n            instance.value.playbackRate = value;\n        }\n    }\n    /**\n     * Plays the sound.\n     * - Triggers `onEndedObservable` if played for the full duration and the `loop` option is not set.\n     * @param options The options to use when playing the sound. Options set here override the sound's options.\n     */\n    play(options = {}) {\n        if (this.state === 5 /* SoundState.Paused */) {\n            this.resume();\n            return;\n        }\n        options.duration ??= this.duration;\n        options.loop ??= this.loop;\n        options.loopStart ??= this.loopStart;\n        options.loopEnd ??= this.loopEnd;\n        options.startOffset ??= this.startOffset;\n        options.volume ??= 1;\n        options.waitTime ??= 0;\n        const instance = this._createInstance();\n        this._beforePlay(instance);\n        instance.play(options);\n        this._afterPlay(instance);\n        this._stopExcessInstances();\n    }\n    /**\n     * Stops the sound.\n     * - Triggers `onEndedObservable` if the sound is playing.\n     * @param options - The options to use when stopping the sound.\n     */\n    stop(options = {}) {\n        if (options.waitTime && 0 < options.waitTime) {\n            this._setState(0 /* SoundState.Stopping */);\n        }\n        else {\n            this._setState(1 /* SoundState.Stopped */);\n        }\n        if (!this._instances) {\n            return;\n        }\n        for (const instance of Array.from(this._instances)) {\n            instance.stop(options);\n        }\n    }\n}\n//# sourceMappingURL=staticSound.js.map","let StaticSoundBufferId = 1;\n/**\n * Abstract class representing a static sound buffer.\n *\n * A static sound buffer is a fully downloaded and decoded array of audio data that is ready to be played.\n *\n * Static sound buffers can be reused multiple times by different {@link StaticSound} instances.\n *\n * Static sound buffers are created by the {@link CreateSoundBufferAsync} function.\n *\n * @see {@link StaticSound.buffer}\n */\nexport class StaticSoundBuffer {\n    constructor(engine) {\n        /**\n         * The name of the sound buffer.\n         */\n        this.name = `StaticSoundBuffer #${StaticSoundBufferId++}`;\n        this.engine = engine;\n    }\n}\n//# sourceMappingURL=staticSoundBuffer.js.map","import { _AbstractSoundInstance } from \"./abstractSoundInstance\";\n/** @internal */\nexport class _StaticSoundInstance extends _AbstractSoundInstance {\n}\n//# sourceMappingURL=staticSoundInstance.js.map","import { StaticSound } from \"../abstractAudio/staticSound\";\nimport { StaticSoundBuffer } from \"../abstractAudio/staticSoundBuffer\";\nimport { _StaticSoundInstance } from \"../abstractAudio/staticSoundInstance\";\nimport { _HasSpatialAudioOptions } from \"../abstractAudio/subProperties/abstractSpatialAudio\";\nimport { _StereoAudio } from \"../abstractAudio/subProperties/stereoAudio\";\nimport { _CleanUrl, _FileExtensionRegex } from \"../audioUtils\";\nimport { _WebAudioParameterComponent } from \"./components/webAudioParameterComponent\";\nimport { _WebAudioBusAndSoundSubGraph } from \"./subNodes/webAudioBusAndSoundSubGraph\";\nimport { _SpatialWebAudio } from \"./subProperties/spatialWebAudio\";\n/** @internal */\nexport class _WebAudioStaticSound extends StaticSound {\n    /** @internal */\n    constructor(name, engine, options) {\n        super(name, engine);\n        this._spatial = null;\n        this._spatialAutoUpdate = true;\n        this._spatialMinUpdateTime = 0;\n        this._stereo = null;\n        if (typeof options.spatialAutoUpdate === \"boolean\") {\n            this._spatialAutoUpdate = options.spatialAutoUpdate;\n        }\n        if (typeof options.spatialMinUpdateTime === \"number\") {\n            this._spatialMinUpdateTime = options.spatialMinUpdateTime;\n        }\n        this._options = {\n            autoplay: options.autoplay ?? false,\n            duration: options.duration ?? 0,\n            loop: options.loop ?? false,\n            loopEnd: options.loopEnd ?? 0,\n            loopStart: options.loopStart ?? 0,\n            maxInstances: options.maxInstances ?? Infinity,\n            pitch: options.pitch ?? 0,\n            playbackRate: options.playbackRate ?? 1,\n            startOffset: options.startOffset ?? 0,\n        };\n        this._subGraph = new _WebAudioStaticSound._SubGraph(this);\n    }\n    /** @internal */\n    async _initAsync(source, options) {\n        this._audioContext = this.engine._audioContext;\n        if (source instanceof _WebAudioStaticSoundBuffer) {\n            this._buffer = source;\n        }\n        else if (typeof source === \"string\" || Array.isArray(source) || source instanceof ArrayBuffer || source instanceof AudioBuffer) {\n            this._buffer = (await this.engine.createSoundBufferAsync(source, options));\n        }\n        if (options.outBus) {\n            this.outBus = options.outBus;\n        }\n        else if (options.outBusAutoDefault !== false) {\n            await this.engine.isReadyPromise;\n            this.outBus = this.engine.defaultMainBus;\n        }\n        await this._subGraph.initAsync(options);\n        if (_HasSpatialAudioOptions(options)) {\n            this._initSpatialProperty();\n        }\n        if (options.autoplay) {\n            this.play();\n        }\n        this.engine._addNode(this);\n    }\n    /** @internal */\n    get buffer() {\n        return this._buffer;\n    }\n    /** @internal */\n    get _inNode() {\n        return this._subGraph._inNode;\n    }\n    /** @internal */\n    get _outNode() {\n        return this._subGraph._outNode;\n    }\n    /** @internal */\n    get spatial() {\n        if (this._spatial) {\n            return this._spatial;\n        }\n        return this._initSpatialProperty();\n    }\n    /** @internal */\n    get stereo() {\n        return this._stereo ?? (this._stereo = new _StereoAudio(this._subGraph));\n    }\n    /** @internal */\n    async cloneAsync(options = null) {\n        const clone = await this.engine.createSoundAsync(this.name, options?.cloneBuffer ? this.buffer.clone() : this.buffer, this._options);\n        clone.outBus = options?.outBus ? options.outBus : this.outBus;\n        return clone;\n    }\n    /** @internal */\n    dispose() {\n        super.dispose();\n        this._spatial?.dispose();\n        this._spatial = null;\n        this._stereo = null;\n        this._subGraph.dispose();\n        this.engine._removeNode(this);\n    }\n    /** @internal */\n    getClassName() {\n        return \"_WebAudioStaticSound\";\n    }\n    _createInstance() {\n        return new _WebAudioStaticSoundInstance(this, this._options);\n    }\n    _connect(node) {\n        const connected = super._connect(node);\n        if (!connected) {\n            return false;\n        }\n        // If the wrapped node is not available now, it will be connected later by the subgraph.\n        if (node._inNode) {\n            this._outNode?.connect(node._inNode);\n        }\n        return true;\n    }\n    _disconnect(node) {\n        const disconnected = super._disconnect(node);\n        if (!disconnected) {\n            return false;\n        }\n        if (node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n        }\n        return true;\n    }\n    _initSpatialProperty() {\n        if (!this._spatial) {\n            this._spatial = new _SpatialWebAudio(this._subGraph, this._spatialAutoUpdate, this._spatialMinUpdateTime);\n        }\n        return this._spatial;\n    }\n}\n_WebAudioStaticSound._SubGraph = class extends _WebAudioBusAndSoundSubGraph {\n    get _downstreamNodes() {\n        return this._owner._downstreamNodes ?? null;\n    }\n    get _upstreamNodes() {\n        return this._owner._upstreamNodes ?? null;\n    }\n};\n/** @internal */\nexport class _WebAudioStaticSoundBuffer extends StaticSoundBuffer {\n    /** @internal */\n    constructor(engine) {\n        super(engine);\n    }\n    async _initAsync(source, options) {\n        if (source instanceof AudioBuffer) {\n            this._audioBuffer = source;\n        }\n        else if (typeof source === \"string\") {\n            await this._initFromUrlAsync(source);\n        }\n        else if (Array.isArray(source)) {\n            await this._initFromUrlsAsync(source, options.skipCodecCheck ?? false);\n        }\n        else if (source instanceof ArrayBuffer) {\n            await this._initFromArrayBufferAsync(source);\n        }\n    }\n    /** @internal */\n    get channelCount() {\n        return this._audioBuffer.numberOfChannels;\n    }\n    /** @internal */\n    get duration() {\n        return this._audioBuffer.duration;\n    }\n    /** @internal */\n    get length() {\n        return this._audioBuffer.length;\n    }\n    /** @internal */\n    get sampleRate() {\n        return this._audioBuffer.sampleRate;\n    }\n    /** @internal */\n    clone(options = null) {\n        const audioBuffer = new AudioBuffer({\n            length: this._audioBuffer.length,\n            numberOfChannels: this._audioBuffer.numberOfChannels,\n            sampleRate: this._audioBuffer.sampleRate,\n        });\n        for (let i = 0; i < this._audioBuffer.numberOfChannels; i++) {\n            audioBuffer.copyToChannel(this._audioBuffer.getChannelData(i), i);\n        }\n        const buffer = new _WebAudioStaticSoundBuffer(this.engine);\n        buffer._audioBuffer = audioBuffer;\n        buffer.name = options?.name ? options.name : this.name;\n        return buffer;\n    }\n    async _initFromArrayBufferAsync(arrayBuffer) {\n        this._audioBuffer = await this.engine._audioContext.decodeAudioData(arrayBuffer);\n    }\n    async _initFromUrlAsync(url) {\n        url = _CleanUrl(url);\n        await this._initFromArrayBufferAsync(await (await fetch(url)).arrayBuffer());\n    }\n    async _initFromUrlsAsync(urls, skipCodecCheck) {\n        for (const url of urls) {\n            if (skipCodecCheck) {\n                // eslint-disable-next-line no-await-in-loop\n                await this._initFromUrlAsync(url);\n            }\n            else {\n                const matches = url.match(_FileExtensionRegex);\n                const format = matches?.at(1);\n                if (format && this.engine.isFormatValid(format)) {\n                    try {\n                        // eslint-disable-next-line no-await-in-loop\n                        await this._initFromUrlAsync(url);\n                    }\n                    catch {\n                        if (format && 0 < format.length) {\n                            this.engine.flagInvalidFormat(format);\n                        }\n                    }\n                }\n            }\n            if (this._audioBuffer) {\n                break;\n            }\n        }\n    }\n}\n/** @internal */\nclass _WebAudioStaticSoundInstance extends _StaticSoundInstance {\n    constructor(sound, options) {\n        super(sound);\n        this._enginePlayTime = 0;\n        this._enginePauseTime = 0;\n        this._isConnected = false;\n        this._pitch = null;\n        this._playbackRate = null;\n        this._sourceNode = null;\n        this._onEnded = () => {\n            this._enginePlayTime = 0;\n            this.onEndedObservable.notifyObservers(this);\n            this._deinitSourceNode();\n        };\n        this._onEngineStateChanged = () => {\n            if (this.engine.state !== \"running\") {\n                return;\n            }\n            if (this._options.loop && this.state === 2 /* SoundState.Starting */) {\n                this.play();\n            }\n            this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n        };\n        this._options = options;\n        this._volumeNode = new GainNode(sound._audioContext);\n        this._initSourceNode();\n    }\n    /** @internal */\n    dispose() {\n        super.dispose();\n        this._pitch?.dispose();\n        this._playbackRate?.dispose();\n        this._sourceNode = null;\n        this.stop();\n        this._deinitSourceNode();\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    }\n    /** @internal */\n    get currentTime() {\n        if (this._state === 1 /* SoundState.Stopped */) {\n            return 0;\n        }\n        const timeSinceLastStart = this._state === 5 /* SoundState.Paused */ ? 0 : this.engine.currentTime - this._enginePlayTime;\n        return this._enginePauseTime + timeSinceLastStart + this._options.startOffset;\n    }\n    set currentTime(value) {\n        const restart = this._state === 2 /* SoundState.Starting */ || this._state === 3 /* SoundState.Started */;\n        if (restart) {\n            this.stop();\n            this._deinitSourceNode();\n        }\n        this._options.startOffset = value;\n        if (restart) {\n            this.play();\n        }\n    }\n    get _outNode() {\n        return this._volumeNode;\n    }\n    /** @internal */\n    set pitch(value) {\n        this._pitch?.setTargetValue(value);\n    }\n    /** @internal */\n    set playbackRate(value) {\n        this._playbackRate?.setTargetValue(value);\n    }\n    /** @internal */\n    get startTime() {\n        if (this._state === 1 /* SoundState.Stopped */) {\n            return 0;\n        }\n        return this._enginePlayTime;\n    }\n    /** @internal */\n    getClassName() {\n        return \"_WebAudioStaticSoundInstance\";\n    }\n    /** @internal */\n    play(options = {}) {\n        if (this._state === 3 /* SoundState.Started */) {\n            return;\n        }\n        if (options.duration !== undefined) {\n            this._options.duration = options.duration;\n        }\n        if (options.loop !== undefined) {\n            this._options.loop = options.loop;\n        }\n        if (options.loopStart !== undefined) {\n            this._options.loopStart = options.loopStart;\n        }\n        if (options.loopEnd !== undefined) {\n            this._options.loopEnd = options.loopEnd;\n        }\n        if (options.startOffset !== undefined) {\n            this._options.startOffset = options.startOffset;\n        }\n        let startOffset = this._options.startOffset;\n        if (this._state === 5 /* SoundState.Paused */) {\n            startOffset += this.currentTime;\n            startOffset %= this._sound.buffer.duration;\n        }\n        this._enginePlayTime = this.engine.currentTime + (options.waitTime ?? 0);\n        this._volumeNode.gain.value = options.volume ?? 1;\n        this._initSourceNode();\n        if (this.engine.state === \"running\") {\n            this._setState(3 /* SoundState.Started */);\n            this._sourceNode?.start(this._enginePlayTime, startOffset, this._options.duration > 0 ? this._options.duration : undefined);\n        }\n        else if (this._options.loop) {\n            this._setState(2 /* SoundState.Starting */);\n            this.engine.stateChangedObservable.add(this._onEngineStateChanged);\n        }\n    }\n    /** @internal */\n    pause() {\n        if (this._state === 5 /* SoundState.Paused */) {\n            return;\n        }\n        this._setState(5 /* SoundState.Paused */);\n        this._enginePauseTime += this.engine.currentTime - this._enginePlayTime;\n        this._sourceNode?.stop();\n        this._deinitSourceNode();\n    }\n    /** @internal */\n    resume() {\n        if (this._state === 5 /* SoundState.Paused */) {\n            this.play();\n        }\n    }\n    /** @internal */\n    stop(options = {}) {\n        if (this._state === 1 /* SoundState.Stopped */) {\n            return;\n        }\n        this._setState(1 /* SoundState.Stopped */);\n        const engineStopTime = this.engine.currentTime + (options.waitTime ?? 0);\n        this._sourceNode?.stop(engineStopTime);\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    }\n    _connect(node) {\n        const connected = super._connect(node);\n        if (!connected) {\n            return false;\n        }\n        // If the wrapped node is not available now, it will be connected later by the sound's subgraph.\n        if (node instanceof _WebAudioStaticSound && node._inNode) {\n            this._outNode?.connect(node._inNode);\n            this._isConnected = true;\n        }\n        return true;\n    }\n    _disconnect(node) {\n        const disconnected = super._disconnect(node);\n        if (!disconnected) {\n            return false;\n        }\n        if (node instanceof _WebAudioStaticSound && node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n            this._isConnected = false;\n        }\n        return true;\n    }\n    _deinitSourceNode() {\n        if (!this._sourceNode) {\n            return;\n        }\n        if (this._isConnected && !this._disconnect(this._sound)) {\n            throw new Error(\"Disconnect failed\");\n        }\n        this._sourceNode.disconnect(this._volumeNode);\n        this._sourceNode.removeEventListener(\"ended\", this._onEnded);\n        this._sourceNode = null;\n    }\n    _initSourceNode() {\n        if (!this._sourceNode) {\n            this._sourceNode = new AudioBufferSourceNode(this._sound._audioContext, { buffer: this._sound.buffer._audioBuffer });\n            this._sourceNode.addEventListener(\"ended\", this._onEnded, { once: true });\n            this._sourceNode.connect(this._volumeNode);\n            if (!this._connect(this._sound)) {\n                throw new Error(\"Connect failed\");\n            }\n            this._pitch = new _WebAudioParameterComponent(this.engine, this._sourceNode.detune);\n            this._playbackRate = new _WebAudioParameterComponent(this.engine, this._sourceNode.playbackRate);\n        }\n        const node = this._sourceNode;\n        node.detune.value = this._sound.pitch;\n        node.loop = this._options.loop;\n        node.loopEnd = this._options.loopEnd;\n        node.loopStart = this._options.loopStart;\n        node.playbackRate.value = this._sound.playbackRate;\n    }\n}\n//# sourceMappingURL=webAudioStaticSound.js.map"],"names":["StaticSound","AbstractSound","constructor","name","engine","super","duration","this","_options","value","loopStart","loopEnd","pitch","it","_instances","values","instance","next","done","playbackRate","play","options","state","resume","loop","startOffset","volume","waitTime","_createInstance","_beforePlay","_afterPlay","_stopExcessInstances","stop","_setState","Array","from","StaticSoundBufferId","StaticSoundBuffer","_StaticSoundInstance","_AbstractSoundInstance","_WebAudioStaticSound","_spatial","_spatialAutoUpdate","_spatialMinUpdateTime","_stereo","spatialAutoUpdate","spatialMinUpdateTime","autoplay","maxInstances","Infinity","_subGraph","_SubGraph","_initAsync","source","_audioContext","_WebAudioStaticSoundBuffer","_buffer","isArray","ArrayBuffer","AudioBuffer","createSoundBufferAsync","outBus","outBusAutoDefault","isReadyPromise","defaultMainBus","initAsync","_HasSpatialAudioOptions","_initSpatialProperty","_addNode","buffer","_inNode","_outNode","spatial","stereo","_StereoAudio","cloneAsync","clone","createSoundAsync","cloneBuffer","dispose","_removeNode","getClassName","_WebAudioStaticSoundInstance","_connect","node","connect","_disconnect","disconnect","_SpatialWebAudio","_WebAudioBusAndSoundSubGraph","_downstreamNodes","_owner","_upstreamNodes","_audioBuffer","_initFromUrlAsync","_initFromUrlsAsync","skipCodecCheck","_initFromArrayBufferAsync","channelCount","numberOfChannels","length","sampleRate","audioBuffer","i","copyToChannel","getChannelData","arrayBuffer","decodeAudioData","url","_CleanUrl","fetch","urls","matches","match","_FileExtensionRegex","format","at","isFormatValid","flagInvalidFormat","sound","_enginePlayTime","_enginePauseTime","_isConnected","_pitch","_playbackRate","_sourceNode","_onEnded","onEndedObservable","notifyObservers","_deinitSourceNode","_onEngineStateChanged","stateChangedObservable","removeCallback","_volumeNode","GainNode","_initSourceNode","currentTime","_state","timeSinceLastStart","restart","setTargetValue","startTime","undefined","_sound","gain","start","add","pause","engineStopTime","Error","removeEventListener","AudioBufferSourceNode","addEventListener","once","_WebAudioParameterComponent","detune"],"mappings":"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"}